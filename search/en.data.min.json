[{"id":0,"href":"/introduction/","title":"Introduction","parent":"Index","content":"In this section we will explore what RIDDL is, by answering these questions:\nWhat Is RIDDL? What can RIDDL do? What is RIDDL Based On? Who Can Benefit From RIDDL? Who Made RIDDL Possible? How Can I Get Help? Click on the above links to explore this section; or, go to the next recommended section: Conceptual Overview.\n"},{"id":1,"href":"/","title":"Index","parent":"","content":"IDDL is a language and toolset for specifying a system design. RIDDL is not a programming language, but it uses ideas from prior works, unique combinations of those ideas, and some original ideas.\nBefore we get into the details, let\u0026rsquo;s review the structure of this documentation, so that you may utilize it efficiently.\nEveryone should read the Introduction section as it provides a high level introduction to RIDDL, defines what RIDDL is, what it can do, what it is based upon, who helped it come to fruition, and how to get help. Definitely start with the Introduction if you\u0026rsquo;re new to RIDDL.\nEveryone should also read the Conceptual Overview which describes the various definitional concepts used by RIDDL. This section will give you a complete understanding of the ideas used in RIDDL, without worrying about the syntax of the language that is used to express those ideas.\nPeople involved with RIDDL come from many professional roles so there are Guides that provide learning paths for those various roles.\nFor those that like to learn incrementally, there is a Tutorial that walks the reader through the construction of a RIDDL model for a restaurant chain, and the resulting software system to operate it.\nIf you want to dive into the technical specification for the RIDDL language, you can go to the Language section and learn the language syntax and grammar.\nIf you want to learn to use the tools that RIDDL provides, you can go to the Tooling section and learn how to install and use them.\nIf you\u0026rsquo;re interested in knowing how we plan to extend RIDDl in the future, please review our Future Work section.\nFull Index Search Result Introduction What Is RIDDL? What can RIDDL do? What is RIDDL Based On? Who Can Benefit From RIDDL? Who Made RIDDL Possible? How Can I Get Help? Concepts Action Actor Adaptor Application Application Element Author Context Definition Description Domain Entity Example Expression Field Function Group Handlers Includes Inlets Input Invariants Joints Messages On Clauses Options Outlets Output Pipes Plants Processors Projections Root Root Saga Steps Sagas States Stories Story Case Terms Types Vital Definitions Guides Domain Expert\u0026#39;s Guide Author\u0026#39;s Guide Syntax Cheat Sheet Syntax Reference Design Tips Design Patterns Command/Event Patterns 1 - Same Event 2 - Same Parameters 3 - Optional or List Parameters 4 - Surfaced Parameters Implementor\u0026#39;s Guide Different Ways To Get/Use RIDDL Developer\u0026#39;s Guide Checking Documentation Principles Grammar Terminals Common Domain Context Entity Root Dependencies testing Releasing RIDDL Reactive Summit Language Common Documentation Conventions Language Conventions Descriptions Identifiers Examples Types Expressions Includes Functions Imports Options Root Domain Context Entities Options State Invariants Entity Handler Function Adaptors Projections Saga Features Context Handler Story Streaming Pipes Processors Plants Tooling riddlc riddlc --help Download and install a release How To Build `riddlc` Using riddlc/actions/get-riddlc@main Installing `riddlc` riddlc Config File Compilation Compiling RIDDL Translation riddlc options Hugo Docs sbt-riddl Getting Ready To Go IntelliJ Plugin VSCode Plugin Tutorial Example Reactive BBQ Case Study CEO of Reactive BBQ Corporate Head Chef Host Server Bartender Chef Cook Delivery Driver Online Customer RBBQ Scenarios Reactive BBQ Restaurant Back Office Corporate Future Work Analyses Binary AST Diagrams OpenAPI Kalix Akka Other Translators Privacy Policy "},{"id":2,"href":"/future-work/analyses/","title":"Analyses","parent":"Future Work","content":" Uses/Used-by Common to many programming language compilers, RIDDL too needs to be able to generate a pair of maps\nuses = key is a definition, value is a list of definitions used by the key used-by = key is a definition, value is a list of definitions that use the key "},{"id":3,"href":"/concepts/","title":"Concepts","parent":"Index","content":"In this section we will explore the concepts and ideas that RIDDL uses. This is not about the RIDDL language syntax, but about the concepts that the language uses and how they relate to each other.\nDefinitions RIDDL consists only of definitions that define the design of the desired system.\nDefinitional Hierarchy Definitions in RIDDL are arranged in a hierarchy. Definitions that contain other definitions are known as containers or parents. Definitions that do not contain other definitions are known as leaves.\nThis is done simply by having an attribute that lists the contents of any definition:\ncontents: The contained definitions that define the container. Not all definitions can contain other ones so sometimes this is empty. Simplifications The valid hierarchy structure is shown below, but to make this hierarchy easier to comprehend, we\u0026rsquo;ve taken some short-cuts :\nAll the common attributes have been omitted for brevity but are implied on each line of the hierarchy. We only descend as far as an Example definition; but you should infer this extended hierarchy wherever an Example occurs: Examples Actions Expressions We only descend as far as a Type definition. Whenever you see one, you should infer this hierarchy: Types Fields Hierarchy With those clarifying simplifications, here\u0026rsquo;s the hierarchy:\nRoot Domain Type Application Type Group Output Input Handler Story Case Example Context Type Entity Type Function Example State Type Field [Handler](/concepts/handler/ On Clause Example Invariant Expression Handler On Clause Example Handler On Clause Example Projection Type Field Handler On Clause Example Saga Type SagaStep Example Adaptor Type Handler On Clause Example Processor Type Inlet Outlet Example Function Example Plant Processor Type Inlet Outlet Example InletJoint OutletJoint Pipe Next When you\u0026rsquo;re done exploring all the concepts, check out our guides next.\nFull Index Action Actor Adaptor Application Application Element Author Context Definition Description Domain Entity Example Expression Field Function Group Handlers Includes Inlets Input Invariants Joints Messages On Clauses Options Outlets Output Pipes Plants Processors Projections Root Root Saga Steps Sagas States Stories Story Case Terms Types Vital Definitions "},{"id":4,"href":"/tooling/riddlc/translation/options/","title":"riddlc options","parent":"Translation","content":" Introduction Like many other complex programs, riddlc implements a variety of commands, each with their own functionality and their own options. As there are overlaps\nOptions come and go as riddlc evolves. If you experience issues with the command line options, you can always run riddlc without any options and it will explain the options your version supports. Common Options Some options are common to all the commands.\n-h (\u0026ndash;help) Causes riddlc to print out help and usage information and exit.\n-t (\u0026ndash;show-times) Translation is done in various stages (parsing, validating, loading, translating, etc.). This option causes riddlc to print out how long each of these stages takes\n-v (\u0026ndash;verbose) Causes riddlc to be more verbose in its output, what it is doing, etc. So far this doesn\u0026rsquo;t add any additional output but the option is reserved for this use case.\n-q (\u0026ndash;quiet) Do not print out any output, just do the requested command.\n-d (\u0026ndash;dry-run) Go through the motions of processing the options and teeing up the command to run, but don\u0026rsquo;t actually run it.\n-w (\u0026ndash;suppress-warnings) Causes all warnings to be squelched from the output. riddlc has many general warnings, lots of warnings about missing things, and even stylistic or idiomatic suggestions. This option suppresses all of them to make the output less verbose.\n-m (\u0026ndash;suppress-missing-warnings) Warnings about missing constructs are normally turned off, this option turns them back on so the messages are put out by riddlc. This can be quiet verbose in early RIDDL specifications that do not have much documentation in them.\n-s (\u0026ndash;suppress-style-warnings) Warnings about RIDDL style are normally turned off, this option turns them back on so the messages are put out by riddlc\nparse [options] Command The parse command causes riddlc to only parse the provided RIDDL file for syntactic compliance with the RIDDL language. No validation or translation is done on the input. Note that riddlc terminates after the first syntax error message has printed.\nIn addition to the common options, you can specify the options described in the following subsections.\n-i (--input-file) This is a required option that provides the file to be parsed.\nvalidate [options] Command This command does everything that the parse command does, but also semantically validates the input if parsing succeeds.\nIn addition to the common options, you can specify the options described in the following subsections.\n-i (--input-file) This is a required option that provides the file to be parsed.\nreformat [options] Command This command regurgitates its input but in a consistent style with options to affect that style in various ways.\nIn addition to the common options, you can specify the options described in the following subsections.\n-i (--input-file) This is a required option that provides the file to be parsed.\n-o (--output-dir) This is a required option that provides the directory into which the output will be placed. Generated files will have the same names as the input files.\n-s (--single-file) This option causes all the include statements in the input to be removed and the entire input generated into a single file.\nCurrently this option is forced on whether you specify the option or not. The only output supported is a single file. This will be remedied in a later release. hugo [options] Command This command causes riddlc to parse, validate and translate its input into the input needed for a hugo based website that described the RIDDL input.\nIn addition to the common options, you can specify the options described in the following subsections.\n-i (--input-file) This is a required option that provides the file to be translated to a hugo website.\n-o (--output-dir) This is a required option that provides the directory into which the hugo website source files will be placed.\n-p, --project-name \u0026lt;value\u0026gt; This options provides the hugo command with the overall name of the project that is being described by the RIDDL input. This is used in the meta tags for the title of the page, and other places where the title is needed.\n-e, --erase-output \u0026lt;value\u0026gt; Erase the entire output directory before putting out any files.\nIt is highly recommended that you use this option, but it defaults to off to prevent the new user from deleting the wrong directory structure. All files under --output-dir will be unceremoniously deleted so specifying --output-dir incorrectly can yield significant data loss. -b, --base-url \u0026lt;value\u0026gt; This option provides the first part of the URL at which the generated site is publicly accessible. It defaults to http://localhost:1313 which is the default for hugo.\n-s, --source-url \u0026lt;value\u0026gt; The generated site offers the ability to link to the source document for any page. The \u0026lt;value\u0026gt; provided must be a valid URL for a website.\nThis corresponds to the geekdoc hugo theme\u0026rsquo;s geekdocRepo parameter. -h, --edit-path \u0026lt;value\u0026gt; This option is used to extend the funtionality of the --source-url option to allow editing as well as linking to the source. This option provides the source repository\u0026rsquo;s intermediate URL path that can be used to edit a page.\n-l, --site-logo-url \u0026lt;value\u0026gt; URL to the site\u0026rsquo;s logo image for use by hugo\nhugo-git-check [options] Command This command is the same as the hugo command, and takes the same options, except you also provide a URL to a directory in a git repository. Any changes to the git repository below that direction, as reported by git, will cause the hugo command to run. Otherwise nothing happens. This allows an auto-update upon changes when combined with the repeat command.\nfrom \u0026lt;path-to-config-file\u0026gt; Command This command repeats\nrepeat \u0026lt;cycle-delay\u0026gt; \u0026lt;max-cycles\u0026gt; \u0026lt;path-to-config-file Command This command repeats whichever command is specified in the configuration file at \u0026lt;path-to-config-file\u0026gt;. It will cycle \u0026lt;max-cycles\u0026gt; times and insert a delay of \u0026lt;cycle-delay\u0026gt; which must be specified with a duration suffix like s(seconds) m(minutes), etc. The full set of possibilities are defined here\nthe input needed for a hugo based website that described the RIDDL input.\nIn addition to the common options, you can specify the options described in the following subsections.\nOptions From Configuration Files The from and repeat commands use HOCON configuration files to determine what to do. The HOCON syntax is [fully explained here](https://github. com/lightbend/config/blob/main/HOCON.md) but it is simpler than that in the case of riddlc, just follow these rules:\nAssign the command you want to run to the \u0026ldquo;command\u0026rdquo; option. All the common options can be specified at the top level. Command specific options must appear in a section named after the command. All the configuration items have the same names as the long form names that\nriddlc prints out with the help command. So, for example, to reformat a file to another file without warnings you could set up a configuration file like this:\ncommand = reformat suppress-warnings = true reformat { input-file = \u0026#34;path/to/input.riddl\u0026#34; output-dir = \u0026#34;path/to/output/dir\u0026#34; single-file = true } Similarly for other commands. You can even specify all the options for all the commands and then just change the command selector when you want to do something different. Or, put them each in separate files and use commandline completion to specify which file.\nExample of riddlc help command RIDDL Compiler (c) 2022 Reactive Software LLC. All rights reserved. Version: 0.2.1-131-f6486929 This program parses, validates and translates RIDDL sources to other kinds of documents. RIDDL is a language for system specification based on Domain Drive Design, Reactive Architecture, and Agile principles. Usage: riddlc [parse|validate|reformat|hugo|hugo-git-check|from|help|repeat] [options] \u0026lt;args\u0026gt;... -V | --version -h | --help Print out help/usage information and exit -t | --show-times Show compilation phase execution times -d \u0026lt;value\u0026gt; | --dry-run \u0026lt;value\u0026gt; go through the motions but don\u0026#39;t write any changes -v | --verbose Provide detailed, step-by-step, output detailing riddlc\u0026#39;s actions -q | --quiet Do not print out any output, just do the requested command -w | --suppress-warnings Suppress all warning messages so only errors are shown -m | --suppress-missing-warnings Show warnings about things that are missing -s | --suppress-style-warnings Show warnings about questionable input style. Command: parse [options] Parse the input for syntactic compliance with riddl language. No validation or translation is done on the input -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt; required riddl input file to read Command: validate [options] Parse the input and if successful validate the resulting model. No translation is done on the input. -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt; required riddl input file to read Command: reformat [options] Parse and validate the input-file and then reformat it to a standard layout written to the output-dir. -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt; required riddl input file to read -o \u0026lt;value\u0026gt; | --output-dir \u0026lt;value\u0026gt; required output directory for the generated output -s \u0026lt;value\u0026gt; | --single-file \u0026lt;value\u0026gt; Resolve all includes and imports and write a single file with the same file name as the input placed in the out-dir Command: hugo [options] Parse and validate the input-file and then translate it into the input needed for hugo to translate it to a functioning web site. -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt; required riddl input file to read -o \u0026lt;value\u0026gt; | --output-dir \u0026lt;value\u0026gt; required output directory for the generated output -p \u0026lt;value\u0026gt; | --project-name \u0026lt;value\u0026gt; Optional project name to associate with the generated output -e \u0026lt;value\u0026gt; | --erase-output \u0026lt;value\u0026gt; Erase entire output directory before putting out files -b \u0026lt;value\u0026gt; | --base-url \u0026lt;value\u0026gt; Optional base URL for root of generated http URLs -t \u0026lt;value\u0026gt; | --themes \u0026lt;value\u0026gt; -s \u0026lt;value\u0026gt; | --source-url \u0026lt;value\u0026gt; URL to the input file\u0026#39;s Git Repository -h \u0026lt;value\u0026gt; | --edit-path \u0026lt;value\u0026gt; Path to add to source-url to allow editing -l \u0026lt;value\u0026gt; | --site-logo-url \u0026lt;value\u0026gt; URL to the site\u0026#39;s logo image for use by site -p \u0026lt;value\u0026gt; | --site-logo-path \u0026lt;value\u0026gt; Path, in \u0026#39;static\u0026#39; directory to placement and use of the site logo. Command: hugo-git-check [options] git-clone-dir This command checks the \u0026lt;git-clone-dir\u0026gt; directory for new commits and does a `git pull\u0026#34; command there if it finds some; otherwise it does nothing. If commits were pulled from the repository, then the hugo command is run to generate the hugo source files and hugo is run to make the web site available at hugo\u0026#39;s default local web address: |http://localhost:1313/ git-clone-dir Provides the top directory of a git repo clone that contains the \u0026lt;input-file\u0026gt; to be processed. -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt; required riddl input file to read -o \u0026lt;value\u0026gt; | --output-dir \u0026lt;value\u0026gt; required output directory for the generated output -p \u0026lt;value\u0026gt; | --project-name \u0026lt;value\u0026gt; Optional project name to associate with the generated output -e \u0026lt;value\u0026gt; | --erase-output \u0026lt;value\u0026gt; Erase entire output directory before putting out files -b \u0026lt;value\u0026gt; | --base-url \u0026lt;value\u0026gt; Optional base URL for root of generated http URLs -t \u0026lt;value\u0026gt; | --themes \u0026lt;value\u0026gt; -s \u0026lt;value\u0026gt; | --source-url \u0026lt;value\u0026gt; URL to the input file\u0026#39;s Git Repository -h \u0026lt;value\u0026gt; | --edit-path \u0026lt;value\u0026gt; Path to add to source-url to allow editing -l \u0026lt;value\u0026gt; | --site-logo-url \u0026lt;value\u0026gt; URL to the site\u0026#39;s logo image for use by site -p \u0026lt;value\u0026gt; | --site-logo-path \u0026lt;value\u0026gt; Path, in \u0026#39;static\u0026#39; directory to placement and use of the site logo. Command: from [options] config-file Load riddlc options from a config file config-file A HOCON configuration file with riddlc options -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt; required riddl input file to read -o \u0026lt;value\u0026gt; | --output-dir \u0026lt;value\u0026gt; required output directory for the generated output Command: help Print out how to use this program Command: repeat config-file [refresh-rate] [max-cycles] This command supports the edit-build-check cycle. It doesn\u0026#39;t end until \u0026lt;max-cycles\u0026gt; has completed or EOF is reached on standard input. During that time, the selected subcommands are repeated. config-file The path to the configuration file that should be repeated refresh-rate Specifies the rate at which the \u0026lt;git-clone-dir\u0026gt; is checked for updates so the process to regenerate the hugo site is started max-cycles Limit the number of check cycles that will be repeated. -n | --interactive This option causes the repeat command to read from the standard input and when it reaches EOF (Ctrl-D is entered) then it cancels the loop to exit. "},{"id":5,"href":"/guides/domain-experts/","title":"Domain Expert's Guide","parent":"Guides","content":"Domain experts (DEs) are subject matter experts (SMEs) in some knowledge or problem domain. They are the authority on the language used to describe both problems and solutions within their domain or field of expertise. These individuals are recognized authorities, and they influence an organization\u0026rsquo;s product, service or strategic direction.\nDomain experts may or may not be in leadership positions, but they are people who are broadly trusted for their knowledge of business rules, processes, technical details, and system requirements.\nThese are the EF_Huttons of the organization.\nWhile not a comprehensive list, these people may be Architects, Analysts, Developers, Managers, QA Engineers, or even Call Center Agents, and line workers from the warehouse.\nDomain Experts do not need to be well versed in DDD or Reactive Architecture initially. It is the job of the Author to act as a guide and mentor through these topics. But Domain Experts must be open to change what is for what could be. Reactive Architectures can be very challenging for people to digest. More specifically, quite often techniques used to implement distributed and reactive systems will change user experiences, expectations of consistency and availability, the means used to monitor and maintain systems and processes, and so on. Domain experts will need to come to understand the reasons for these changes and be able to evangelize them as they interact with their peers.\n"},{"id":6,"href":"/tooling/riddlc/","title":"riddlc","parent":"Tooling","content":"This section covers how use the riddlc tool.\nriddlc --help Download and install a release How To Build `riddlc` Using riddlc/actions/get-riddlc@main Installing `riddlc` riddlc Config File Compilation Compiling RIDDL Translation riddlc options Hugo Docs "},{"id":7,"href":"/tutorial/rbbq/scenario/","title":"Reactive BBQ Case Study","parent":"Example","content":" About Reactive BBQ The Reactive BBQ domain is a familiar one for those who have taken the Lightbend Reactive Architecture Professional (LRA-P) course. That course uses this example throughout to good effect in the workshops. The same premises apply in this tutorial. We go deeper into reactive architecture by having you specify portions of it in RIDDL.\nAs you might guess from the name, Reactive BBQ is a restaurant chain that serves spicy (reactive!) BBQ dishes. It doesn\u0026rsquo;t exist of course, even if we may or may not have mistaken R\u0026amp;R BBQ in Salt Lake City for the Reactive version in 2018.\nThe Reactive BBQ case study in the LRA-P course included interviews with several fictitious employees. Those interviews and the case study material have been replicated here with thanks to Lightbend; we recommend that you read through this case study first.\nThe RIDDL files for Reactive BBQ are arranged into a directory structure, each with an explanation page as follows:\nReactive BBQ Domain Restaurant BackOffice Corporate Case Study The Reactive BBQ restaurant chain has determined that their existing restaurant operations system is not suitably meeting their needs and have hired a high technology consulting company (you) to provide some needed guidance on how they can improve their customer service, tracking, and reliability.\nWhat follows are the interviews conducted with key personnel at Reactive BBQ in order to identify the issues.\nReactive BBQ CEO Corporate Head Chef Host Server Bartender Chef Cook Delivery Driver Online Customer "},{"id":8,"href":"/tutorial/rbbq/scenario/ceo/","title":"CEO of Reactive BBQ","parent":"Reactive BBQ Case Study","content":"How would you describe your restaurants?\nReactive BBQ is a family restaurant with 500 locations across 20 countries. We\u0026rsquo;re open for breakfast, lunch and supper. Our specialty at Reactive BBQ is our award winning Reactive Ribs, but we are also well known for our tender steaks and our slow roasted chicken. We take traditional BBQ flavours and give them a bit of a spicy punch. The customer experience at each Reactive BBQ should have the same high level of quality across the globe.\nWhat challenges do you face?\nThe challenge is that our original system was designed for one restaurant, and as more were opened, we started moving into the cloud. We started by moving inventory management into the cloud. Then we moved the customers facing areas: reservations, ordering etc. into the same application. We created a website on top of this so that customers can place orders for pickup or delivery, but they can also make reservations online.\nAs we add more locations, the system becomes unresponsive during peak hours as it seems to be struggling to keep up with all the reservations, the servers entering orders, orders being filled, payments, all of these drag everything down to a crawl. Staff gets frustrated, customers even more so, it can take 30 seconds to make a reservation, or enter an order.\nThe Operations team attempted to address the peak time performance issue by adding more instances of the application in the cloud, but this turned out to be quite expensive, and we still see a noticeable lag in response times during peak hours.\nAnother issue is that our application seems to be brittle. When one thing goes wrong, it seems like everything else goes wrong at the same time. I keep hearing reports of outages across the board. And these outages have a huge impact on our business. In the early days, when a problem happened, it affected a single restaurant. But now that we are in the cloud, when the application becomes unavailable it can affect many restaurants or even all of them.\nWe have been forced to limit certain activities during certain times of the day. For example, during the lunch hour on the east coast we aren\u0026rsquo;t allowed to generate certain kinds of reports. The same applies for the west coast. As our operation expands into more time zones, it is become harder to find the right time to do these reports. Ideally doing an inventory report during the lunch rush shouldn\u0026rsquo;t make the system crawl.\nAnother issue is upgrades. Every time we want to upgrade the software we have to take the whole system offline. This is also affected by things like the east coast lunch rush. So again we have to look for specific windows during the day to deploy. Those windows are getting smaller, and the deployments are taking longer. Sometimes when we do an upgrade something goes wrong and the system is unavailable during the times we need it the most. This gets very expensive and very annoying.\nWe have been wanting to implement a loyalty program that requires tracking data about our customers, but our development team tells us this would be a \u0026ldquo;major refactor\u0026rdquo;, and that sounds expensive and risky. I don\u0026rsquo;t really understand the details, but it feels like adding a loyalty program to do the tracking shouldn\u0026rsquo;t be that big of a deal.\nI wanted to implement a new electronic menu for the restaurants. You know, with the tablets on the tables? I thought it would be more environmentally friendly than printing new menus every month. It would also help us follow the trends. Anyway, that apparently was problematic as well. The system that deals with the online menu is really tightly tied up with the fact that it is online and deliveries and all that. I don\u0026rsquo;t really understand the details, but apparently adapting it to work in the restaurant is apparently going to be a lot of work. I would also like to put screens in the kitchen so we could get rid of paper completely.\nCEO\u0026rsquo;s Key Details 500+ Locations Existing Cloud Infrastructure Online Delivery/Pickup Orders, Reservations Experiencing too much downtime Due to upgrades or failures System responds slowly Outages can be very expensive Actions being taken to \u0026ldquo;work around\u0026rdquo; the problems with the system Want to implement a loyalty program but it\u0026rsquo;s risky Want to implement electronic menus but it is also risky "},{"id":9,"href":"/guides/authors/design/patterns/command-event/same-event/","title":"1 - Same Event","parent":"Command/Event Patterns","content":"Question:\nShould separate commands on the same entity all yield the same event, containing the exact changed entity?\nExamples: event UserModified { id: MemberId, info: Info, members: MemberId*, contacts: Contacts, } Suggestions In an event driven system it is important to have distinct events for each operation such that there is a structural difference in the responses. This pattern is advised against for diverse sets of operations, and keeping in mind advantages of other patterns mentioned in this section.\n"},{"id":10,"href":"/guides/authors/design/patterns/command-event/same-parameters/","title":"2 - Same Parameters","parent":"Command/Event Patterns","content":"Question:\nShould each command have its own event, containing the exact changed entity?\nExamples: event OrganizationEstablished { id: OrganizationId info: Info, members: MemberId*, contacts: Contacts, } event OrganizationInfoModified { id: OrganizationId info: Info, members: MemberId*, contacts: Contacts, } event OrganizationMembersModified { id: OrganizationId info: Info, members: MemberId*, contacts: Contacts, } event OrganizationContactsModified { id: OrganizationId info: Info, members: MemberId*, contacts: Contacts, } Suggestions This affords much more traceability, but there is a lot of extraneous data coming back in non-creation events. While it makes sense to return the entire entity in UserEstablished as it was just created and has never been received from backend where data could have been added automatically, the other events could have their parameters pared down a bit. This could be considered an antipattern from that perspective.\n"},{"id":11,"href":"/guides/authors/design/patterns/command-event/optional-parameters/","title":"3 - Optional or List Parameters","parent":"Command/Event Patterns","content":"Question:\nShould the event for each command have a version of the entity where all fields are optional, or lists, such that only changed data is sent back to the gateway?\nExamples: type InfoUpdated { name: String?, address: Address?, members: MemberId*, isPrivate: Boolean?, } event OrganizationEstablished { id: OrganizationId info: Info, contacts: Contacts, } event OrganizationInfoModified { id: OrganizationId info: InfoUpdated, } event UserContactsModified { id: OrganizationId contacts: Contacts, } Suggestions This both removes clutter and makes it easier to see exactly what is going on in each event. We are excluding the Contacts object from the OrganizationInfoModified event since it there is no way it will change during this operation. We are also using InfoUpdated in place of the original objects so that we can reduce our load - if we are modifying Info.name or Info.isPrivate, we don\u0026rsquo;t need to bring the more complex \u0026amp; hefty Address object along with it because the field is now optional.\nThese principles apply especially to objects like Info that describe the basic details of an entity - they usually have many more fields than shown in this example, a mixture of collections, RIDDL Compound Types, and RIDDL Predefined Types.\nAnybody looking at this event would have to know that the data coming back is not the exact copy of the data but only the fields which have been updated. This is especially pertinent in the case of collections because there are no optional versions of objects (like InfoUpdated) to indicate that there is something different going on here.\nEither way, it is advised to annotate optional versions of objects and event parameters which are collections using the briefly or description syntax\nNote that OrganizationMembersModified is not covered here. This is because it does not have a wrapper RIDDL Compound Types, as assumed by the question.\nAnother note to make is that if a subfield of an object is expected to change frequently this may not be the best option, especially if the field is a collection that could be very long, as described above, or otherwise potentially heavy object. Depending on how frequently a subfield, however nested, is expected to change, or depending on its potential load, or both, it should be given its own Command/Event pair. This ensures it is not interrupting or interrupted by the flow of other changes being handled less frequently. The Event in this case should be surfaced instead.\nKeep in mind that using optional versions of objects like InfoUpdated does lead to a bit more overhead, both in terms of development and in terms of message size. Optional parameters still consume space in protobuffer messages, even if just to indicate emptiness, and modifying a data field on a returned type would require not forgetting to modify the optional version correctly. Protobuffer message space used to indicate emptiness should especially be taken into consideration when comparing this solution to surfaced parameters instead\n"},{"id":12,"href":"/guides/authors/design/patterns/command-event/surfaced-parameters/","title":"4 - Surfaced Parameters","parent":"Command/Event Patterns","content":"Question:\nShould the events for each command have only the fields that might have changed, listed individually, when replying to gateway?\nExamples: event UserMembersModified { id: OrganizationId, members: MemberId* } command AddUserPrimaryContacts { userId: MemberId, contact: MemberId* } command RemoveUserPrimaryContacts { userId: MemberId, contact: MemberId* } event OrganizationPrimaryContactsAdded { id: OrganizationId primaryContacts: MemberId+ } event OrganizationBillingContactsRemoved { id: OrganizationId primaryContacts: MemberId* } Suggestions This solution removes clutter, and offers more direct access to data than does optional parameters. This more direct access may be useful if parameters are changing frequently or involve a heavy load. However, if a collection is used here, whether the data returned is the list of modified data elements or the new collection of all data element is entirely up to the developer. This decision may change for each endpoint depending on how heavy the Event load can potentially be. However, one should try to maintain consistency as much as possible.\nAside from the UserMembersModified event, the example commands and their correlated events may or may not make sense to use. It depends on how often these commands will be used. In this case it is probably not the most fitting solution, but if we were dealing with financial data that was constantly being modified - say a list of stocks being used by a high-frequency trading chip - it would make sense to have individualized commands for these actions. If this is the case, note that it is unclear whether the return events are intended to return the modified elements or the new list in its entirety. It may make sense to return just the added elements in Added, and the new list in Removed. No matter what, it is advised to leave annotations regarding these decisions using the briefly or description syntax.\nNote that this applies whether we are dealing with collections of RIDDL Predefined Types or RIDDL Compound Types.\n"},{"id":13,"href":"/guides/authors/design/patterns/command-event/","title":"Command/Event Patterns","parent":"Patterns","content":" Introduction To Messages If you are not familiar with the concept of Messages as it pertains to RIDDL, see here. This document pertains only to Commands and Events.\nBackend v Gateway This design spec considers only designing services themselves. As such it ignores usability features like fine-grained command parameters for updating data, unless justified. In a gateway service more consideration would have to be made for usability.\nProblem Statement There are implementation designs to be made regarding the arrangement of input (Command) and output (Event) data across Handlers. This documents pertains to all types of Command Handlers.\nPreliminary Definitions In this section we will be trying to figure out how to structure commands for creating, modifying, and deleting fields on User entities.\nHere are the riddl specs we will be assuming for each example (borrowed from the evolving improving.app:\nentity Organization is { state Active is { info: Info, members: MemberId*, contacts: Contacts, } } type Contacts is { primaryContacts: MemberId+, billingContacts: MemberId*, distributionContacts: MemberId* } type Info is { name: String, address: Address?, isPrivate: Boolean, } type OrganizationId is Id (Organization) type MemberId is Id (Member) briefly \u0026#34;Member is not relevant here, so it will not be shown here.\u0026#34; type Address is { line1: String, line2: String, city: String, stateProvince: String, country: String, postalCode: PostalCode } type MobileNumber is Pattern(\u0026#34;\\(([0-9]{3})\\)([0-9]{3})-([0-9]{4})\u0026#34;) described as \u0026#34;North American Phone Number standard\u0026#34; type EmailAddress is String type CAPostalCode is Pattern(\u0026#34;[A-Z]\\d[A-Z]\\d[A-Z]\\d\u0026#34;) type USPostalCode is Pattern(\u0026#34;\\d{5}(-\\d{4})?\u0026#34;) type PostalCode is one of { CAPostalCode, USPostalCode } ### We will be trying to find Events for the following Commands: command EstablishOrganization { info: Info, contacts: Contacts } command ModifyUserInfo { id: OrganizationId, info: Info } command AddMembersToUser { userId: OrganizationId, members: MemberId* } command ModifyUserContacts { userId: MemberId, contacts: Contacts } Solutions To Consider 1 - Same Event 2 - Same Parameters 3 - Optional or List Parameters 4 - Surfaced Parameters "},{"id":14,"href":"/guides/authors/design-tips/","title":"Design Tips","parent":"Author's Guide","content":" Domain Hierarchy When considering how to organize your specification into a set , there are no formal rules. Domains are fuzzy concepts on purpose. However, here are a few things that might help:\nDomain, Subdomain, Bounded Context, Problem/Solution Space in DDD: Clearly Defined Domain Drive Design: Domain Definition Use the communication structure of the organization per Conway\u0026rsquo;s Law Use the Event Storming process, and then look for the event groupings. Isolated groups are typically subdomains. Defining Bounded Contexts TBD\n"},{"id":15,"href":"/guides/authors/design/patterns/","title":"Patterns","parent":"Design","content":"This section helps authors with the task of using RIDDL to design a system via recommended patterns for various systems.\nCommand/Event Patterns 1 - Same Event 2 - Same Parameters 3 - Optional or List Parameters 4 - Surfaced Parameters "},{"id":16,"href":"/introduction/what-is-riddl/","title":"What Is RIDDL?","parent":"Introduction","content":"RIDDL gets its name from an acronym that stands for Reactive Interface with Domain Definition Language.\nRIDDL is a specification language for the niche of large, distributed, reactive, concurrent systems such as required for modern internet-scale applications or corporate back office infrastructure.\nRIDDL is a variety of software libraries and tools, provided in this GitHub repository, that allow humans to work with the language to create their own derivative works.\n[riddlc] is a complete extensible compiler infrastructure for processing RIDDL specifications. It uses a plugin system to allow new commands to be added to it for generating information from a RIDDL specification. For more details, please see the tooling section\n"},{"id":17,"href":"/tooling/riddlc/command-line-help/","title":"riddlc --help","parent":"riddlc","content":"riddlc is the command that makes all the magic happen. As you will see, riddlc is a rich and powerful tool for processing RIDDL input.\nCommand Syntax overview riddlc uses a sub-command structure. At a high level, the command line syntax is very simple:\n\u0026gt; riddlc [common options] command-name [command-options] Info Command Output For this version of riddlc:\n\u0026gt; content % riddlc info [info] About riddlc: [info] name: riddlc [info] version: 0.14.0 [info] documentation: https://riddl.tech [info] copyright: © 2019-2022 Ossum Inc. [info] built at: 2022-09-09 11:28:07.485-0400 [info] licenses: Apache License, Version 2.0 [info] organization: Reactific Software LLC [info] scala version: 2.13.8 [info] sbt version: 1.7.1 the help text shows the commands and options available:\nRIDDL Compiler © 2019-2022 Ossum Inc. All rights reserved.\u0026#34; Version: 0.13.3-2-49ff0a59-20220909-1104-SNAPSHOT This program parses, validates and translates RIDDL sources to other kinds of documents. RIDDL is a language for system specification based on Domain Drive Design, Reactive Architecture, and distributed system principles. Usage: riddlc [options] -t | --show-times Show compilation phase execution times -d | --dry-run go through the motions but don\u0026#39;t write any changes -v | --verbose Provide verbose output detailing riddlc\u0026#39;s actions -D | --debug Enable debug output. Only useful for riddlc developers -q | --quiet Do not print out any output, just do the requested command -w | --suppress-warnings Suppress all warning messages so only errors are shown -m | --suppress-missing-warnings Show warnings about things that are missing -s | --suppress-style-warnings Show warnings about questionable input style. -P \u0026lt;value\u0026gt; | --plugins-dir \u0026lt;value\u0026gt; Load riddlc command extension plugins from this directory. Usage: [about|dump|from|help|hugo|info|parse|repeat|validate|version] \u0026lt;args\u0026gt;... Command: about Print out information about RIDDL Command: dump input-file input-file Command: from config-file target-command Loads a configuration file and executes the command in it config-file A HOCON configuration file with riddlc options in it. target-command The name of the command to select from the configuration file Command: help Print out how to use this program Command: hugo [options] input-file Parse and validate the input-file and then translate it into the input needed for hugo to translate it to a functioning web site. input-file required riddl input file to read -o \u0026lt;value\u0026gt; | --output-dir \u0026lt;value\u0026gt; required output directory for the generated output -p \u0026lt;value\u0026gt; | --project-name \u0026lt;value\u0026gt; optional project name to associate with the generated output -e \u0026lt;value\u0026gt; | --erase-output \u0026lt;value\u0026gt; Erase entire output directory before putting out files -b \u0026lt;value\u0026gt; | --base-url \u0026lt;value\u0026gt; Optional base URL for root of generated http URLs -t \u0026lt;value\u0026gt; | --themes \u0026lt;value\u0026gt; Add theme name/url pairs to use alternative Hugo themes -s \u0026lt;value\u0026gt; | --source-url \u0026lt;value\u0026gt; URL to the input file\u0026#39;s Git Repository -h \u0026lt;value\u0026gt; | --edit-path \u0026lt;value\u0026gt; Path to add to source-url to allow editing -m \u0026lt;value\u0026gt; | --site-logo-path \u0026lt;value\u0026gt; Path, in \u0026#39;static\u0026#39; directory to placement and use of the site logo. -n \u0026lt;value\u0026gt; | --site-logo-url \u0026lt;value\u0026gt; URL from which to copy the site logo. Command: info Print out build information about this program Command: parse input-file input-file Command: repeat [options] config-file target-command [refresh-rate] [max-cycles] This command supports the edit-build-check cycle. It doesn\u0026#39;t end until \u0026lt;max-cycles\u0026gt; has completed or EOF is reached on standard input. During that time, the selected subcommands are repeated. config-file The path to the configuration file that should be repeated target-command The name of the command to select from the configuration file refresh-rate Specifies the rate at which the \u0026lt;git-clone-dir\u0026gt; is checked for updates so the process to regenerate the hugo site is started max-cycles Limit the number of check cycles that will be repeated. -n | --interactive This option causes the repeat command to read from the standard input and when it reaches EOF (Ctrl-D is entered) then it cancels the loop to exit. Command: validate input-file input-file Command: version Print the version of riddlc and exits "},{"id":18,"href":"/guides/","title":"Guides","parent":"Index","content":"Before reading any of the guides in this section, please consider reading the conceptual overview of RIDDL as a prerequisite.\nThere are four kinds of readers of this documentation based on the intent of the reader. Accordingly, the documentation has a guide for each kind of reader:\nExpert's Guide For knowledge domain experts who would provide concepts, structure, and event flows to RIDDL authors. Author's Guide For those who will write RIDDL specifications and must know the language intricacies for full and accurate specifications. Implementor's Guide For those who will implement software systems based on RIDDL specifications and the output of RIDDL based tools. Developer's Guide For those who will work on the RIDDL software itself or help others with their use of it. The following sections define these roles more clearly: Domain Experts Authors Implementors Developers Domain Experts Domain experts (DEs) are subject matter experts (SMEs) in some knowledge or problem domain. They are the authority on the language used to describe both problems and solutions within their domain or field of expertise. These individuals are recognized authorities, and they influence an organization\u0026rsquo;s product, service or strategic direction.\nAuthors Authors are the individuals who create system specifications. Such work is greatly aided by using a clear, concise, precise, and intuitive language in which to specify a system. That language is RIDDL. Authors form the bridge between Domain Experts and Implementors.\nImplementors Implementors are the technical experts who implement the system defined in a RIDDL specification. These people are most often Software, QA, and DevOps Engineers. Of course, throughout implementation they will be supported by the Author(s), Domain Experts, and other related staff. Implementors use the output from the RIDDL tools to aid in their comprehension and coding of a solution that corresponds to the RIDDL system specification or model.\nDevelopers Developers are the technical experts that advance RIDDL\u0026rsquo;s state of the art. They develop the tooling and documentation that makes up RIDDL. Since RIDDL is an open source project, developers can be affiliated with many organizations, presumably the organizations that derive utility from RIDDL.\n"},{"id":19,"href":"/future-work/bast/","title":"Binary AST","parent":"Future Work","content":"When the riddlc compiler parses a RIDDL document, it translates it to an Abstract Syntax Tree (AST) in memory. The AST is then used by other passes to validate and translate the AST into other forms. The binary AST (BAST) translator converts the AST in memory into a binary format that is stored for later usage. Saving the BAST format and then reading it back into the compiler avoids the time to both parse the RIDDL document and validate it for consistency.\nConsequently, the riddlc offers a translator from validated AST to BAST format and the ability to read BAST files instead of RIDDL files. The content of a BAST file must contain a valid domain definition from which portions can be imported with the import keyword like this:\nimport domain Kitchen from \u0026#34;rbbq.bast\u0026#34; "},{"id":20,"href":"/language/root/domain/context/","title":"Context","parent":"Domain","content":"A context definition in RIDDL represents the notion of a bounded context per DDD. Contexts are introduced with the contextkeyword and have a name, like this:\ncontext BBQ is { ??? } In the above, the context is named BBQ and its definition is 3 question marks. ??? means \u0026ldquo;unknown\u0026rdquo; or \u0026ldquo;to be determined\u0026rdquo;\nContained Definitions Common Types Options A context may define options. Options help the translation tools know what to do with\nType Types are used in bounded contexts to define messages, function input and output, the state of entities, etc. For more on type definitions see types\nSpecific Context definitions are containers and they may contain definitions that are specific to being defined in a context:\nEntities Options State Invariants Entity Handler Function Adaptors Projections Saga Features Context Handler "},{"id":21,"href":"/language/root/domain/context/entity/","title":"Entities","parent":"Context","content":" Example Here is an outline of the definition of an entity\nentity Example is { options(...)) // Optional aspects of the entity and code gen hints invariant i is { ... } // Logical assertions that must always be true state s is { ... } // Information retained by the entity function f is { ... } // Functions to eliminate redundancy in handlers handler h is { ... } // How the entity handles messages sent to it } Details The links below provide more details on the various sub-definitions of an entity:\nOptions State Invariants Entity Handler Function "},{"id":22,"href":"/language/root/domain/context/entity/options/","title":"Options","parent":"Entities","content":"The optional entity kind prefix is a directive that suggests how the entity might handle its state and received messages. In the example above, we expect the \u0026ldquo;Printer\u0026rdquo; entity to be a physical device. An \u0026ldquo;actor\u0026rdquo; entity in of the same name could be expected to be a person who prints.\nThe options available suggest how the entity might handle its state and message input:\nkind - indicates the intended kind of entity in an argument to the kind entity. event sourced - indicates that event sourcing is used in the persistence of the entity\u0026rsquo;s states, storing a log of change events value - indicates that only the current value of the entity\u0026rsquo;s state is persisted, recording no history off the change events aggregate - indicates this entity is an \u0026lsquo;aggregate root entity\u0026rsquo; as defined by DDD. persistent - indicates that this entity should persist its state to stable storage. consistent - indicates that this entity tends towards Consistency as defined by the CAP theorem and therefore uses sharding and the single writer principle to ensure a consistent view on state changes available - indicates that this entity tends towards Availability as defined by the CAP theorem and therefore replicates its entity state to multiple locations or even across data centers using CRDTs (conflict-free replicated data types). grpc - indicates that the entity should be accessible via gRPC api invocations mq - indicates that commands and queries may be sent by a message queue such as Kafka, Pulsar, or Google Pub Sub Entities use event sourcing to keep track of the entire history of changes to the entity\u0026rsquo;s state.\n"},{"id":23,"href":"/reactive-summit/","title":"Reactive Summit","parent":"Index","content":"Welcome, Reactive Summit 2022 attendees!\nImportant Links Shown At Reactive Summit 2022 Documentation (here): https://riddl.tech Source Code: https://github.com/reactific/riddl Discussions: https://github.com/reactific/riddl/discussions Example: https://github.com/improving-app/riddl Contact: reid.spencer@improving.com Other Information Full Slide Deck\nReid\u0026rsquo;s LinkedIn Profile\nPlease send a link request and a note mentioning Reactive Summit "},{"id":24,"href":"/language/root/domain/context/entity/state/","title":"State","parent":"Entities","content":"The state definitions of an entity define the structure of the information that the entity retains as its current state.\nSyntax Example The state of an entity is defined with the state keyword within the content of an entitydefinition, like this:\nentity Car { type Propulsion = any of { ICE, Electric, Steam, Diesel, EMDrive } state Static is { wheels: Integer doors: Integer rightHandDrive: Boolean propulsion: Propulsion } } One of the primary purposes of an entity is to represent the characteristics of the entity with state information. We call it state because it represents the current state of the entity at any given point in time.\nThe above example definition associates a state, named Static with the entity named Car having these fields in its aggregate data type:\nwheels - an Integer value providing the number of wheels on the car. doors - an Integer value providing the number of doors on the car. rightHandDrive - a Boolean value indicating if it is right hand drive. propulsino - a Propulsion enum value presumably representing the kind of propulsion the vehicle uses. Multiple State Definitions It is entirely possible to specify multiple named state definitions for a single entity. This is provided in the language to support finite state machines which are frequently used with entities. The state of an entity can be modelled as simply transitions of states as each handler processes a command. Multiple state values are useful when the state of the entity has different modes of operation where different sets of state values are needed.\n"},{"id":25,"href":"/guides/developers/grammar/terminals/","title":"Terminals","parent":"Grammar","content":"This file shows the definition of the terminal symbols, as productions, and grouped in categories:\n(* Terminal symbol definitions in various categories *) Terminals = Punctuation | Options | Keywords | Predefined | Readability | Operators; Punctuation = asterisk | comma | colon | curlyOpen | curlyClose | dot | equals | ellipsis | ellipsisQuestion | plus | question | quote | roundOpen | roundClose | squareOpen | squareClose | undefined | verticalBar ; asterisk = \u0026#34;*\u0026#34;; comma = \u0026#34;,\u0026#34;; colon = \u0026#34;:\u0026#34;; curlyOpen = \u0026#34;{\u0026#34;; curlyClose = \u0026#34;}\u0026#34;; dot = \u0026#34;.\u0026#34;; equals = \u0026#34;=\u0026#34;; ellipsis = \u0026#34;...\u0026#34;; ellipsisQuestion = \u0026#34;...?\u0026#34;; plus = \u0026#34;+\u0026#34;; question = \u0026#34;?\u0026#34;; quote = \u0026#34;\\\u0026#34;\u0026#34;; roundOpen = \u0026#34;(\u0026#34;; roundClose = \u0026#34;)\u0026#34;; squareOpen = \u0026#34;[\u0026#34;; squareClose = \u0026#34;]\u0026#34;; undefined = \u0026#34;???\u0026#34;; verticalBar = \u0026#34;|\u0026#34;; Options = actor |aggregate | async | available | consistent | device eventSourced | function | gateway | persistent | reply | concept | sync value | wrapper ; actor = \u0026#34;actor\u0026#34;; aggregate = \u0026#34;aggregate\u0026#34;; async = \u0026#34;async\u0026#34;; available = \u0026#34;available\u0026#34;; consistent = \u0026#34;consistent\u0026#34;; device = \u0026#34;device\u0026#34;; eventSourced = \u0026#34;event sourced\u0026#34;; function = \u0026#34;function\u0026#34;; gateway = \u0026#34;gateway\u0026#34;; persistent = \u0026#34;persistent\u0026#34;; reply = \u0026#34;reply\u0026#34;; concept = \u0026#34;concept\u0026#34;; sync = \u0026#34;sync\u0026#34;; value = \u0026#34;value\u0026#34;; wrapper = \u0026#34;wrapper\u0026#34;; Keywords = action | adaptor | all | any | append | background | brief | call | causing | command | commands | consumer | context | described | details | domain | each | else_ | entity | event | events | example | execute | explained | feature | function | handles | include | input | interaction | invariant | items | many | mapping | on | one | option | optional | options | output | publish | query | queries | range | remove | requires | result | results | role | see | send | set | state | then_ | topic | type | value | when | yields action = \u0026#34;action\u0026#34;; adaptor = \u0026#34;adaptor\u0026#34;; all = \u0026#34;all\u0026#34;; any = \u0026#34;any\u0026#34;; append = \u0026#34;append\u0026#34;; background = \u0026#34;background\u0026#34;; brief = \u0026#34;brief\u0026#34;; call = \u0026#34;call\u0026#34;; causing = \u0026#34;causing\u0026#34;; command = \u0026#34;command\u0026#34;; commands = \u0026#34;commands\u0026#34;; consumer = \u0026#34;consumer\u0026#34;; context = \u0026#34;context\u0026#34;; described = \u0026#34;described\u0026#34;; details = \u0026#34;details\u0026#34;; domain = \u0026#34;domain\u0026#34;; each = \u0026#34;each\u0026#34;; else_ = \u0026#34;else\u0026#34;; entity = \u0026#34;entity\u0026#34;; event = \u0026#34;event\u0026#34;; events = \u0026#34;events\u0026#34;; example = \u0026#34;example\u0026#34;; execute = \u0026#34;execute\u0026#34;; explained = \u0026#34;explained\u0026#34;; feature = \u0026#34;feature\u0026#34;; function = \u0026#34;function\u0026#34;; handles = \u0026#34;handles\u0026#34;; include = \u0026#34;include\u0026#34;; input = \u0026#34;input\u0026#34;; interaction = \u0026#34;interaction\u0026#34;; invariant = \u0026#34;invariant\u0026#34;; items = \u0026#34;items\u0026#34;; many = \u0026#34;many\u0026#34;; mapping = \u0026#34;mapping\u0026#34;; on = \u0026#34;on\u0026#34;; one = \u0026#34;one\u0026#34;; option = \u0026#34;option\u0026#34;; optional = \u0026#34;optional\u0026#34;; options = \u0026#34;options\u0026#34;; output = \u0026#34;output\u0026#34;; publish = \u0026#34;publish\u0026#34;; query = \u0026#34;query\u0026#34;; queries = \u0026#34;queries\u0026#34;; range = \u0026#34;range\u0026#34;; remove = \u0026#34;remove\u0026#34;; requires = \u0026#34;requires\u0026#34;; result = \u0026#34;result\u0026#34;; results = \u0026#34;results\u0026#34;; role = \u0026#34;role\u0026#34;; see = \u0026#34;see\u0026#34;; send = \u0026#34;send\u0026#34;; set = \u0026#34;set\u0026#34;; state = \u0026#34;state\u0026#34;; then_ = \u0026#34;then\u0026#34;; topic = \u0026#34;topic\u0026#34;; type = \u0026#34;type\u0026#34;; value = \u0026#34;value\u0026#34;; when = \u0026#34;when\u0026#34;; yields = \u0026#34;yields\u0026#34;; Predefined = Boolean | Date | DateTime | Decimal | Duration | Id | Integer | LatLong | Nothing | Number | Pattern | Real | String | Time | TimeStamp | UniqueId | URL ; Boolean = \u0026#34;Boolean\u0026#34;; Date = \u0026#34;Date\u0026#34;; DateTime = \u0026#34;DateTime\u0026#34;; Decimal = \u0026#34;Decimal\u0026#34;; Duration = \u0026#34;Duration\u0026#34;; Id = \u0026#34;Id\u0026#34;; Integer = \u0026#34;Integer\u0026#34;; LatLong = \u0026#34;LatLong\u0026#34;; Nothing = \u0026#34;Nothing\u0026#34;; Number = \u0026#34;Number\u0026#34;; Pattern = \u0026#34;Pattern\u0026#34;; Real = \u0026#34;Real\u0026#34;; String = \u0026#34;String\u0026#34;; Time = \u0026#34;Time\u0026#34;; TimeStamp = \u0026#34;TimeStamp\u0026#34;; UniqueId = \u0026#34;UniqueId\u0026#34;; URL = \u0026#34;URL\u0026#34;; Readability = and | are | as | by | for | from | is | of | on | to ; and = \u0026#34;and\u0026#34;; are = \u0026#34;are\u0026#34;; as = \u0026#34;as\u0026#34;; by = \u0026#34;by\u0026#34;; for = \u0026#34;for\u0026#34;; from = \u0026#34;from\u0026#34;; is = \u0026#34;is\u0026#34;; of = \u0026#34;of\u0026#34;; on = \u0026#34;on\u0026#34;; to = \u0026#34;to\u0026#34;; Operators = and | or | not | plus | minus | times | div | mod ; not = \u0026#34;not\u0026#34;; plus = \u0026#34;+\u0026#34;; minus = \u0026#34;-\u0026#34;; times = \u0026#34;*\u0026#34;; div = \u0026#34;/\u0026#34;; mod = \u0026#34;%\u0026#34;; "},{"id":26,"href":"/language/common/doc-conventions/","title":"Documentation Conventions","parent":"Common","content":"This page defines the conventions we use throughout this documentation.\nRIDDL Snippets Whenever we include RIDDL source code in the documentation it will be in a fixed sized font like this:\ndomain MyDomain is { ??? } Notes Whenever an incidental note needs to be presented, it will be shown in blue like this paragraph. Recommendations Whenever an important recommendation needs to be made it will be shown in green like this paragraph. Warnings Whenever a point that is often a source of confusion needs to be made, it will be shown in yellow like this paragraph. Dangers Whenever a point that will lead to errors or have dangerous consequences needs be made, it will be shown in red like this paragraph. Language Definitions Whenever an important RIDDL language definition is made, it will appear in a box like this. "},{"id":27,"href":"/language/common/lang-conventions/","title":"Language Conventions","parent":"Common","content":" Introduction Syntax conventions of RIDDL are very simple and lenient. The intended audience is business owners, business analysts, domain engineers, and software architects. It is intentionally simple and readable. The language is free in its formatting. It does not require indentation and its various constructs can be arranged on any line. RIDDL supports the definition of a variety of concepts taken directly from Domain Driven Design and the Unified Modeling Language as well as software architecture.\nThe following language conventions are adhered to throughout the language for ease of use (special cases and rule contraventions cause confusion).\nLanguage Consistency Most things in RIDDL are consistent throughout the language. We believe this makes learning the language easier since there are no exceptions to fundamental constructs. The sections below define the consistent language features.\nDeclarative Definitions The language is declarative. You don\u0026rsquo;t say how to do something, you specify the end result you want to see. The language aims to capture a detailed and concise definition of the abstractions that a complex system will require. It does not specify how those abstractions should be built. RIDDL is not a programming language, but its compiler can generate structurally sound code that can be completed by a software engineer.\nEvery Definition Can Be Documented Every thing you can define can have a described by, described in file, or explained by suffix which lets you document the definition using markdown.\nHierarchy Of Definitions Definitions are specified in a strict containment hierarchy. Definitions that can contain other definitions are known as containers. For example, a domain definition is a recursively nested definition, as follows:\ndomain root is { domain branch is { domain leaf { } } } That is, domains are definitions that can contain the definition of (sub) domains. Similarly context can define entity\ncontext foo is { entity bar is { ... } } Definitions And References A definition introduces a named instance of some RIDDL concept at its point. The specification of that definition proceeds directly following the is keyword.\nIf RIDDL supported the concept of a Cat and its owner (it doesn\u0026rsquo;t in both those cases), then you might specify a cat named \u0026ldquo;Smudge\u0026rdquo; with an owner named \u0026ldquo;Reid\u0026rdquo; like this:\ncat Smudge is { owner is entity Reid } Here is an explanation of each of these tokens:\ncat is the kind of concept that the author wants to define Smudge is the name the author wants to assign to this cat concept is is a required keyword for readability { starts the definition of Smudge the cat owner is the name of a property that all \u0026ldquo;cat\u0026rdquo; concepts have is is another keyword required for readability entity Reid is a reference to an instance of a concept, an entity, of type Reid. References to many kinds of RIDDL concepts are made in this way, by name (type) with a prefix for the kind of concept. } completes the definition of Smudge the cat. This is a simple convention used throughout the language for all concept definitions and references to them.\nContainers Containers are definitions that contain other, nested, definitions. Between the { and the } that define the boundaries of a definition, you may place other definitions. Such nested definitions are deemed to be contained. Not every definition is a container as it only applies to concepts like domain, context and entity.\nThe full list of all Container definitions is as follows:\ntopic feature entity adaptor context interaction domain Leaves Definitions that may not contain other definitions are called \u0026ldquo;leaves\u0026rdquo; because, like tree leaves, they occur at the extremity (most nested) part of the definitional hierarchy.\nWork In Progress Modelling a domain can be hard work. New ideas come up that must be flushed out. Sometimes things get left undefined. That\u0026rsquo;s okay! Riddl uses a special construct, ??? to mean \u0026ldquo;we don\u0026rsquo;t know yet\u0026rdquo;. It can be used as the body of any definition. For example it is entirely legal to write:\ncat Smudge is { ??? } If we aren\u0026rsquo;t sure of the characteristics of the cat named \u0026ldquo;Smudge\u0026rdquo;\nDirectives RIDDL supports the notion of directives that are specified as a complete line whose first character is the hash mark. The directive extends to the end of that line. Hash marks at other locations on a line are not recognized as directives. The subsections below define the kinds of directives supported by RIDDL\u0026rsquo;s compiler.\nSubstitutions For example:\n#define x = expialidocious defines a symbol x that has the value expialidocious . Wherever $x is seen in the input it will be replaced with expialidocious before being lexically interpreted by the compiler.\nSubstitutions have not yet been implemented in RIDDL File Inclusion RIDDL allows source input to be included, inline, from other files. That is, the parser will substitute the text of an included file, replacing the include directive. This is much like the C preprocessor #include directive. RIDDL always parses the entire specification but the include directive allows you to organize that specification into many (even nested) files. Note that include directives are only permitted within container definitions. Doing so prevents fragments of definitions from being separated into individual files.\nFor example, this is allowed:\ndomain ThingAmaJig { #include \u0026#34;thingamajig/thing-context\u0026#34; #include \u0026#34;thingamajig/ama-topic\u0026#34; #include \u0026#34;thingamajig/jig-context\u0026#34; } while this is not:\ndomain #include \u0026#34;ThingAmaJig-domain\u0026#34; because it is not specified within the contained portion of a container. A domain is a container, but it needs a name and that name cannot be buried in an include file. As a rule of thumb, you can always use #include right after an opening curly brace of a container definition.\nDescriptions (Explanations) A definition may also be accompanied by some text or markup at its end to describe or explain the purpose of that definition. We call these descriptions or explanations because this is the text that is used to describe or explain the RIDDL definition, and it is used to generate documentation for the definition. A description occurs directly after the definition\u0026rsquo;s closing curly bracket and is preceded using either the described as or explained as keyword phrase. Essentially it looks like this:\ncat Smudge is { ??? } explained as \u0026#34;TBD but owned by Reid\u0026#34; The grammar for a description is this:\ndescription = (\u0026#34;described\u0026#34; | \u0026#34;explained\u0026#34;), \u0026#34;as\u0026#34;, \u0026#34;{\u0026#34;, description body, \u0026#34;}\u0026#34; ; description body = literal string description | doc block description ; literal string description = (literal string)+ ; literal string = \u0026#34;\\\u0026#34;\u0026#34; ; doc-block-description = ... tbd What occurs within a description/explanation can be one of three things:\nA single literal string in quotations: \u0026quot;this string\u0026quot;, as shown above. A curly brace enclosed list of \u0026ldquo;docblock\u0026rdquo; lines which consists of a group of lines, each preceded by a vertical bar. The bar denotes the left margin. Markdown syntax is accepted. A curly brace enclosed list of four sections: brief, details, items and see Each of these is explained in more detail in the sections that follow.\nSingle Literal String Pretty simple, like this:\ndomain SomeDomain is { ??? } explained as \u0026#34;Not very helpful\u0026#34; Documentation Block Allowing markdown syntax, like this:\ndomain SomeDomain is { ??? } explained as { |## Overview |This domain is rather vague, it has no content. |## Utility |The utility of this domain is dubious because: |* It has no content |* Its name is not useful |* It is only an example of RIDDL syntax } Separate Sections The documentation in this section is stale and needs to be revised. When more formal documentation is required for major definitions (domains, contexts, entities), then you should use the sectioned style to group your documentation into standard sections, like this:\nbrief is a simple text description of the definition details is a longer textual description enclosed in a block { }, avoiding the need to quote the text. This property may include Markdown directives that will be rendered in any generated documentation. items is a means of including references to other entities or definitions is also enclosed withing a block { }. see is a block where additional resources supporting the description may be listed. All of these nested blocks can use markdown in a doc block or simple literal strings depending on your needs. For example:\ndomain SomeDomain is { ??? } explained as { brief { \u0026#34;this domain is rather vague, it has no content\u0026#34; } description { |The utility of this domain is dubious because: } items(\u0026#34;Aspects Of Utility\u0026#34;) { |* It has no content |* Its name is not useful |* It is only an example of RIDDL syntax } } "},{"id":28,"href":"/language/common/descriptions/","title":"Descriptions","parent":"Common","content":"The RIDDL syntax is simply a hierarchical arrangement of definitions. Each definition can have a description. Descriptions are used to generate documentation and they follow markdown conventions.\nExamples There are several ways to describe a definition. In each of the examples we attach a description to some domain named Foo. The definition is not important for our purposes here. Descriptions come after the definition using one of five phrases:\ndescribed by described as described in file \u0026quot;\u0026lt;filename\u0026gt;\u0026quot; explained by explained in file \u0026quot;\u0026lt;filename\u0026gt;\u0026quot; These four phrases are equivalent but provided to suit the nature of the definitions to which they may be applied. For example:\ndomain Foo is { } explained as \u0026#34;Foo is not a very good domain name\u0026#34; is equivalent to:\ndomain Foo is { } described by \u0026#34;Foo is not a very good domain name\u0026#34; Quoted String Format The examples show above use a single string as the description. This is appropriate when the description is short, as is typical for small definitions.\nQuoted Strings Format Alternatively, a large description may be provided as a set of quoted strings enclosed in curly braces. For example:\ndomain Foo is { } described by { \u0026#34;Foo is not a very good domain name\u0026#34; \u0026#34;And an empty domain doesn\u0026#39;t define anything!\u0026#34; } Note in this case that we have embedded markdown syntax into the description.\nMarkdown Format Alternatively, to make things a little more free-form, and aligned on the left column, a description may be formed using just a vertical bar character to indicate the line start. For example:\ndomain Foo is { } described by { |# Warning |Foo is not a very good domain name |And an empty domain doesn\u0026#39;t define anything! } Note in this case that we have embedded Markdown syntax into the description. The # Warning syntax is an indication to a Markdown processor that a new heading with the text \u0026ldquo;Warning\u0026rdquo; should be started. All descriptions are encouraged to use this Markdown syntax style.\nMarkdown In File With the in file \u0026quot;\u0026lt;filename\u0026gt;.md\u0026quot; syntax, you can place the Markdown description of a definition into a separate file. This is a good choice for long descriptions to minimize reading flow disruption when reading the RIDDL code.\nUsing Markdown Syntax Markdown syntax is encouraged in descriptions because the riddlc compiler can translate RIDDL specifications into the input of the website generator hugo, which expects markdown. In this way, a large RIDDL specification can be translated automatically into a beautiful website.\nThe full range of markdown, html, and shortcode syntax that hugo supports may be used in RIDDL descriptions. See this link for more details on hugo\n"},{"id":29,"href":"/tutorial/rbbq/scenario/headchef/","title":"Corporate Head Chef","parent":"Reactive BBQ Case Study","content":"What is your role in the restaurant?\nCorporate wants each restaurant to have a consistent experience. My job is to create new recipes to be included in the menu. I spend a lot of time trying out different ingredients and flavours to try to get the right balance for our menu. I have to be careful to stick to ingredients that we can buy in sufficient quantities. Most people think that a restaurant like ours prepares everything from scratch. Sometimes we do, but a lot of our stuff is bought premade in bulk and then shipped to the restaurants. Our Reactive BBQ sauce is a perfect example. Very few people know what goes into the sauce. Even the companies we get to prepare it don\u0026rsquo;t have all the details.\nOnce I have a new dish figured out I talk to the marketing team. They work on preparing a nice description of the dish. We also have a food photographer so I work with him to make sure that the dish looks nice and is presentable for his photos.\nWhat challenges do you face?\nWell, as I mentioned there is the issues with sourcing ingredients. It can be a tricky business with all of the regions we have restaurants in. That\u0026rsquo;s part of the reason why so many things have to be shipped from our warehouses. Some of our ingredients are sourced locally, but not all of them.\nWe have these crazy processes around updating the actual menus. We can\u0026rsquo;t just do it whenever we want. Menus are only updated once a month. That makes sense because there are printer costs and distribution issues we have to think about. Basically once a month, after everything is prepared, I send an email out to all the restaurants with new menu items and recipes. But then we have to coordinate with the printers to make sure they get hard copies delivered in time. And then we have to also coordinate with the website to make sure they are up to date. It becomes a bit of a hassle. Basically near the end of every month we have this flurry of activity to get everything prepared.\nHead Chef\u0026rsquo;s Key Details Corporate Chef updates the menu once a month. Corporate Chef works with photographer on menu photographs. Corporate Chef deals with supply chain for the restaurants. Menu updates must be coordinated with printing and website. "},{"id":30,"href":"/guides/authors/","title":"Author's Guide","parent":"Guides","content":"The author needs a clear and intuitive language to program in (RIDDL). This activity is greatly facilitated by tools to aid the job, for example, IDE plugins, graphical authoring utilities, and so on. The author needs to have the ability to configure these tools and utilities to match their mode of work. The RIDDL compiler must emit clear feedback on errors, warnings, and other details that would improve the overall correctness and outputs from RIDDL.\nRIDDL sources are intended to be kept in version control along with the source code. The RIDDL compiler, riddlc, has utilities that will automate the process of generating RIDDL outputs from source control or in local environments. These will be discussed further when we dive into riddlc in depth.\nAuthors are the individuals who create system specifications. Such work is greatly aided by using a clear, concise, precise, and intuitive language in which to specify a system. That language is RIDDL. Authors form the bridge between Domain Experts and Implementors.\nAuthors should have an expert understanding of DDD, and be familiar with reactive architecture, API design, distributed systems concepts, and software architecture in general. While not required, it is also helpful to be familiar with Scala, Akka (including Akka Clustering and Streaming), and cloud architectures. This knowledge is useful for the successful construction of a viable domain model encoded in RIDDL. Consequently, Authors must acquire a full understanding of the syntax, structure and semantics of RIDDL.\nIt will also be very helpful if authors become familiar with:\nMarkdown Git Hugo Geekdoc Theme for Hugo HOCON configuration format Scala programming language The Actor Model Functional Programming This activity is greatly facilitated by tools to aid the job, for example, IDE plugins, graphical authoring utilities, and so on. The author needs to have the ability to configure and run these tools and utilities to match their mode of work. The RIDDL compiler emits clear feedback on errors, warnings, and an author must be able to interpret those messages and use them to adjust the RIDDL sources to improve the overall correctness in the outputs from RIDDL.\n"},{"id":31,"href":"/guides/authors/design/","title":"Design","parent":"Author's Guide","content":"This section helps authors with the task of using RIDDL to design a system.\nPatterns Command/Event Patterns 1 - Same Event 2 - Same Parameters 3 - Optional or List Parameters 4 - Surfaced Parameters "},{"id":32,"href":"/introduction/what-can-riddl-do/","title":"What can RIDDL do?","parent":"Introduction","content":"RIDDL is a software specification language. As a consequence of it being a language, it has a software tool, riddlc (riddl compiler), that can be used to do a variety of things. Most of those things involve reading riddl input files, checking them, and producing some output file(s).\nInput The input to riddlc is always a single file with the .riddl suffix. This is a text file that contains definitions in the RIDDL syntax. While the input is specified as a single file, that could be just the top level file of a hierarchically arranged set of files that are included from the top level file.\nOptions The riddlc program has many options but generally they control:\nwhere more options are coming from (e.g. config files) what kind of logging output should be generated (terse to verbose) what kind of output should be generated Output The riddlc program can produce many kinds of outputs. Being extensible, this list can grow. Currently implemented functionality includes:\nSyntax Validation - making sure that the input is syntactically correct Semantic Validation - making sure that the structure and referential integrity of the input is correct. Specification Site - construction of hugo input that can be translated into a web site to make the specification navigable and readable Diagrams - generating a variety of diagrams as either PNG or mermaid input Kalix - generating the necessary Google Protobuffers input for Kalix to use to generate the infrastructure for a software system. In the future we expect to produce translators that will also provide:\nAkka - generating Akka infrastructure code with a \u0026ldquo;fill in the blanks\u0026rdquo; approach for system design evolution.\nKuberenetes - generating Kubernetes deployment descriptors, etc.\nRIDDL sources produce two kinds of output:\nSpecification: Specification outputs are the \u0026ldquo;requirements\u0026rdquo; of the domain model. Domain experts spend most of their time here - adding detail, reviewing for completeness/correctness, and establishing the domain model - which includes defining a ubiquitous language. Most of this work is done by reviewing the web site generated from RIDDL sources. Beyond textual definitions and descriptions of Domains, Contexts, Entities, Plants, Functions, etc. specification outputs may also include wireframe mockups, diagrams of various types that add clarity to the definition and interactions within the domain, for example, Context Maps, Flow Charts, Sequence Diagrams, State Machines, Entity Relationships.\nWhen the delivery team begins building, the system specification outputs become their guide posts as they build. Undoubtedly, the implementation team will need to engage with domain experts to get additional information and clarity as they develop. Specification outputs provide the baseline from which these conversations happen. The insights gained should be captured in the RIDDL file and new specification outputs generated to reflect these learnings.\nImplementation: Implementation outputs are intended to accelerate the efforts of the delivery team. As such, these outputs tend to be more technical in nature. Examples of these outputs would include:\nScala/Akka code stubs including actor definitions, value objects, message definitions (case classes), and so on. Test cases derived from user stories in the RIDDL spec. Protobuf (Protocol Buffer) definitions. Open API Specifications (AKA Swagger) Initial build.sbt Initial GIT project and structure Boilerplate CI/CD Definitions for implementation artifacts Boilerplate infrastructure code to deploy both specification outputs and generated system sources "},{"id":33,"href":"/tooling/editor-plugins/intellij-plugin/","title":"IntelliJ Plugin","parent":"Getting Ready To Go","content":"This project has not started yet but has a high priority attached to it.\nLike other languages, RIDDL will have an IntelliJ Plugin to do syntax highlighting and error checking to help the author write the language effectively.\n"},{"id":34,"href":"/language/root/domain/context/adaptor/","title":"Adaptors","parent":"Context","content":"Adaptors are translators between contexts and (sub-)domains. DDD calls these \u0026ldquo;anti-corruption layers\u0026rdquo;; but we find that term to be awkward and its abbreviation to be conflated with Access Control List and with a ligament of the knee (Anterior Cruciate Ligament). Consequently, we prefer to use the term adaptor for this concept. However, the name DDD chose is apt. Adaptors (and ACLs) aim to solve a language problem that often exists in large domain modelling exercises: conflation and overloading of terms.\nFor example, consider the word \u0026ldquo;order\u0026rdquo; in various contexts:\nmilitary - a directive or command from a superior to a subordinate restaurant - a list of items to be purchased and delivered to a table mathematics - A sequence or arrangement of successive things. sociology - A group of people united in a formal way architecture - A type of column and entablature forming the unit of a style And there are several more.\nTo disambiguate the definition of common terms we use bounded contexts in DDD, and RIDDL, that precisely define the meaning of a term in that context. But, what happens when two bounded contexts use the same term for different purposes? That\u0026rsquo;s where Adaptors come in.\nUse Cases There are several use cases in which the need for an Adaptor occurs as in the following subsections\nNon-DDD External Systems An adaptor can adapt a non-DDD external system to a DDD system. The DDD system can then interact with the non-DDD system using messages as if it was a DDD system by simply interacting with the corresponding Adaptor. See\nthis stackoverflow article for more on this.\nReactions Some entities need to react to the occurrence of events from other bounded contexts. These adaptations are often handled directly by an entity handler but sometimes the model needs to specify reactions at the bounded context level where they can be converted into commands on the appropriate entities.\nVersioning Bounded contexts and their entities undergo version changes and those changes can affect the structure and composition of the messages used. To support smooth transitions between versions, the software needs to support older versions of messages seamlessly. This is handled in RIDDL by adapting the old messages to the new messages, even if that means ignoring them.\nDefining Adaptors An adaptor can only be defined as part of the definition of a bounded context. It can specify how to handle the messages received from another bounded context, or even from a pipe. For example, we adapt context Bar below to the event from context Foo\ncontext Foo is { type FooEventName is event { ??? } } context Bar is { type BarCommandName is command { ??? } adaptor FromFooContext for Foo is { adapt FooEventName to BarCommandName as { given \u0026#34;entity\u0026#34; } } } "},{"id":35,"href":"/guides/developers/grammar/common/","title":"Common","parent":"Grammar","content":"A number of frequently used productions are useful to understand in the sections that follow. Commentary follows the grammar.\n(* Common RIDDL EBNF Grammar Productions *) (******************************************************************** COMMON *) any char = ? any UTF-8 character ? ; any but newline = any char - ( \u0026#34;\\n\u0026#34; | \u0026#34;\\r\u0026#34; ) ; nonquote = any char - \u0026#39;\u0026#34;\u0026#39; ; digits = \u0026#34;0\u0026#34; | \u0026#34;1\u0026#34; | \u0026#34;2\u0026#34; | \u0026#34;3\u0026#34; | \u0026#34;4\u0026#34; | \u0026#34;5\u0026#34; | \u0026#34;6\u0026#34; | \u0026#34;7\u0026#34; | \u0026#34;8\u0026#34; | \u0026#34;9\u0026#34; ; literalInteger = digits literalString = quote nonquote quote ; literalStrings = literalString { literalString } ; markdownLine = verticalBar, any but newline, newline ; markdownLines= markdownLine { markdownLine.rep(1)) } ; docBlock = (open, (markdownLines | literalStrings), close) | literalString ; optionalNestedContent(content) = open [ content ] close ; brief = \u0026#34;brief\u0026#34;, [ ( literalString | docBlock ) ] ; details = \u0026#34;details\u0026#34;, [ (literalString | docBlock) ] ; items = \u0026#34;items\u0026#34;, [ \u0026#34;(\u0026#34;, literalString \u0026#34;)\u0026#34; ], open, { identifier, \u0026#34;is\u0026#34;, docBlock), close ; citations = \u0026#34;see\u0026#34;, docBlock ; as = \u0026#34;as\u0026#34; | \u0026#34;by\u0026#34;; detailedDescription = brief, details, items, citations ; literalStringsDescription = literalStrings ; docBlockDescription = markdownLine ; description = ( \u0026#34;described\u0026#34; | \u0026#34;explained\u0026#34; ), as, open, (literalStringDescription | docBlockDescription | detailedDescription), close ; literalDecimal = plusOrMinus, digits{digits}, \u0026#34;.\u0026#34; {digits} ; idHeadChars = ? upper and lower case letters ? ; idTailChars = ? letters digits and underscore ? ; simpleIdentifier = idHeadChars, { idTailChars } ; quotedIdentifier = \u0026#34;\u0026#39;\u0026#34;, any char { any char }, \u0026#34;\u0026#39;\u0026#34; ; identifier = simpleIdentifier | quotedIdentifier ; pathIdentifier = identifier { \u0026#34;.\u0026#34;, identifier } ; is = \u0026#34;is\u0026#34; | \u0026#34;are\u0026#34; | \u0026#34;:\u0026#34; | \u0026#34;=\u0026#34; ) ; open = \u0026#34;{\u0026#34; ; close = \u0026#34;}\u0026#34; ; options(validOptions) = \u0026#34;options\u0026#34;, \u0026#34;(\u0026#34; validOptions{validOptinos} \u0026#34;)\u0026#34; | \u0026#34;option\u0026#34;, \u0026#34;is\u0026#34;, validOptions ; commandRef = \u0026#34;command\u0026#34;, pathIdentifier ; eventRef = \u0026#34;event\u0026#34;, pathIdentifier ; queryRef = \u0026#34;query\u0026#34;, pathIdentifier ; resultRef = \u0026#34;result\u0026#34;, pathIdentifier ; messageRef = commandRef | eventRef | queryRef | resultRef ; entityRef = \u0026#34;entity\u0026#34;, pathIdentifier ; topicRef = \u0026#34;topic\u0026#34;, pathIdentifier ; typeRef = \u0026#34;type\u0026#34;, pathIdentifier; actionRef = \u0026#34;action\u0026#34;, pathIdentifier ; contextRef = \u0026#34;context\u0026#34;, pathIdentifier ; domainRef = \u0026#34;domain\u0026#34;, pathIdentifier; "},{"id":36,"href":"/language/common/","title":"Common","parent":"Language","content":"Some definitions and concepts are fundamental to RIDDL and can appear in many RIDDL definitions. Before exploring the hierarchy of definitions, we will define some things that are common to many definitions:\nDocumentation Conventions Language Conventions Descriptions Identifiers Examples Types Expressions Includes Functions Imports Options "},{"id":37,"href":"/future-work/diagrams/","title":"Diagrams","parent":"Future Work","content":""},{"id":38,"href":"/tooling/riddlc/download-and-use-a-release/","title":"Download and install a release","parent":"riddlc","content":"Starting with the 0.6.0 a \u0026ldquo;universal\u0026rdquo; release bundle is made available for Linux and MacOS Systems directly from GitHub. You can find them in the GitHub Releases section under \u0026ldquo;Assets\u0026rdquo;. Note that not all releases have these assets.\nAfter downloading the .zip asset, you should:\nMove that .zip file to somewhere in your home directory Unpack that .zip file with unzip \u0026lt;path-to-tgz\u0026gt; That will give you a directory like riddl-0.6.0/bin (the version # might be different) Put that bin directory in your path Now you can just run “riddlc” from anywhere Some day we will have a packaged installer. "},{"id":39,"href":"/tooling/riddlc/build/","title":"How To Build `riddlc`","parent":"riddlc","content":" 1. Obtain source code \u0026gt; git clone https://github.com/reactific/riddl.git \u0026gt; cd riddl 2. Install JDK Please follow the directions provided by Adoptium to install OpenJDK on your machine. For MacOS users, this boils down to:\nbrew install --cask temurin 3. Install sbt Please follow the directions to install sbt which orchestrates the build for RIDDL. For MacOS users, this boils down to:\n\u0026gt; brew install sbt 4. Build Within the cloned repository\u0026rsquo;s directory (step 1 above), run this command:\n\u0026gt; sbt \u0026#34;clean ; compile\u0026#34; "},{"id":40,"href":"/language/common/identifiers/","title":"Identifiers","parent":"Common","content":"Identifiers are the names of definitions. In the following domain definition,\ndomain foo is { ??? } the identifier is foo. Identifiers can be specified in two ways:\nsimple: any alphabetic character followed by alphanumerics or underscore quoted: \u0026quot; followed by a string of characters chosen from this set: a-zA-Z0-9_+\\-|/@$%\u0026amp;, :\u0026quot; followed by a \u0026quot; Path Identifiers In several places in RIDDL, you may need to reference a definition in another definition. Such references are called Path Identifiers. Path identifiers encode a simple algorithm to find the definition of interest.\nThe best way to learn path identifiers is by example, so please consider the following example as you read the sections below\ndomain A { domain B { context C { type Simple = String(,30) } type BSimple = A.B.C.Simple // full path starts from root context D { type DSimple = ^E.ESimple // partial path entity E { type ESimple = ^^^C.Simple // E-\u0026gt;D-\u0026gt;B-\u0026gt;C-\u0026gt;Simple type Complicated = ^^^C^D.DSimple // E-\u0026gt;D-\u0026gt;B-\u0026gt;C-\u0026gt;B-\u0026gt;D-\u0026gt;DSimple } } } } Path Identifier Syntax Path identifiers are composed of only the names of the definitions, the caret symbol, ^, and the period character, .. The path is interpreted this way:\nStart in the context of the container definition in which the path occurs If the next symbol is ^ make the context the parent of the current context If the next symbol is an identifier, make the current context that definition If the next symbol is a . it can be considered as the current context and thus ignored. Note that separating the names by periods simply allows us to distinguish the names of adjacent definitions. The resulting definition is the final context.\nFull Path Identifier A full path starts from the root of the hierarchy and mentions each definition name until the sought leaf definition is reached. The full path identifier to the Simple type definition in the example above is A.B.C.Simple which is also used in the definition of the BSimple type\nPartial Path Identifiers Path identifiers can be partial too. All partial path identifiers start with a caret, ^. A single caret indicates the current container definition in the hierarchy, two periods indicates the container\u0026rsquo;s container, three periods indicates the container\u0026rsquo;s container\u0026rsquo;s container, and etc.\nIn the example, the definitions of both DSimple and ESimple use partial paths to name the type.\nFor DSimple the partial path, ^D.E.ESimple, is broken down like this:\nstart with the current definition, type DSimple ^ - go up to context B D - go down to context D . - stay at context D E - select the definition namedE, entity E . - stay at entity E ESimple - select the type named ESimple For ESimple, the partial path, ^^^C.Simple is broken down like this:\nstart with the current container, entity E ^ - go up to context D ^ - go up to domain B C - select context C . - stay at context C Simple - select definition named \u0026ldquo;Simple\u0026rdquo; Complex Partial Path Identifiers The definition of Complicated uses path ^^^C^D.DSimple in the example above. This helps us to see how DSimple is referenced in a complicated path. The complicated part is the ^ between C and D. This path is interpreted like this:\nstart with the current container, entityE ^ - go up one container to context D ^ - go up one container to domain B C - in the current container, domain B, select context C ^ - go up one container to domain B D - in the current container, domain B, select context D . - select the current container, context D DSimple - in the current container, select definition DSimple "},{"id":41,"href":"/language/root/domain/context/entity/invariants/","title":"Invariants","parent":"Entities","content":"Invariants specify rules about the state of an entity that must never be violated. Invariants typically come from business logic assertions. For example, a business axiom of a warehouse might be that the supply of a product should never be below 1. That is, the warehouse should never completely run out of a product it is storing. Reality, of course, must account for the supply running out; nevertheless specifying an invariant on the business intent may be important. This can be done in an entity with the invariant keyword:\ninvariant InSupply is { ProductState.supply \u0026gt; 0 } Invariants are checked every time the corresponding entity\u0026rsquo;s state is modified. If an invariant fails to be satisfied, the state change is aborted and an error is generated.\nSyntax Specifying an invariant may use a variety of common conditional operators familiar to most programming languages and mathematics. The expression provided must evaluate to a boolean value, either true or false. A true value means the invariant is satisfied and a false value means the invariant is not satisfied.\nComparison Operators = equality - The two operands must be equal: op1 = op2 != inequality - The two operands must not be equal op1 != op2 \u0026lt; less - The first operand must be less than the second operand: op1 \u0026lt; op2 \u0026lt;= less-or-equal - The first operand must be less than or equal to the second operand: op1 \u0026lt;= op2 \u0026gt; greater - The first operand must be greater than the second operaond: op1 \u0026gt; op2 \u0026gt;= greater-or-equal = The first operand must be greater than or equal to the second operand: op1 \u0026gt;= op2 Logic and Grouping Operators and - conjunction - Both operands must evaluate to true: op1 and op2 or - disjunction - Either operand must evaluate to true: op1 or op2 not - inverse - The inverse boolean value of the only operand: not op1 () - grouping - Parentheses are used to group operands into a single value: ( ... ) Operand Types constant - Constant values like numbers and strings may be used as operands function - Function invocations that return the right type of value may be used to compare runtime computed values. state - State values of the entity can be used as operands; when multiple state objects are specified, the name of the object must be used with the name of the field, separated by a period. "},{"id":42,"href":"/language/root/domain/streaming/pipe/","title":"Pipes","parent":"Streaming","content":"Pipes are uni-directional conduits for reliably transmitting data of a particular type between the publishers and consumers attached at the ends of the pipe.\nSyntax Example pipe WeatherForecast is { options rate(1000), paritions(7), transmits type Forecast } In the foregoing, a pipe named WeatherForecast is defined to transmit the data type named Forecast and with two options:\nrate - an expected sustained rate of 1000 data points per second partitions - a minimum number of partitions on the data of 7 Data Transmission Type Pipes can transmit any data type that RIDDL can specify. There is only one data type that flows in a pipe. The transmission type is often used with an alternation of message types such as the commands and queries that an entity might receive.\nOptional Pipe Characteristics Pipes may play a large role in the resiliency of a reactive system so we permit a variety of options to be specified no them. These options are intended only as advice to the translators converting the pipe into useful code. For example, a pipe may or may not need to be persistent. If a pipe has the burden of persistence removed, it is likely much more performant because the latency of storage is not involved.\npersistent The messages flowing through the pipe are persisted to stable, durable storage, so they cannot be lost even in the event of system failure or shutdown. This arranges for a kind of bulkhead in the system that retains published data despite failures on either end of the pipe.\ncommitable With this option, pipes support the notion of being commitable. This means the consuming processors of a pipe\u0026rsquo;s data may commit to the pipe that they have completed their work on one or more data items. The pipe then guarantees that it will never transmit those data items to that processor again. This is helpful when the processor is starting up to know where it left off from its previous incarnation.\npartitions(n) For scale purposes, a pipe must be able to partition the data by some data value that is in each data item (a key) and assign the consumption of the data to corresponding members of a consumer group. This permits multiple instances of a consuming processor to handle the data in parallel. The n value is the minimum recommended number of partitions which defaults to 5 if not specified\nlossy By default, pipes provide the guarantee that they will deliver each data item at least once. The implementation must then arrange for data items to be idempotent so that the effect of running the event two or more times is the same as running it once. To counteract this assumption a pipe can be use the lossy option which reduces the guarantee to merely best reasonable effort, which could mean loss of data. This may increase throughput and lower overhead and is warranted in situations where data loss is not catastrophic to the system. Some IoT systems can have this characteristic.\nProducers \u0026amp; Consumers Attached to the ends of pipes are producers and consumers. These are processors of data and may originate, terminate or flow data through them, connecting two pipes together. Producers provide the data, consumers consume the data. Sometimes we call producers sources because they originate the data. Sometimes we call consumers sinks because they terminate the data.\ngraph LR; Producers --\u003e P{{Pipe}} --\u003e Consumers Source --\u003e P1{{Pipe 1}} --\u003e Flow --\u003e P2{{Pipe 2}} --\u003e Sink Pipes may have multiple publishers (writers of data to the pipe) and multiple consumers (readers of data from the pipe). In fact, because of the partitioned consumption principle, there can be multiple groups of consumers, each group getting each data item from the pipe.\nSubscriptions When a pipe has multiple consumers, they are organized into subscriptions. Each subscription gets every datum the pipe carries. Consumers attach to a subscription and there is generally one consumer per partition of the subscription. Sometimes subscriptions are known as consumer groups as is the case for Kafka.\n"},{"id":43,"href":"/language/root/domain/context/projection/","title":"Projections","parent":"Context","content":"A projection can be defined in a context to improve query performance across a large number of entities by providing a read-only view of persistent state across a set of entities.\nNecessity Projections are necessary since persistent entities use event sourcing which is not a query-friendly data layout since it is merely a sequential event log that indicates what changed. To query this event log one would have to reconstruct the current state from each entity\u0026rsquo;s set of events which could be exceedingly time-consuming.\nQueries involving only a single entity never need a projection since the query can be satisfied quite simply by examination of a single entity. When a query must search multiple entities then projections are needed to satisfy that query quickly. Otherwise, a complete scan of all the entities and the reconstruction of each of them would be needed.\nBecause of the foregoing, projections may only be defined in a context or a domain. This requirement limits the set of entities over which the projection is defined to the set reachable as descendents of that context or domain.\nDefinition context Example { entity A { state a { a: Integer, A: String } } entity B { state b { b: String, B: Integer, ARef: Id(A) } } projection \u0026#34;A-and-B\u0026#34; { for entity A { A: String c: Date } for entity B { B: Integer ARef: Id(A) } query GetRecentB { requires { earliestDate: Date } fetch(B) from(A,B) where(A.c \u0026gt;= @earliestDate) } } } A projection definition Projections are constructed by handling events.\nHere\u0026rsquo;s the projection process. Usually, events are logged as they are kept appended at the end of the log file. Logs are string and text. To retrieving meaningful information out of logs, logs are transformed into a more query-friendly format and stored in queriable repository or DB.\n"},{"id":44,"href":"/tutorial/rbbq/scenario/","title":"RBBQ Scenarios","parent":"Example","content":" Case Study The Reactive BBQ restaurant chain has determined that their existing restaurant operations system is not suitably meeting their needs and have hired a high technology consulting company to provide some needed guidance on how they can improve their customer service, tracking, and reliability.\nWhat follows are the interviews conducted with key personnel at Reactive BBQ in order to identify the issues.\nCEO of Reactive BBQ How would you describe your restaurants?\nReactive BBQ is a family restaurant with 500 locations across 20 countries. We\u0026rsquo;re open for breakfast, lunch and supper. Our specialty at Reactive BBQ is our award winning Reactive Ribs, but we are also well known for our tender steaks and our slow roasted chicken. We take traditional BBQ flavours and give them a bit of a spicy punch. The customer experience at each Reactive BBQ should have the same high level of quality across the globe.\nWhat challenges do you face?\nThe challenge is that our original system was designed for one restaurant, and as more were opened, we started moving into the cloud. We started by moving inventory management into the cloud. Then we moved the customers facing areas: reservations, ordering etc. into the same application. We created a website on top of this so that customers can place orders for pickup or delivery, but they can also make reservations online.\nAs we add more locations, the system becomes unresponsive during peak hours as it seems to be struggling to keep up with all the reservations, the servers entering orders, orders being filled, payments, all of these drag everything down to a crawl. Staff gets frustrated, customers even more so, it can take 30 seconds to make a reservation, or enter an order.\nThe Operations team attempted to address the peak time performance issue by adding more instances of the application in the cloud, but this turned out to be quite expensive, and we still see a noticeable lag in response times during peak hours.\nAnother issue is that our application seems to be brittle. When one thing goes wrong, it seems like everything else goes wrong at the same time. I keep hearing reports of outages across the board. And these outages have a huge impact on our business. In the early days, when a problem happened, it affected a single restaurant. But now that we are in the cloud, when the application becomes unavailable it can affect many restaurants or even all of them.\nWe have been forced to limit certain activities during certain times of the day. For example, during the lunch hour on the east coast we aren\u0026rsquo;t allowed to generate certain kinds of reports. The same applies for the west coast. As our operation expands into more time zones, it is become harder to find the right time to do these reports. Ideally doing an inventory report during the lunch rush shouldn\u0026rsquo;t make the system crawl.\nAnother issue is upgrades. Every time we want to upgrade the software we have to take the whole system offline. This is also affected by things like the east coast lunch rush. So again we have to look for specific windows during the day to deploy. Those windows are getting smaller, and the deployments are taking longer. Sometimes when we do an upgrade something goes wrong and the system is unavailable during the times we need it the most. This gets very expensive and very annoying.\nWe have been wanting to implement a loyalty program that requires tracking data about our customers, but our development team tells us this would be a \u0026ldquo;major refactor\u0026rdquo;, and that sounds expensive and risky. I don\u0026rsquo;t really understand the details, but it feels like adding a loyalty program to do the tracking shouldn\u0026rsquo;t be that big of a deal.\nI wanted to implement a new electronic menu for the restaurants. You know, with the tablets on the tables? I thought it would be more environmentally friendly than printing new menus every month. It would also help us follow the trends. Anyway, that apparently was problematic as well. The system that deals with the online menu is really tightly tied up with the fact that it is online and deliveries and all that. I don\u0026rsquo;t really understand the details, but apparently adapting it to work in the restaurant is apparently going to be a lot of work. I would also like to put screens in the kitchen so we could get rid of paper completely.\nCEO\u0026rsquo;s Key Details 500+ Locations Existing Cloud Infrastructure Online Delivery/Pickup Orders, Reservations Experiencing too much downtime Due to upgrades or failures System responds slowly Outages can be very expensive Actions being taken to \u0026ldquo;work around\u0026rdquo; the problems with the system Want to implement a loyalty program but it\u0026rsquo;s risky Want to implement electronic menus but it is also risky Corporate Head Chef What is your role in the restaurant?\nCorporate wants each restaurant to have a consistent experience. My job is to create new recipes to be included in the menu. I spend a lot of time trying out different ingredients and flavours to try to get the right balance for our menu. I have to be careful to stick to ingredients that we can buy in sufficient quantities. Most people think that a restaurant like ours prepares everything from scratch. Sometimes we do, but a lot of our stuff is bought premade in bulk and then shipped to the restaurants. Our Reactive BBQ sauce is a perfect example. Very few people know what goes into the sauce. Even the companies we get to prepare it don\u0026rsquo;t have all the details.\nOnce I have a new dish figured out I talk to the marketing team. They work on preparing a nice description of the dish. We also have a food photographer so I work with him to make sure that the dish looks nice and is presentable for his photos.\nWhat challenges do you face?\nWell, as I mentioned there is the issues with sourcing ingredients. It can be a tricky business with all of the regions we have restaurants in. That\u0026rsquo;s part of the reason why so many things have to be shipped from our warehouses. Some of our ingredients are sourced locally, but not all of them.\nWe have these crazy processes around updating the actual menus. We can\u0026rsquo;t just do it whenever we want. Menus are only updated once a month. That makes sense because there are printer costs and distribution issues we have to think about. Basically once a month, after everything is prepared, I send an email out to all the restaurants with new menu items and recipes. But then we have to coordinate with the printers to make sure they get hard copies delivered in time. And then we have to also coordinate with the website to make sure they are up to date. It becomes a bit of a hassle. Basically near the end of every month we have this flurry of activity to get everything prepared.\nHead Chef\u0026rsquo;s Key Details Corporate Chef updates the menu once a month. Corporate Chef works with photographer on menu photographs. Corporate Chef deals with supply chain for the restaurants. Menu updates must be coordinated with printing and website. Host What is your role in the restaurant?\nI answer phones and record reservations. I also greet and seat guests as they arrive at the restaurant. Guests can either call, or use the website to make reservations, so it is necessary for me to consult the system before I seat customers. I also need to update the reservations system when I seat customers so that someone online can\u0026rsquo;t reserve the same table.\nWhat challenges do you face?\nI think the biggest problem I have is the reservations system. It seems like it is never working properly. Sometimes I try to add a reservation and it takes forever. I have customers lined up waiting for their tables and I don\u0026rsquo;t have time to be dealing with the slow software. Or I might go to look up the reservation for a customer and it takes so long to find it. The customers get frustrated and I am always apologizing to them for the slow software. Sometimes, after waiting forever for the information to come back, the system just crashes and I get nothing. Then it takes minutes or in rare cases hours for it to come back up. In the meantime I am struggling to figure out who is supposed to have a reservation and who isn\u0026rsquo;t.\nI have started printing out all the reservations periodically during the day. It helps to speed things up because I don\u0026rsquo;t have to use the software. But it doesn\u0026rsquo;t work for more recent reservations, so I end up looking at the print outs first and then only going to the software if I don\u0026rsquo;t find the person on the sheet.\nHost\u0026rsquo;s Key Details Host takes reservations in person or via phone Reservations can also be made online Host seats reservations as well as walk ins. Reservation system is unresponsive System often fails Printouts being used to deal with the failures of the software Server What is your role in the restaurant?\nI greet guests at their table, help them understand the menu and make recommendations, then take their food and drink orders. After taking their order I input it into our computer system. When the order is ready I pick it up from the kitchen or bar and deliver it to the table.\nWhen the guest is finished, I present the bill and settle at the table. At the end of the shift I pay out my cash bills to the restaurant, bundle and submit my receipts and collect my tips.\nHow do you know which prepared order from the kitchen/bar is for which table?\nOrders are input into the computer system with the table number, the prepared order is presented with a printout including the table number.\nHow do you settle a bill at the table?\nGuests can pay with cash or card.\nHow do you track how much you\u0026rsquo;ve made in tips for a shift?\nOur computer system keeps track of that for me and gives me a total at the end of the shift.\nWhat challenges do you face?\nDuring peak times things can get a little hectic. Entering orders seems to take longer when we get busy. We have a limited number of computer terminals to enter the information into, so as things slow down the other servers start to line up to enter their orders. We have asked for more terminals, but apparently they are really expensive so they won\u0026rsquo;t give us more.\nSome of us have tried going around the system and just asking the kitchen to start making something before we enter the order, but the cooks really don\u0026rsquo;t like when we do that. They say it\u0026rsquo;s too hard for them to keep track so they want us to use the computer.\nServer\u0026rsquo;s Key Details Server enters orders into the system. Server collects orders from the kitchen and delivers it to the table. Server delivers bills to the tables and collects payments. Server helps customers to understand the menu choices. Software tracks tips etc. System slows down when it\u0026rsquo;s busy. Servers bottleneck on using the computers. Kitchen doesn\u0026rsquo;t like servers working around the system. Bartender What is your role in the restaurant?\nI take drink orders at the bar and entertain the guests. I mix the drinks and take them to the customers when they are ready. When the customer is done for the day I help them settle their tab.\nI also mix drink orders for the servers in the restaurant. The servers deliver those drinks. I just get them ready and leave them on a tray with the table number so the servers know where they go.\nAt the end of a shift I cash out with the restaurant and take my tips.\nWhat challenges do you face?\nSometimes drink orders will sit for a really long time. When a drink is ordered a ticket prints out at my station and I usually make it right away. But the servers get busy, or they forget to check for the order. The drink ends up sitting on the counter for a while before they are able to come and get it. This means the ice is melting and it can really ruin a good drink.\nIt would be nice if there was a way to let the server know that their order is ready. Sometimes I end up looking around and trying to signal them if the drink has been sitting for a while, but they aren\u0026rsquo;t always easy to track down because they might be busy talking to customers. It would be nice if there was some way to get someone else to deliver the drinks. I would do it, but I am not allowed to leave the bar unattended.\nBartender\u0026rsquo;s Key Details Bartender takes drink orders at the bar. Bartender prepares drinks for customers at the bar. Bartender delivers drink orders to customers at the bar. Bartender collects payments for the customers at the bar. Bartender prepares drinks for tables to be taken out be the servers. Collect tips, similar to the server. Would like a way to notify servers when something is ready. Chef What is your role in the restaurant?\nI oversee the entire kitchen and all of its staff. I source local ingredients required to prepare our menu items. The menu is decided on monthly and distributed via email. I inspect all prepared orders that leave the kitchen.\nWhat challenges do you face?\nI think the worst thing is when the system that prints our orders goes haywire. Sometimes the system crashes and orders get lost. While it is down we don\u0026rsquo;t know what needs to be made. The servers have to resort to handwritten tickets and it\u0026rsquo;s sometimes difficult to read their writing. Some of it is really just gibberish. It results in a lot of orders getting missed or getting made improperly.\nThe servers complain a lot about the system being slow, but we don\u0026rsquo;t really see that in the kitchen. Once they enter an order it usually prints out right away as long as the system is working.\nChef\u0026rsquo;s Key Details Chef sources local ingredients for the menu. Chef inspects all orders that leave the kitchen. Orders get lost when the system fails. Handwritten tickets are a pain. Cook What is your role in the restaurant?\nDepending on the day, I work at different stations in the kitchen. The chef tells me where I will be working for that day. I prepare orders according to the tickets that get printed out at my station. Once an order is ready, I take it over to a station where we gather all the pieces of that order. The chef then approves it and we notifiy the server that their order is ready.\nWhat challenges do you face?\nHandwritten tickets. Man do I hate those things. We have this one server that writes in this horrible chicken scratch. Every time he brings me these tickets, I have to get her to explain to me what she has written. It\u0026rsquo;s just awful.\nThen there is the server\u0026rsquo;s attitudes. It\u0026rsquo;s pretty good most of the time, but when things get busy they start to get really annoying. When they get frustrated they kind of take it out on us in the kitchen. They start yelling about their orders taking too long. I try to explain to them that there are other orders that came first and I have to do them before I can get to theirs, but it doesn\u0026rsquo;t help. They end up storming off. I hear them talking sometimes like it\u0026rsquo;s our fault somehow.\nCook\u0026rsquo;s Key Details Printed Ticket provide details on orders to be prepared. Handwritten tickets are a pain. Servers are frustrated. Delivery Driver What is your role in the restaurant?\nI deliver for five locations around the city. We don\u0026rsquo;t get a lot of deliveries. We aren\u0026rsquo;t a pizza place after all. but our wings and ribs are popular delivery options. I am on call for each of the delivery locations. If one of them gets a delivery, I get a notification on my phone. I go pick up the food from the location nearest the customer. Then I drive to the customer, and deliver their food. I collect their payment if necessary. Sometimes they pay online. In that case I don\u0026rsquo;t have to do much, just drop off the food.\nWhat challenges do you face?\nYou mean other than traffic and customers annoyed with the delivery times? I think the app they give me is probably my biggest headache. I have this app on my phone. When I get a delivery it notifies me. It gives me all the details about the order and the customer. I also have a dongle that I attach to my phone that allow me to collect credit/debit payments.\nThe problem is that sometimes it doesn\u0026rsquo;t work. I will be on the way to a customer site when suddenly it just stops. I get some error like \u0026ldquo;unable to communicate with server\u0026rdquo; or something. When that happens I lose everything. I don\u0026rsquo;t have access to the customer address or their order. Thankfully they always print that information out on the bill before the delivery so I can still use that. But then when I go to collect the payment I end up having to use one of those old credit card swipe machines. The manual ones that take an imprint of the card. That doesn\u0026rsquo;t work if the customer planned to pay with debit though. In those cases I am out of luck.\nApparently they are going to start offering customer loyalty cards as well. They tell me that those will go through the same app. That just sounds like more headache. So now when the system goes down I am going to have to write down the customer\u0026rsquo;s loyalty number, and then enter it when manually when the system comes back up.\nDelivery Driver\u0026rsquo;s Key Details Driver gets notifications through the app on their phone. Driver picks up orders and delivers them to the customer. Driver collects payments. Workarounds for unreliable software in the form of printed receipts. Online Customer Describe how you place an order online with Reactive BBQ\nWell, I go to the website and they have their menu there. I have a look at the menu and decide what I want. The menu is organized into different sections, like lunch, dinner, appetizers, dessert, that sort of thing. The menu online isn\u0026rsquo;t identical to what I get in the restaurant, but it\u0026rsquo;s pretty close. I have also done it through the phone app they have.\nAs I find things that I want, I add them to my order. Then when I have everything I want, I checkout.\nTo checkout I have to give them some information, like the delivery address, my phone number, that sort of thing. I also have to give them my credit card information so that I can pay for it. I order pretty often though, so they have all of that stuff on file already. I just enter my username and password. Once that is done, I finish the order and then I have to wait.\nAnd what happens when your food is delivered?\nThe driver brings the food to the door. They hand me the food. I usually pay online. I love that when they come to the door, I don\u0026rsquo;t have to give them money. I can enter a tip online too so that I don\u0026rsquo;t have to give them anything, but it always feels a bit weird to tip them when they haven\u0026rsquo;t delivered the food yet. If I have cash I will often pay for the food online but then give them the tip in person. I live pretty far away and it\u0026rsquo;s a bit of a drive for them, so I usually tip them pretty well. I like to see their smile when I give it to them in person.\nDo you ever order pickup?\nSometimes. I order pickup once in a while and just grab it on my way home from work. I can still order online so I usually do that, and then I just choose pickup instead of delivery. Sometimes, if I am away from my computer, I will just phone them and order something instead.\nDo you ever have trouble ordering online?\nSometimes. Their website and app aren\u0026rsquo;t always working. Or if it is working it can be really slow. I don\u0026rsquo;t mind waiting when it\u0026rsquo;s slow, unless I am in a hurry or really hungry. But when it doesn\u0026rsquo;t work at all, I usually just don\u0026rsquo;t bother. When that happens I will usually just order from the other place down the street. The food isn\u0026rsquo;t as good, and their website is kind of hard to use, but it gets the job done in a pinch.\nHave you ever used the online reservation system?\nI have used it once or twice. I usually eat at home so I don\u0026rsquo;t use it that often. But it has been okay when I have used it. I don\u0026rsquo;t get to pick specific tables or anything. I just give them a few details about what I want, like how many people, whether I want a booth, that sort of thing.\nOnline Customer\u0026rsquo;s Key Details Customer adds menu items to their order through the website/app. Customer checks out when they have completed their order. Customer enters delivery or pickup information. Customer authorizes payment and tip through the website/app. Customer makes reservations through the website/app. Website/app doesn\u0026rsquo;t always work, forcing customer to go elsewhere. "},{"id":45,"href":"/language/root/domain/story/","title":"Story","parent":"Domain","content":" Example story WritingABook is { role is \u0026#34;Author\u0026#34; capability is \u0026#34;edit on the screen\u0026#34; benefit is \u0026#34;revise content more easily\u0026#34; accepted by { example one { given \u0026#34;I need to write a book\u0026#34; when \u0026#34;I am writing the book\u0026#34; then \u0026#34;I can easily type words on the screen instead of using a pen\u0026#34; } described by \u0026#34;nothing\u0026#34; example two { given \u0026#34;I need to edit a previously written book\u0026#34; when \u0026#34;I am revising the book\u0026#34; then \u0026#34;I can erase and re-type words on the screen\u0026#34; } described as \u0026#34;nothing\u0026#34; } implemented by { ??? } } described as \u0026#34;A simple authoring story\u0026#34; "},{"id":46,"href":"/tooling/riddlc/using-the-get-riddlc-action/","title":"Using riddlc/actions/get-riddlc@main","parent":"riddlc","content":"If you plan to develop a RIDDL specification and place the code for it into a GitHub repository, there is a GitHub action to automate the running of model validation and documentation generation in Pull Requests easier.\nDefining A Workflow The workflow shown below is sufficient for many projects. You should be able to just copy and paste it to .github/workflows/validate-riddl.yaml and all your main merges and pushes to a pull-request branch will automatically validate the source.\nname: Validate RIDDL on: push: branches: [ main ] pull_request: branches: [ main ] workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: Set Up JDK 17 uses: actions/setup-java@v2 with: java-version: \u0026#39;17\u0026#39; distribution: \u0026#39;temurin\u0026#39; - name: Get riddlc uses: reactific/riddl/actions/get-riddlc@main - name: Validate improving-app model with riddlc run: | echo RIDDLC = \u0026#34;$RIDDLC\u0026#34; which riddlc riddlc from \u0026#34;src/main/riddl/ImprovingApp.conf\u0026#34; validate shell: bash GitHub actions and workflows are documented at this link\n"},{"id":47,"href":"/language/root/domain/context/saga/","title":"Saga","parent":"Context","content":" Introduction A Saga defines a way for an external application to invoke a distributed transaction via the Saga Pattern. Sagas are necessary in distributed services that use the Database per Service Pattern, like RIDDL. The Saga Pattern definition describes the context in which Sagas are used:\nYou have applied the Database per Service pattern. Each service has its own database. Some business transactions, however, span multiple service so you need a mechanism to implement transactions that span services. For example, let’s imagine that you are building an e-commerce store where customers have a credit limit. The application must ensure that a new order will not exceed the customer’s credit limit. Since Orders and Customers are in different databases owned by different services the application cannot simply use a local ACID transaction.\nThe goal of a saga is to define a function across multiple entities that must atomically succeed with state changes, or fail with no state changes. So, a saga defines a set of commands to send to incur changes on entities, and a set of commands to undo those changes in case it cannot be atomically completed.\nSagas are very like functions but they only involve the sending of commands to entities. Sagas generally involve one or more different kinds of entities, or multiple entities of the same kind.\nExample saga AllOrNothing is { options(parallel) requires { p1: String, p2: String } yields { result: String } action Step1 for entity Thingy is { command DoIt reverted by UnDoIt as { example One is { then \u0026#34;pass p1 to entity Thingy with DoIt\u0026#34; } } } action Step2 for entity Thingy is { command CheckIt reverted by UnCheckIt as { example One is { then \u0026#34;pass p2 to entity Thingy with CheckIt\u0026#34; and \u0026#34;yield the result from the reply from Thingy\u0026#34; } } } } defines saga, AllOrNothing, with two input parameters, an output string, and two steps to be done in parallel.\nFurther Reading IBM: Saga Pattern Microsoft: Saga Distributed Transaction Pattern Chris Richardson "},{"id":48,"href":"/guides/implementors/ways-to-use-riddl/","title":"Different Ways To Get/Use RIDDL","parent":"Implementor's Guide","content":"There are several ways to get riddl software on to your computer, depending on how you want to work.\nDownload Staged Integrate With SBT RiddlSbtPlugin Download This is the simplest way to get riddlc. It should run on Windows, Mac and Linux. Follow these steps:\nGo to the riddlc downloads page Click on the release title you want to install Scroll down to the \u0026ldquo;Assets\u0026rdquo; section Download the riddlc-{version}.zip file Unzip that file on your computer Place the riddlc-{version}/bin directory in your path Staged To use riddlc locally and be able to update it with new changes without a large download, use this approach:\ngit clone https://github.com/reactific/riddl.git cd riddl Put the ./riddlc/target/universal/stage/bin directory in your PATH variable using a full path instead of \u0026ldquo;.\u0026rdquo; Run sbt stage to build the program To update, run git pull from the riddl cloned repository directory and rerun sbt stage to rebuild. This allows you to both make local changes and pull in changes from others to keep your local copy of riddlc up to date.\nIntegrate With SBT TBD.\nRiddlSbtPlugin To use the sdt-plugin you must first have installed riddlc by one of the above methods. This approach allows you to run riddlc commands from a sbt based project. The command you configure will run first when you use the compile command in sbt. Follow these steps:\nIn your plugins.sbt file, add: `addSbtPlugin(\u0026ldquo;com.reactific\u0026rdquo; % \u0026ldquo;sbt-riddl\u0026rdquo; % \u0026ldquo;{version}\u0026rdquo;). You can find the latest available version here In your build.sbt file, use enablePlugins(SbtRiddlPlugin) on your project Set the following sbt settings: riddlcPath := file(\u0026quot;...\u0026quot;) This defaults to \u0026ldquo;riddlc\u0026rdquo; which is appropriate if the right version is in your path; otherwise specify the full path to the riddlc command riddlcOptions := Seq(\u0026quot;from\u0026quot;, \u0026quot;path/to/config/file\u0026quot;, \u0026quot;hugo\u0026quot;) This is just an example, you can put any command or options you want in that sequence. Use riddlc help to find out what commands you can use. To run a translator in this way, put a riddlc.conf file next to the top level .riddl file you want to translate. The content of that file can specify common options and the commands you want to support from sbt-riddl, like the example below, taken from the riddl-examples project. These files use Human-Oriented-CONfiguration common { show-times = true verbose = true quiet = false dry-run = false show-warnings = true show-missing-warnings = false show-style-warnings = false } hugo { input-file = \u0026#34;ReactiveBBQ.riddl\u0026#34; output-dir = \u0026#34;target/hugo/ReactiveBBQ\u0026#34; project-name = \u0026#34;Reactive BBQ\u0026#34; site-title = \u0026#34;Reactive BBQ Generated Specification\u0026#34; site-description = \u0026#34;This site provides a specification for the Reactive BBQ application as generated by riddlc\u0026#34; site-logo-path = \u0026#34;images/RBBQ.png\u0026#34; erase-output = true base-url = \u0026#34;https://bbq.riddl.tech\u0026#34; source-url = \u0026#34;https://github.com/reactific/riddl\u0026#34; edit-path = \u0026#34;/-/blob/main/src/riddl/ReactiveBBQ\u0026#34; } validate { input-file = \u0026#34;ReactiveBBQ.riddl\u0026#34; "},{"id":49,"href":"/guides/implementors/","title":"Implementor's Guide","parent":"Guides","content":"Implementors are the technical experts who implement the system defined in a RIDDL specification. These people are most often Software, QA, and DevOps Engineers. Of course, throughout implementation they will be supported by the Author(s), Domain Experts, and other related staff. Implementors use the output from the RIDDL tools to aid in their comprehension and coding of a solution that corresponds to the RIDDL system specification or model.\nIt is incumbent on the author and implementation team members to keep the RIDDL sources up to date and accurate as the system evolves. The implementation team members must notify the author of changes to the model that the technical implementation necessitates.\nImplementors should be experts in Reactive Architectures. In addition, software engineers, and to a certain extent, other implementors need to be well versed in the implementation tech stack. The creators of the RIDDL language have found that Scala and Akka deployed into a cloud environment provide the best tooling and support for implementing a reactive system. It is not surprising then, that some concepts and constructs found in RIDDL have strong parallels to these tools. It must be noted, however, that reactive systems can be implemented using a variety of languages, frameworks, environments, products and tools. Cloud native offerings can be used with great effect. The critical point is, throughout implementation, reactive principles must be forefront in mind as implementation choices are made.\nIt must also be stated at this point that even though it may conflict with reactive principles, the business has final say in major implementation choices. It is incumbent on the implementation team to advise decision makers on the risks and challenges that are posed by making choices that conflict with reactive principles. Factors like time, cost, user experience, business rules, availability of technical talent, strategic partners, and so on are all extremely important and may conflict with the choices of the implementation team and sound reactive architecture.\nDifferent Ways To Get/Use RIDDL "},{"id":50,"href":"/tooling/riddlc/from-config-file/","title":"riddlc Config File","parent":"riddlc","content":"You can store your options to riddlc in a file and use that file with the from command. The configuration files use HOCON as the input format. Here\u0026rsquo;s an example:\n# This file contains the input parameters to riddlc for use with `riddlc from` command. # We want to run the \u0026#34;hugo\u0026#34; command in riddlc so that riddl input is converted to input for the hugo web site generator. command = hugo # This block provides options that are common to any command. common = { show-times = true verbose = true quiet = false dry-run = false hide-warnings = true hide-missing-warnings = true hide-style-warnings = true debug = true show-unused-warnings = false } # This block provides options for the \u0026#34;hugo\u0026#34; command to translate riddl to a hugo web site. hugo { input-file = \u0026#34;ImprovingApp.riddl\u0026#34; output-dir = \u0026#34;target/hugo/\u0026#34; erase-output = true project-name = \u0026#34;ImprovingApp\u0026#34; enterprise-name = \u0026#34;Improving Inc.\u0026#34; site-title = \u0026#34;RIDDL Specification For improving.app\u0026#34; site-description = \u0026#34;This site provides the documentation generated from the RIDDL specification for the improving.app\u0026#34; site-logo-url = \u0026#34;https://avatars.slack-edge.com/2022-08-03/3892148238579_bdc8d3ad2e5b91bd6cda_88.png\u0026#34; site-logo-path = \u0026#34;images/logo.png\u0026#34; erase-output = true base-url = \u0026#34;https://riddl.improving.app\u0026#34; source-url = \u0026#34;https://github.com/improving-ottawa/improving-app-riddl\u0026#34; with-glossary = true with-todo-list = true with-graphical-toc = false } stats { input-file = \u0026#34;ImprovingApp.riddl\u0026#34; } validate { input-file = \u0026#34;ImprovingApp.riddl\u0026#34; } Example command syntax: riddlc from path/to/hocon/file/above validate\nThis would use the \u0026ldquo;common\u0026rdquo; and \u0026ldquo;validate\u0026rdquo; sections of the hocon file for configuration and then run the validate command. The file validated is specified by the input-file setting. The common options specify that the validate command, or any other command supported by the hocon file would:\nshow-times = true - print out the durations of each of the phases verbose = true - print detailed information on what riddlc is doing quiet = false - print all messages at end of run dry-run = false - actually do the work, not just process the options hide-warnings = true - hide all kinds of warnings hide-missing-warnings = true - display no warnings about missing definitions hide-style-warnings = true - display no warnings about specification style debug = true - print debug info, typically only useful to implementors show-unused-warnings = false - display no warnings about unused definitions "},{"id":51,"href":"/tutorial/rbbq/scenario/host/","title":"Host","parent":"Reactive BBQ Case Study","content":"What is your role in the restaurant?\nI answer phones and record reservations. I also greet and seat guests as they arrive at the restaurant. Guests can either call, or use the website to make reservations, so it is necessary for me to consult the system before I seat customers. I also need to update the reservations system when I seat customers so that someone online can\u0026rsquo;t reserve the same table.\nWhat challenges do you face?\nI think the biggest problem I have is the reservations system. It seems like it is never working properly. Sometimes I try to add a reservation and it takes forever. I have customers lined up waiting for their tables and I don\u0026rsquo;t have time to be dealing with the slow software. Or I might go to look up the reservation for a customer and it takes so long to find it. The customers get frustrated and I am always apologizing to them for the slow software. Sometimes, after waiting forever for the information to come back, the system just crashes and I get nothing. Then it takes minutes or in rare cases hours for it to come back up. In the meantime I am struggling to figure out who is supposed to have a reservation and who isn\u0026rsquo;t.\nI have started printing out all the reservations periodically during the day. It helps to speed things up because I don\u0026rsquo;t have to use the software. But it doesn\u0026rsquo;t work for more recent reservations, so I end up looking at the print outs first and then only going to the software if I don\u0026rsquo;t find the person on the sheet.\nHost\u0026rsquo;s Key Details Host takes reservations in person or via phone Reservations can also be made online Host seats reservations as well as walk ins. Reservation system is unresponsive System often fails Printouts being used to deal with the failures of the software "},{"id":52,"href":"/tooling/editor-plugins/vs-code-plugin/","title":"VSCode Plugin","parent":"Getting Ready To Go","content":"This project has not started yet but has a high priority attached to it.\nLike other languages, RIDDL will have a Visual Studio Code plugin to do syntax highlighting and error checking to help authors write the language effectively.\n"},{"id":53,"href":"/introduction/what-is-riddl-based-on/","title":"What is RIDDL Based On?","parent":"Introduction","content":"The RIDDL specification language borrows concepts from:\nDomain Driven Design (DDD) Reactive System Architecture (RSA) C4 Model Of Software Architecture Akka Agile User Stories Behavior Driven Development (BDD) Finite State Machines Command/Query Separation CQRS Event Sourcing Saga Pattern Unified Modeling Language (UML) RIDDL aims to capture business concepts, system designs and architectural details in a way that is consumable by business professionals yet can also be directly translated into various technical and non-technical artifacts, including:\na documentation web-site various architectural diagrams (context maps, sequence diagrams, and so on) design input to code generators (e.g. Kalix, protobuffers) Kubernetes deployment descriptors code scaffolding and templates that implement the design captured in the RIDDL specification and more; please see the future projects section Using these outputs, delivery teams are well-equipped to quickly begin the task of implementation. Regeneration of the model in subsequent iterations of the design are accommodated and continue to provide value through the evolution of the design without interrupting the implementation.\nDomain Driven Design (DDD) RIDDL is based on concepts from DDD. This allows domain experts and technical teams to work at a higher level of abstraction by co-creating a ubiquitous language for the target domain enabling them to develop a system specification that is familiar and comprehensible by business and technical leaders alike.\nFor best comprehension of the RIDDL language, it is best to be familiar with DDD concepts. For a four-minute overview watch this video. For a more in depth understanding we recommend reading Vaughn Vernon\u0026rsquo;s more concise book Domain Driven Design Distilled, or Eric Evans\u0026rsquo; original tome Domain Driven Design: Tackling Complexity in the Heart of Software\nReactive System Architecture (RSA) The Reactive Manifesto was authored in 2014 by Jonas Bonér, David Farley, Roland Kunh, and Martin Thompson. As the computing landscape evolved and companies began to operate at \u0026ldquo;internet scale\u0026rdquo; it became evident that the old ways of constructing systems were not adequate. We needed an approach to system architecture back then that was fundamentally different in order to meet user expectations.\nThe central thesis of reactive architectures is that the overriding objective in any system must be responsiveness. Users are conditioned to expect systems that perform well and are generally available. If these conditions are not met, users tend to go elsewhere to get what they want. That, of course, is clearly unacceptable for any business endeavor. To maintain responsive to users, a system must deal with various responsiveness challenges:\nsystem or component failure (resiliency) increasing work load (scalability) high operational cost (efficiency) slow responses (performance) A reactive system aims to be responsive in the face of all of these challenges. Without going into too much detail here, among the key means of achieving responsiveness is to decompose the concerns of a domain into well isolated blocks of functionality (DDD), and then, establishing clear non-blocking, asynchronous, message-driven interfaces between them. Together, the concepts of, Responsiveness, Elasticity, Resiliency, and Message-Driven form the basis of a Reactive Architecture.\nTo get more information on Reactive Architecture please refer to the excellent 6 part course by Lightbend. You can find the first course in that series here.\nUnified Modeling Language (UML) One of the key insights brought forward by UML is that it is far easier for humans to comprehend the intended design of a system by communicating these ideas with pictures. UML is a language of very precise graphical symbols that communicate different concerns of a system design.\nThis idea has been further leveraged by other design artifacts and activities. For example, a very common DDD exercise is called Event Storming. In this exercise a group of experts brainstorms about the things that happen, concrete events, within a system. Event Storming uses a very low fidelity tool to capture the details of the exercise. In this exercise, traditionally events are captured first on orange sticky notes. The commands that generate those notes are then captured on blue stickies. And the actors that initiate those commands are captured on yellow stickies. And so on. More information on event storming can be found here and here\nRIDDL uses many of the design artifacts detailed under the UML specification to help communicate the design and intent of a system. For example, Sequence Diagrams are used extensively to document the interactions between bounded contexts in a system. A State Machine Diagram may be used to document the lifecycle of an entity or actor in a system, and so on. However, RIDDL\u0026rsquo;s diagram output is not limited to UML diagrams. Peter Chen\u0026rsquo;s 1971 invention of the entity relationship diagram is very well adapted to the concept of entity in DDD. DDD also has its own diagrams:\nthe System Context Diagram provides a depiction of the actors, internal systems, external systems, and how they interact (use cases). the Context Map is a high level diagram that portrays the general relationships between bounded contexts. Business Use Case Diagram - same idea as the UML version but simpler More on that can be found here\nAgile User Stories Agile user stories are used to capture the requirements of various components within a system. In RIDDL we capture these user stories as a Feature.\nAs a [persona], I [want to], [so that]\u0026hellip;\nIn other words, it provides WHO (persona), WHAT (want to), and WHY (so that).\nBehavior Driven Design (BDD) Behavior-driven development was pioneered by Daniel Terhorst-North. It grew from a response to test-driven development (TDD), as a way to help programmers on new agile teams “get straight to the good stuff” of knowing how to approach testing and coding, and minimize misunderstandings. BDD has evolved into both analysis and automated testing at the acceptance level. Cucumber Documentation BDD provides a simple specification language named Gherkin which is used heavily in RIDDL. Even if you are not familiar with the Gherkin language, it is simple enough and intuitive enough to be grasped quickly.\nGherkin scenarios follow a simple structural pattern, like this:\nSCENARIO: \u0026lt;scenario description\u0026gt; GIVEN \u0026lt;a precondition\u0026gt; WHEN \u0026lt;an event occurs\u0026gt; THEN \u0026lt;take an action\u0026gt; RIDDL uses this structure to define the processing that should occur when defining how an event should be handled, when a function is invoked. Most of it is free-form natural language. Consequently, RIDDL is not a precise programming language.\nagile circles or considered BDD as a tool for testing, you have likely encountered Gherkin language. It follows the familiar, Given - When - Then format of capturing a user story.\n"},{"id":54,"href":"/guides/developers/grammar/domain/","title":"Domain","parent":"Grammar","content":"See domains for examples and explanations of the following grammar productions\n(* RIDDL EBNF Grammar for knowledge domains *) domain include = \u0026#34;include\u0026#34;, literalString domain content = typeDef | topic | interaction | context | domain | domainInclude domain = \u0026#34;domain\u0026#34;, identifier, \u0026#34;is\u0026#34;, \u0026#34;{\u0026#34;, (undefined | domainContent), \u0026#34;}\u0026#34;, description "},{"id":55,"href":"/language/common/examples/","title":"Examples","parent":"Common","content":"RIDDL uses Gherkin examples in various places to express a functionality or behavior requirement on the definition that uses it. Gherkin examples are used in these places:\nAdaptors Handlers Functions Processors Projections Saga Actions Story Structure Gherkin is a language developed by SmartBear Software, a vendor of software quality tools, for the cucumber testing system. RIDDL uses a subset of the language as SmartBear has defined it. Four constructs are used in RIDDL:\nGIVEN - A description of the scenario, environment, or setting of the example WHEN - A condition that must be true for this example to be applicable THEN - An action, or set of actions, that are to be performed BUT - An action, or set of actions, that are not to be performed Example example AllDone is { Given \u0026#34;I am out shopping\u0026#34; And \u0026#34;I have eggs\u0026#34; And \u0026#34;I have milk\u0026#34; And \u0026#34;I have butter\u0026#34; When \u0026#34;I check my list\u0026#34; Then \u0026#34;I don\u0026#39;t need anything\u0026#34; } "},{"id":56,"href":"/tooling/riddlc/translation/hugo/","title":"Hugo Docs","parent":"Translation","content":"One of the main features of the RIDDL compiler is generating HTML documentation. The documentation enjoys the advantage of being more complete and accurate due to the compiler\u0026rsquo;s rigorous analyses. The riddlc compiler generates Hugosources for conversion to a web-site by the hugo generator. See Hugo Documentation for details on how to\n"},{"id":57,"href":"/tooling/riddlc/install/","title":"Installing `riddlc`","parent":"riddlc","content":"This guide helps you to install the riddlc tool on your local computer. Before installation, you will need to follow the steps defined on the build page.\nUniversal Installer RIDDL\u0026rsquo;s build system can generate a universal installation package that produces a zip file that can be unpacked and it provides a script to run on MacOS, Windows, and Linux.\n1. Build Universal Installer \u0026gt; project riddlc \u0026gt; universal:packageBin 2. Move Generated ZIP File a. Step 1 will have produce a .zip file in the riddlc/target/universal directory. b. Copy this .zip file to the machine on which you wish to install riddlc c. On that machine, unpack the .zip file with unzip \u0026lt;path-to-zip\u0026gt; You will now have a directory named something like:riddl-0.5.6/bin but the version # might be different. d. Put that bin directory in your path e. Now you can just run riddlc from the command line\nNative Installer TBD. Some day we will have a native installer for each platform.\n"},{"id":58,"href":"/language/","title":"Language","parent":"Index","content":"This section presents the RIDDL source language syntax, one definition at a time according to their typical arrangement.\nWarning This section of the documentation has not been maintained well and is due for re-synchronization with the concepts section Overview Prerequisites Definitional Hierarchy Overview RIDDL is not a Turing complete language. However, it is intended to be used to create systems that are Turing complete. Consequently, RIDDL is not a programming language, it is a system specification language, and not only at software developers.\nWe expected business managers, business analysts, knowledge domain experts, system architects, and software developers to all be able to read and comprehend RIDDL models with only a little training and DDD background. The language tries hard to be readable in English and not overly technical while still retaining the ability to be precise, concise, and specific enough to be used for software source code generation.\nThe language is opinionated in the sense that it is intended for the specification of large scale distributed software systems. It does not attempt to be useful for every kind of computing problem nor even every kind of knowledge domain. Several distributed software architecture patterns have been adopted as natural extensions of domain driven design. Data engineering and user interface ideas are also included.\nPrerequisites We recommend that you first read the Language Conventions (not documentation conventions!) to which RIDDL adheres. These conventions are aimed at making RIDDL models consistent, simple, and free of special cases and exceptions.\nNext, there are several concepts that are used in a variety of places in the language. The Common section describes these concepts in preparation for looking at the major definitions in the language.\nDefinitional Hierarchy RIDDL\u0026rsquo;s basic structure is a containment hierarchy of nested definitions. That is, definitions are defined by their contained definitions. At the root of that definitional hierarchy is a single file known as the root file. The name of this file is given to riddlc to start processing a specification.\nSo, we can explore and learn the RIDDL language by examining each level of the definitional hierarchy like peeling the layers of an onion to discover what is hidden at each level.\nStart with the Root.\n"},{"id":59,"href":"/language/root/domain/streaming/processor/","title":"Processors","parent":"Streaming","content":"As the name indicates, a RIDDL processor definition specifies the inputs and outputs of some processor of data. The inputs to the processor are declared with inlet statements and the outputs from the processor are declared with outlet statements.\nInlets An inlet statement in the definition of a processor provides the name and data type for an input to the processor. There can be multiple inlets to the processor but each one must have a separate inlet statement. A processor with no inlets defined is called a source since it originates data and only has an outlet.\nOutlets An outlet statement in the definition of a processor provides the name and data type for an output of the processor. There can be multiple outlets to the processor but each noe must have a separate outlet statement. A processor with no outlets is called a sink since it terminates data and only has an inlet.\nKinds Of Processors RIDDL supports six kinds of processors that are used as the keyword to introduce the processor. The kind of processor depends solely on the number of inlet sand outlets that are defined. The keyword used ensures RIDDL knows how to validate the intention for the number of inlets and outlets.\n# of Inlets # of Outlets Kind Description 0 1 Source Sources originate their data, and publish it to an outlet 1 0 Sink Sinks terminate their data, and consume it from their inlet 1 1 Flow Flows transform their data from inlet to outlet 1 any Split Splits their data from one source to multiple outlets any 1 Merge Merges their data from multiple intles to a single outlet any any Multi Any other combination is a many-to-many flow Syntax Examples source GetWeatherForecast is { outlet Weather is type Forecast } explained as \u0026#34;This is a source for Forecast data\u0026#34; flow GetCurrentTemperature is { inlet Weather is type Forecast outlet CurrentTemp is type Temperature } explained as \u0026#34;This is a Flow for the current temperature, when it changes\u0026#34; sink AttenuateSensor is { inlet CurrentTemp is type Temperature } explained as \u0026#34;This is a Sink for making sensor adjustments based on temperature\u0026#34; The above example shows the definition of three processors of different types. GetWeatherForecast is a source of data that generates weather forecast data as type Forecast. Presumably, that data could be used as the input to the flow named GetCurrentTemperature which takes the forecast and puts out temperate changes as indicated by the latest Forecast received. Finally, the AttenuateSenso processor is a sink of data that makes adjustments to a sensor\u0026rsquo;s attenuation based on the temperature.\n"},{"id":60,"href":"/tutorial/rbbq/reactivebbq/","title":"Reactive BBQ","parent":"Example","content":"Render https://github.com/reactific/riddl-examples/blob/main/src/riddl/ReactiveBBQ/ReactiveBBQ.riddl Everything in RIDDL revolves around creating domains and subdomains. These are logical groupings of definitions that belong together, presumably because they mimic and organizations structure or some other logical, real world groupings. Domains can be nested.\nAt this top level of definition we can see that a single domain named ReactiveBBQ represents the entire enterprise. The details of that top level domain is abstracted away via three include statements within its body, one for each of the subdomains:\nRestaurant Back Office Corporate "},{"id":61,"href":"/language/root/","title":"Root","parent":"Language","content":"The Root level of the definitional hierarchy is the top most concept in the language but there is no syntax to define a \u0026ldquo;Root\u0026rdquo;. Instead, you just create definitions in a file. The \u0026ldquo;Root\u0026rdquo; concept is identical to the file content.\nAt the Root (file) level you can only do two things:\ninclude definitions from another file, define a top level domain For example:\ninclude \u0026#34;other-file\u0026#34; domain foo is { ??? } In this example, we have included all the definitions from \u0026ldquo;other-file\u0026rdquo; but they can only be domain definitions. This example also abstractly defines a domain named foo.\nNow, you can use the tree below to navigate the definitional hierarchy. We recommend you start with Domain and work your way down from there.\nDomain Context Entities Options State Invariants Entity Handler Function Adaptors Projections Saga Features Context Handler Story Streaming Pipes Processors Plants "},{"id":62,"href":"/tooling/sbt-riddl/","title":"sbt-riddl","parent":"Tooling","content":"RIDDL provides an\nSBT plugin for convenience in other projects that want to run riddlc easily from SBT.\nTo install the SBT plugin all you need to do is add the following to your project/plugins.sbt file:\naddSbtPlugin(\u0026#34;com.reactific\u0026#34; %% \u0026#34;sbt-riddl\u0026#34; % \u0026#34;{version}\u0026#34;) Make sure to replace {version} with an appropriate version\nThen, specify options in your build.sbt file like this:\n// Enable the plugin you installed enablePlugins(RiddlSbtPlugin) // Specify the options to riddlc that you want to run when the `compile` // command is used. This allows riddlc to be a code generator riddlcOptions := Seq( \u0026#34;--verbose\u0026#34;, \u0026#34;from\u0026#34;, \u0026#34;path/to/config/file\u0026#34;, \u0026#34;hugo\u0026#34; ) // Specify the minimum riddlc version to processor you RIDDL specification riddlcMinVersion := \u0026#34;0.14.0\u0026#34; The riddlcOptions setting provides all the options to riddlc that you want to run during compile. You would specify in this setting all the needed options to cause riddlc to generate your sources, presumably used in subsequent compilation steps.\n"},{"id":63,"href":"/language/common/types/","title":"Types","parent":"Common","content":" Introduction The RIDDL language allows users to define data types. Definitions of types are more limited in RIDDL than in programming languages on purpose. The type system must be easily understandable by non-programmers as the domain engineer or domain expert is likely the most frequent user.\nPredefined Types RIDDL supports several predefined types that just \u0026ldquo;exist\u0026rdquo; because they are fundamental and well understood in any targeted computing environment. These predefined type names can be used anywhere that a type definition is needed, for example in a field of an entity\u0026rsquo;s state definition see here\nThe predefined types are:\nString - a sequence of characters of any length Boolean - a binary value for true/false logic Number - a numeric value either integer or decimal Integer - a numeric value that excludes fractional parts Decimal - a numeric value that includes fractional parts Real - a real number Id - a globally unique identifier Date - a date value Time - a time of day value DateTime - a date and a time value together TimeStamp - a date and time combined with at least millisecond accuracy Duration - the amount of time between a start and stop time LatLong - a position on earth Nothing - a type that cannot hold a value URL - a uniform resource locator of any scheme Named Type Definitions In addition to the predefined types, RIDDL supports the definition of new types using a name and a type expression with this syntax:\ntype name = \u0026lt;type-expression\u0026gt; When defining values, one must use a named type defined with the type keyword. This enforces legibility by naming every type expression.\nType Expressions RIDDL supports a variety of type expressions for defining named types. The following sections define the kinds of expressions allowed.\nRenames It is possible to rename a predefined or previously defined type as another type name. This is common to increase domain applicability of the name of a predefined type. For example,\ntype FirstName = String // rename a predefined type for clarity might be used to make it clear that the intended use of the String value is to provide a person\u0026rsquo;s first name.\nBounded Strings The predefined types allow use of unbounded strings but when you want to fix the minimum or maximum length of a string, it may only be used in a type expression. The expression String(\u0026lt;min\u0026gt;, \u0026lt;max\u0026gt;) can be used to define such a type. Both \u0026lt;min\u0026gt; and \u0026lt;max\u0026gt; are optional. \u0026lt;min\u0026gt; defaults to 0, and max defaults to infinite. For example;\ntype FirstName = String(2, 30) // string between 2 and 30 chars inclusive type LastName = String(,30) // string between 0 and 30 chars type Unbounded = String(,) // unbounded, same as just \u0026#34;String\u0026#34; Patterns When you need a string to conform to a regular expression, you can use the Pattern type expression. The expression Pattern(\u0026lt;regex\u0026gt;) will define a string that validates its content according to \u0026lt;regex\u0026gt; which must be a quoted Scala regular expression. If assignment to the string does not match the\u0026lt;regex\u0026gt; then an InvalidateEstateException will be generated. For example, here\u0026rsquo;s a pattern for extracting the three components of a North American telephone number:\ntype NATelephoneNumber = pattern(\u0026#34;\\(?([0-9]{3})\\)?-?([0-9]{3})-?([0-9]{4})\u0026#34;) Range The predefined types allow the use of unbounded integers but when you want to constrict the range of values, you need a Range type expression. The expression Range(\u0026lt;min\u0026gt;,\u0026lt;max\u0026gt;) will define an integer value whose range is restricted to the \u0026lt;min\u0026gt; and \u0026lt;max\u0026gt; values provided. As with [bounded strings](#Bounded Strings), the \u0026lt;min\u0026gt; and \u0026lt;max\u0026gt; values are optional and default to 0 and infinity respectively. For example:\ntype Percent = range(,100) // only value 0 to 100 inclusive Restricted Scheme URL The predefined types allow the use of any URL, but when you want to restrict the URL to a specific scheme (e.g. \u0026ldquo;http\u0026rdquo;, \u0026ldquo;mailto\u0026rdquo;) then you can use the URL type expression. The expression URL(\u0026lt;scheme\u0026gt;) specifies a URL that is restricted to the \u0026lt;scheme\u0026gt; specified. For example:\ntype HTTPS_URL = url(\u0026#34;https\u0026#34;) Unique Identifier To define a type that uniquely identifies a runtime entity the Id type expression can be used. It requires a pathIdentifier parameter which specifies the full path (from the root domain) to the runtime entity. For example:\ntype ModelXRef = Id(Autos.Tesla.ModelX) "},{"id":64,"href":"/language/common/expressions/","title":"Expressions","parent":"Common","content":"RIDDL allows expressions to be specified in various places. Most frequently they are the operands to message constructors and when clauses in Gherkin examples. This page shows you what you can do with expressions in RIDDL.\nExpressions Expressions compute values of arbitrary types. Since RIDDL is not a programming language, the syntax used for expressions is minimal and abstract. There is no attempt in RIDDL to be computationally complete. Supporting expression is merely for the convenience to requirements writers.\nConditional Expressions Conditional expressions, or just conditionals, are expressions that can only evaluate to a boolean value. These are used in places where a conditional value is expected, like in a when clause in a Gherkin example. While any expression value can be considered a conditional, there are several operators (or, and, not and the six comparison operators) that will only yield a conditional value. Arithmetic operators are not considered conditional expression. Function call, field selection, and arbitrary expressions are considered conditionals.\nLISP Style Prefix Syntax RIDDL expressions uses prefix syntax. That is the name of each operator comes first (prefix) and its arguments follow within parentheses and comma separated. For example:\nsqrt(+(4,*(3,@MyState.numberField))) This expression says multiply 3 by the value of \u0026ldquo;MyState.numberField\u0026rdquo; (presumably a numeric field in the state named \u0026ldquo;MyState\u0026rdquo;), add 4 to that, then take the square root of that sum. Note that \u0026ldquo;sqrt\u0026rdquo;, \u0026ldquo;+\u0026rdquo; and \u0026ldquo;*\u0026rdquo; and \u0026ldquo;@\u0026rdquo; are all operators. In the case of @, no parentheses are required.\nOperators In the subsections below we will discuss each of the operators that are defined by RIDDL.\nUndefined Expression: ??? If you don\u0026rsquo;t know what expression is needed, just use RIDDL\u0026rsquo;s undefined operator, which is ???. This can be considered a placeholder for future definition.\nArbitrary Expression: \u0026ldquo;expression\u0026rdquo; RIDDL allows an arbitrary expression which is just a quoted string. When you don\u0026rsquo;t have time, inclination or the details of a computation, just describe it in text. For example:\nexample Foo { when \u0026#34;conditions are right\u0026#34; then set State.Field to \u0026#34;the correct value\u0026#34; } In this example, two \u0026ldquo;arbitrary\u0026rdquo; expressions are used:\nconditions are right presumably resolves to a conditional (boolean) value \u0026quot;the correct valuepresumably resolves to a value compatible with the type of the fieldState.Field` Value Selection: @ The @ operator selects the value of a named thing in the RIDDL definition. The @ is followed immediately by a path identifier such as Domain.Context. Entity.State.Field. The path identifier chosen must specify something that holds a value, for example the fields in a state definition or the message of an on clause (in a handler).\nArithmetic: +, -, / *, %, name Arithmetic values perform computations. The usual five arithmetic operators, + - / * % are permitted and they each take two arguments. Additionally, any function name in all lower case, with 0 or more arguments can be used. The function name is not checked except that it must be in all lower case. For example, sqrt(n), log(n), empty(@list) are all valid expressions.\nFunction Call: Path.To.Function(arg1=expression,\u0026hellip;) An expression may invoke a RIDDL defined function to obtain the expression\u0026rsquo;s value. To make such an invocation, a path identifier is used to locate the function to be invoked and each of its arguments must be supplied between parentheses. Arguments in a function call must be named, unlke in an arbitrary arithmetic operator. For example:\nfunction A { requires { i: Integer} yields { j: Integer } A(i=3) This invokes function A with the required value 3 for \u0026ldquo;i\u0026rdquo; parameter\nComparison Condition: \u0026lt;, \u0026lt;=, ==, !=, \u0026gt;=, \u0026gt; The typical six comparison operators are supported. Each takes two operaonds only and compares them in different ways. The result is a conditional, true or false, depending on how the two values compare. The operators are:\n\u0026lsquo;\u0026lt;\u0026rsquo; - return true if operand 1 is less than operand 2 \u0026lsquo;\u0026lt;=\u0026rsquo; - return true if operand 1 is less than or equal to operand 2 \u0026lsquo;==\u0026rsquo; - return true if operand 1 is equal to operand 2 \u0026lsquo;!=\u0026rsquo; - return true if operand 1 is not equal to operand 2 \u0026lsquo;\u0026gt;=\u0026rsquo; - return true if operand 1 is greater than or equal to operand 2 \u0026lsquo;\u0026gt;\u0026rsquo; - return true if operand 1 is greater than operand 2 Logical: not, or, xor, and Conditional expressions can be combined with the three logical operators:\nnot - evaluates to the opposite of its operand, e.g. if the operand is truethen not(true) yields false. Requires exactly 1 operand. or - evaluates to true if any of its operands are true. Requires a minimum of 2 operands xor - evaluates to true if only one of its operands are true and the others are all false. Requires a minimum of 2 operands. and - evaluates to true if all of its operands are true. Requires a minimum of 2 operands. Constants: True, False, Numbers Constant values such as true and false (both conditionals as well), or any real, floating point, or integer number can be interpreted as expressions too.\nTernary Expression: if(condition,then,else) A computation may include the if operator with three operands. The first operand, condition, is a conditional (true/false) expression that determines whether then, an expression, is the result (condition ==true case) or then, also an expression, is the result (condition == false case).\nGroup Expression: (expression) If if aids in clarity, you may place parentheses around an expression to group it together. With prefix operator notation, this isn\u0026rsquo;t strictly needed but is provided for convenience.\n"},{"id":65,"href":"/introduction/who-can-benefit-from-riddl/","title":"Who Can Benefit From RIDDL?","parent":"Introduction","content":"RIDDL is technology-agnostic, but not design-agnostics. It is purposefully aimed at the design of large scale, distributed systems based on reactive architecture. It allows specification of the design of a system, without regard to programming language, cloud vendor choice, or specific technology choices. Using RIDDL allows a living design to evolve through every stage of the development process and then through continuing maintenance and evolution of the system designed.\nConsequently, the people who can benefit from RIDDL are those who are building such systems that want a precise and consistent way of specifying its evolving design as a guide to all stakeholders.\n"},{"id":66,"href":"/guides/developers/","title":"Developer's Guide","parent":"Guides","content":"Developers are the technical experts that advance RIDDL\u0026rsquo;s state of the art. They develop the tooling and documentation that makes up RIDDL. Since RIDDL is an open source project, developers can be affiliated with many organizations, presumably the organizations that derive utility from RIDDL.\nDevelopers must be experts in:\nDomain Drive Design Scala Programming Lanauge Li Haoyi\u0026rsquo;s fastparse Compiler Design Functional programming concepts like folding, AST, etc. Test Driven Development Build Automation Agile Engineering Practices Checking Documentation Principles Grammar Terminals Common Domain Context Entity Root Dependencies testing Releasing RIDDL "},{"id":67,"href":"/tooling/","title":"Tooling","parent":"Index","content":"This section covers the various tools that RIDDL provides and how to build, install and use them. There is a subsection for each tool provided, as follows\nriddlc riddlc --help Download and install a release How To Build `riddlc` Using riddlc/actions/get-riddlc@main Installing `riddlc` riddlc Config File Compilation Compiling RIDDL Translation riddlc options Hugo Docs sbt-riddl Getting Ready To Go IntelliJ Plugin VSCode Plugin "},{"id":68,"href":"/tutorial/rbbq/scenario/server/","title":"Server","parent":"Reactive BBQ Case Study","content":"What is your role in the restaurant?\nI greet guests at their table, help them understand the menu and make recommendations, then take their food and drink orders. After taking their order I input it into our computer system. When the order is ready I pick it up from the kitchen or bar and deliver it to the table.\nWhen the guest is finished, I present the bill and settle at the table. At the end of the shift I pay out my cash bills to the restaurant, bundle and submit my receipts and collect my tips.\nHow do you know which prepared order from the kitchen/bar is for which table?\nOrders are input into the computer system with the table number, the prepared order is presented with a printout including the table number.\nHow do you settle a bill at the table?\nGuests can pay with cash or card.\nHow do you track how much you\u0026rsquo;ve made in tips for a shift?\nOur computer system keeps track of that for me and gives me a total at the end of the shift.\nWhat challenges do you face?\nDuring peak times things can get a little hectic. Entering orders seems to take longer when we get busy. We have a limited number of computer terminals to enter the information into, so as things slow down the other servers start to line up to enter their orders. We have asked for more terminals, but apparently they are really expensive so they won\u0026rsquo;t give us more.\nSome of us have tried going around the system and just asking the kitchen to start making something before we enter the order, but the cooks really don\u0026rsquo;t like when we do that. They say it\u0026rsquo;s too hard for them to keep track so they want us to use the computer.\nServer\u0026rsquo;s Key Details Server enters orders into the system. Server collects orders from the kitchen and delivers it to the table. Server delivers bills to the tables and collects payments. Server helps customers to understand the menu choices. Software tracks tips etc. System slows down when it\u0026rsquo;s busy. Servers bottleneck on using the computers. Kitchen doesn\u0026rsquo;t like servers working around the system. "},{"id":69,"href":"/tooling/editor-plugins/","title":"Getting Ready To Go","parent":"Tooling","content":"Plugins for popular editors are planned for common IDEs to assist authors in writing RIDDL:\nIntelliJ IDEA Plugin VS Code Plugin "},{"id":70,"href":"/tooling/riddlc/compilation/","title":"Compilation","parent":"riddlc","content":" Introduction The Riddl compiler performs several analyses which are described in this section and known collectively as compilation. Each of these analyses occurs in a compilation phase, as described in the following sections.\nLexical Analysis Riddl uses the excellent fastparse library by Li Haoyi. This phase parses the raw textual input to make sure it is syntactically correct. From that syntax, an abstract syntax tree (AST) is produced. Incorrect syntax leads to errors without further analysis.\nStructural Analysis If lexical analysis succeeds, an Abstract Syntax Tree (AST) is compiled as the internal representation of the RIDDL source input within the tools\u0026rsquo; memory. Structural Analysis succeeds when the AST is constructed without error. The\nAST represents the containment hierarchy of the input definitions.\nStyle Analysis To aid in reader comprehension, a certain way of using the RIDDL language is recommended. Optionally, the compiler can generate style warnings to indicate language specifications that deviate from that recommended style.\nSemantic Analysis The Riddl AST is very flexible. It can accept a wide range of input, even input that doesn\u0026rsquo;t necessarily make logical sense. For example, suppose you wrote this:\nentity MyLittlePachyderm is { state is { tusk is TuskDefinition } } This defines an entity type named MyLittlePachyderm which can be used as the pattern to instantiate many entities with this form. This entity is defined with a single state value, tusk that has the type TuskDefinition. Note that there is no definition of TuskDefinition as there is for the entity, state and tusk. Consequently, we don\u0026rsquo;t know the type of the tusk field so our specification is incomplete and would fail semantic analysis.\nSemantic analysis, also known as validation, is the process of finding omissions, as described above, as well as:\nreferences to undefined things, references to existing things of the wrong type, constructs that may be confusing, definitional and logical inconsistencies and, etc. The semantic analysis phase generates messages that identify the omissions and inconsistencies in the input specification. These validity issues typically stop the compiler from proceeding with translation because using an invalid input model tends to produce output that is flawed or less than useful.\n"},{"id":71,"href":"/guides/developers/grammar/context/","title":"Context","parent":"Grammar","content":"DDD bounded contexts are represented in RIDDL with the context definition whose syntax is:\n(* RIDDL EBNF Grammar for bounded contexts *) context options = options(\u0026#34;wrapper\u0026#34; | \u0026#34;gateway\u0026#34; | \u0026#34;function\u0026#34;) context include = \u0026#34;include\u0026#34;, literalString context definitions = typedef | entity | adaptor | interaction | contextInclude context = \u0026#34;context\u0026#34;, identifier, is, open, (undefined | context options, context definitions), close, description } "},{"id":72,"href":"/language/root/domain/","title":"Domain","parent":"Root","content":"A domain is the top definitional level in RIDDL. We use the word domain in the sense of a knowledge domain; like an entire business, or some portion of it. It has nothing to do with Internet domain names. A domain is an arbitrary boundary around some subset of concepts in the universe. As with Domain Driven Design, RIDDL uses the concept of a domain to group together a set of related concepts.\nUnlike other definitions in RIDDL, domains can contain other domains. Because of this, we can organize any large, complex knowledge domain or field of study, into a hierarchical ontology. For example, consider these nested domain definitions:\ndomain Automotive { domain Cars { ??? } domain Trucks { ??? } domain Repairs { ??? } } In this example, the Cars domain is nested inside the more general Automotive domain. We would say that Cars is a subdomain of Automotive. Additionally, there are two other subdomains of Automotive: Trucks and Repairs.\nContext Entities Options State Invariants Entity Handler Function Adaptors Projections Saga Features Context Handler Story Streaming Pipes Processors Plants "},{"id":73,"href":"/language/root/domain/context/features/","title":"Features","parent":"Context","content":"A Feature is a requirement on a context. Features are specified very similarly to the Gherkin language. The same keywords are used and the style is more like RIDDL syntax. If you\u0026rsquo;re already familiar with Gherkin then an example should suffice:\nFeature \u0026#34;Guess the word\u0026#34; is { // The first example has two steps Scenario \u0026#34;Maker starts a game\u0026#34; is { When the Maker starts a game Then the Maker waits for a Breaker to join } // The second example has three steps Scenario \u0026#34;Breaker joins a game\u0026#34; is { Given the Maker has started a game with a word When the Breaker joins the Maker\u0026#39;s game Then the Breaker must guess a word knowing the length of the Maker\u0026#39;s word choice. } Scenario \u0026#34;Breaker makes a guess\u0026#34; is { Given the Maker and Breaker have joined the same game When the Breaker makes a guess And the guess is correct Then the Breaker wins the game And the game is over Else the Breaker may guess again } described by { |The word guess game is a turn-based game for two players. |The Maker makes a word for the Breaker to guess. The game |is over when the Breaker guesses the Maker\u0026#39;s word. } "},{"id":74,"href":"/language/common/includes/","title":"Includes","parent":"Common","content":"An include statement is not a RIDDL definition but an instruction to the compiler to lexically replace the include statement with the content of another file. The name of the file to include is the statement\u0026rsquo;s only parameter, like this:\ninclude \u0026#34;other-file.riddl\u0026#34; The include statement is only permitted where major definitions are expected, specifically at root level, and in the bodies of domain, context, entity, and pipe definitions.\n"},{"id":75,"href":"/future-work/openapi/","title":"OpenAPI","parent":"Future Work","content":"RIDDL can generate OpenAPI (Swagger) input to document Application Programming Interfaces\n"},{"id":76,"href":"/language/root/domain/streaming/plant/","title":"Plants","parent":"Streaming","content":"A RIDDL plant is a definition that combines pipes with processors to specify a model of how data should flow. You may define as many plants as needed but each plant is a closed system without the ability of the RIDDL model to express the sharing of data between the plants. This is done deliberately to prevent unintentional contamination of data in large models.\nJoints The purpose of a plant definition is to provide the blueprint for how a set of pipes, processors, and entities are joined together so that data may flow end-to-end. This is done by using:\nthe names and types of inlets in processors the names and types of outlets in processors the names and content types of pipes the definition of a joint to connect pipes and processors For example, consider this complete plant definition:\ndomain AnyDomain is { plant SensorMaintenance is { source GetWeatherForecast is { outlet Weather is type Forecast } described by \u0026#34;This is a source for Forecast data\u0026#34; flow GetCurrentTemperature is { inlet Weather is type Forecast outlet CurrentTemp is type Temperature } explained as \u0026#34;This is a Flow for the current temperature, when it changes\u0026#34; sink AttenuateSensor is { inlet CurrentTemp is type Temperature } explained as \u0026#34;This is a Sink for making sensor adjustments based on temperature\u0026#34; pipe WeatherForecast is { transmit type Forecast } explained as \u0026#34;Carries changes in the current weather forecast\u0026#34; pipe TemperatureChanges is { transmit type temperature } explained as \u0026#34;Carries changes in the current temperature\u0026#34; joint forecast is outlet GetWeatherForecast.Weather to pipe WeatherForecast joint temp_in is inlet GetCurrentTemperature.weather from pipe WeatherForecast joint temp_out is outlet GetCurrentTemperature.CurrentTemp to pipe TemperatureChanges joint temp_changes is inlet AttenuateSensor.CurrentTemp from pipe TemperatureChanges } explained as \u0026#34;A complete plant definition for temperature based sensor attenuation.\u0026#34; } explained as \u0026#34;Plants can only be specified in a domain definition\u0026#34; In other words, the above plant definition produces this kind of data pipeline: graph LR; subgraph GetWeatherForecast subgraph Weather:outlet end end subgraph GetCurrentTemperature subgraph Weather:inlet end subgraph CurrentTemperature:outlet end end subgraph AttenuateSensor subgraph CurrentTemperature:inlet end end Weather:outlet --\u003e|WeatherForecast| Weather:inlet CurrentTemperature:outlet --\u003e|TemperatureChange| CurrentTemperature:inlet In the diagram, the arrows represent pipes, yellow boxes represent processors and the grey boxes represent the inlet and outlet connection points.\nType Safety Plants are entirely type safe. This means the data type that a pipe transmits must match the data type of the publishing processors (outlets) and the data types of the consuming processors (inlets). When riddlc processes a plant specification, it ensures that all the inlet and outlet data types match the data types of the connected pipes.\nIn the above example, note that each inlet/outlet pair has the same type name (Weather and CurrentTemperature).\nEntities as Processors An entity may also be used as a processor under some special circumstances:\nas a source - An entity may be used as a source of events if a command handler is defined for the entity. as a sink - An entity may be used as a sink for events if a reaction handler is defined for the entity. as a flow - An entity may be used as a flow to convert commands into events Bulkheads TBD\n"},{"id":77,"href":"/guides/developers/principles/","title":"Principles","parent":"Developer's Guide","content":"RIDDL is a high level system specification language and as such must obey some principles of such languages. This page provides those principles.\n1: Declarative RIDDL is not an implementation language and does not pretend to be computationally complete. RIDDL adopts this what not how principle. Details are for software developers. The analyst or architect that writes RIDDL documents wants to only specify what the system is while abstracting away the process of constructing it. It is like city planning, not the processes of laying pipes, providing power and paving roads. The end user ought to be as comfortable reading it as the developer.\nA specification is a statement of what needs to be produced, but not how it is to be realized (implemented). RIDDL specifications are aimed at modelling large, complicated knowledge domains. A RIDDL model must be complete enough that all the parts of it are recognizable and what it will do is discernable, but without understanding how it will be produced.\nConsequently, RIDDL is a declarative specification language.\n2: Both Data And Process RIDDL models appreciate that the dichotomy between \u0026ldquo;doing\u0026rdquo; (process) and \u0026ldquo;being\u0026rdquo; (data) is false. Modern computing systems that model reality must be both in our view. Thus, strictly data-oriented specification languages nor strictly process-oriented specification languages will suffice. RIDDL must be both. While we are human beings we must also be human doings; or as Kurt Vonnegut published in \u0026ldquo;Deadeye Dick\u0026rdquo;:\nSocrates: To be is to do\nSartre: To do is to be\nSinatra: Do be do be doooo.\n3: Completeness The specification must provide the implementors all the information they need to complete the implementation of the system, and no more.\n4: Sufficiently Formal A RIDDL specification should be sufficiently formal so that it can conceivably be tested for consistency, correctness, completeness, and other desirable properties. Theriddlc compiler for RIDDL input aims to achieve exactly this, automatically.\n5: Familiar Terms The specification should discuss the system in terms that are normal and common for the users, implementors and subject-matter experts of the system. While RIDDL does introduce keywords that require some explanation (hence this documentation), one of the primary motivations for using DDD as a primary model for the language is to reinforce this principle.\n6: Rapidly Translatable The RIDDL specification language exists to reduce the burden on system architects, business analysts, and others who must manage complexity and large volumes of concepts. Without the ability to rapidly translate the specification into other useful artifacts, the language would not have high utility. RIDDL can therefore be used to produce:\nComplete documentation websites for the model specified in RIDDL Various kinds of diagrams for better visual comprehension of the model Various kinds of code artifacts to ease the software developers burden Other artifacts through extension plugins "},{"id":78,"href":"/tutorial/rbbq/restaurant/","title":"Restaurant","parent":"Example","content":"// insert https://github.com/reactific/riddl-examples/blob/main/src/riddl/ReactiveBBQ/restaurant/domain.riddl "},{"id":79,"href":"/language/root/domain/streaming/","title":"Streaming","parent":"Domain","content":"RIDDL supports the definition of complex data streaming models. There are two basic definitions involved in setting up a pipeline: a pipe, and a processor. There are several kinds of pipes and processors, and they can be combined to form entire systems of data processing known as a plant. These metaphors come from chemical processing concepts which you can visualize as something like this:\nAll you have to do is remember the 3 P\u0026rsquo;s:\nPipes - Pipes are conduits for reliably transmitting messages of a particular type of data between processors that are connected to the pipe. Processors - While pipes reliably transport data from its producers to its consumers, processors are the producers, consumers, and transformers of data. Notably, entities are processors of pipes too. Plants - Plants combine pipes and processors together with support for rich semantics so that arbitrarily complex streams can be modeled in RIDDL. "},{"id":80,"href":"/tutorial/rbbq/scenario/bartender/","title":"Bartender","parent":"Reactive BBQ Case Study","content":"What is your role in the restaurant?\nI take drink orders at the bar and entertain the guests. I mix the drinks and take them to the customers when they are ready. When the customer is done for the day I help them settle their tab.\nI also mix drink orders for the servers in the restaurant. The servers deliver those drinks. I just get them ready and leave them on a tray with the table number so the servers know where they go.\nAt the end of a shift I cash out with the restaurant and take my tips.\nWhat challenges do you face?\nSometimes drink orders will sit for a really long time. When a drink is ordered a ticket prints out at my station and I usually make it right away. But the servers get busy, or they forget to check for the order. The drink ends up sitting on the counter for a while before they are able to come and get it. This means the ice is melting and it can really ruin a good drink.\nIt would be nice if there was a way to let the server know that their order is ready. Sometimes I end up looking around and trying to signal them if the drink has been sitting for a while, but they aren\u0026rsquo;t always easy to track down because they might be busy talking to customers. It would be nice if there was some way to get someone else to deliver the drinks. I would do it, but I am not allowed to leave the bar unattended.\nBartender\u0026rsquo;s Key Details Bartender takes drink orders at the bar. Bartender prepares drinks for customers at the bar. Bartender delivers drink orders to customers at the bar. Bartender collects payments for the customers at the bar. Bartender prepares drinks for tables to be taken out be the servers. Collect tips, similar to the server. Would like a way to notify servers when something is ready. "},{"id":81,"href":"/tooling/riddlc/compilation-phases/","title":"Compiling RIDDL","parent":"riddlc","content":" Introduction The Riddl compiler (riddlc) performs several functions. These functions are organized into phases of execution which we will summarize below. Each phase generates outputs that are used as inputs for later phases.\nLexical Analysis This phase parses the raw textual input of the RIDDL sources to make sure it is syntactically correct. As the RIDDL source is analyzed an in-memory model of the RIDDL file known as an abstract syntax tree (AST) is constructed. Incorrect syntax leads to errors without further analysis. RIDDL uses the excellent fastparse library by Li Haoyi to perform this analysis. To speed up the process of further analysis and generation for specific kinds of outputs this in-memory model can be converted into a Binary Abstract Syntax Tree (BAST) file that can be persisted to disk. We will touch more on BAST outputs later.\nStructural Analysis The Riddl AST is then scanned to gather all the definitions (things with names) contained in the RIDDL source. Using these definitions a symbol table is created. Then finally, the containment hierarchy of the model defined by the AST is captured. Unless you are enhancing the RIDDL language you will likely not need to concern yourself with the symbol table. We present it here to help you understand the process of RIDDL file compilation.\nValidity Analysis The Riddl AST is very flexible. It can accept a wide range of input, even input that doesn\u0026rsquo;t make logical sense. For example, consider the following model:\ndomain ReactiveBBQ is { context Kitchen is { entity Fridge is { state FullFridge is { food: VeganCheese } } } } This little model should read pretty easily, but don\u0026rsquo;t worry if you don\u0026rsquo;t understand everything right now. This snippet is syntactically correct RIDDL source. However, if we tried to compile this source we will get an error during the validity analysis phase. Why? Inside the FullFridge state we define an attribute called food of type VeganCheese. In this model VeganCheese is not defined anywhere and it is also not recognized as a predefined type. Logically then, because we don\u0026rsquo;t know the data type of the food attribute our specification is incomplete and the riddlc compiler will fail informing you of the error.\nValidation is the process of finding all such omissions as well as:\nreferences to undefined things, references to existing things of the wrong type, constructs that may be confusing, deviations from stylistic conventions definitional inconsistencies and, etc. The validation phase generates messages that identify the omissions and inconsistencies in the input specification. These validity issues typically stop the compiler from proceeding because using an invalid input model tends to produce output that flawed and not useful.\nMaybe a last point here. The riddlc compiler will identify things that match the RIDDL grammar and are valid declarations. It cannot, however, identify things that make no sense to a human reading the specification. For example, if we were to declare an event within the model like so:\n... type WaiterSeatedByCustomer is event { ??? } ... No error would be generated. This is a syntactically valid RIDDL declaration, even though it is obvious to anybody reading the specification that the event is backwards. Customers are seated by Waiters. riddlc is not able to warn you of such inconsistencies (yet!).\nTranslation A RIDDL AST, having been successfully analyzed for structure and validity, is ready to be translated into another form, which is the point of all this bother in the first place.\nRIDDL supports translation to many forms of output. Some of these outputs\nRIDDL supports out of the box. But, it should also be noted that RIDDL translators are extensible to create nearly any output that you wish.\n"},{"id":82,"href":"/introduction/who-made-riddl-possible/","title":"Who Made RIDDL Possible?","parent":"Introduction","content":" Originator Reid Spencer Deeply experienced system architect, software developer and entrepreneur. Initiated RIDDL in 2019 and started committing changes to the repository at the end of 2021 Founder of Reactific Software LLC which was bought by Ossum Inc. in 2022 which he also founded. Contributors James Lovell The original enthusiast, co-conspirator, shaper and user of the language, etc. RIDDL wouldn\u0026rsquo;t be where it is today without James\u0026rsquo; contributions.\nKevin D\u0026rsquo;Vincenzo An early implementor of a hugo translator that inspired much of the current implementation.\nFoundational Work Bertrand Meyer For the notion of command/query separation which led to CQRS\nBjørn Erik Pedersen Creator of hugo\nDaniel Terhorst-North Creator of Gherkin\nEdward F. Moore $ Originator of the Finite State Machine\nEric Brewer {$eric-brewer} Originator of the CAP Theorem\nEric Evans Originated DDD and authored seminal books on DDD:\nDomain-Driven Design: Tackling Complexity In The Heart Of Software Domain-Driven Design References: Definitions and Pattern Summaries Hector Garcia-Molina \u0026amp; Ken Salem Creators of the Saga Pattern\nJonas Bonér Creator of Akka and many distributed system patterns\nKent Beck Creator of eXtreme Programming\nLi Haoyi Creator of fastparse used to parse RIDDL.\nRobert Kaussow Creator of the Geekdoc theme for [Hugo](http://github. com/gohugo/)\nSimon Brown Creator of the C4 Model For Software Architecture\nVaughn Vernon Author of Domain Driven Design Distilled\n"},{"id":83,"href":"/tutorial/rbbq/backoffice/","title":"Back Office","parent":"Example","content":"// insert https://github.com/reactific/riddl-examples/blob/main/src/riddl/ReactiveBBQ/backoffice/domain.riddl "},{"id":84,"href":"/language/root/domain/context/handler/","title":"Context Handler","parent":"Context","content":" This page is stale and no longer accurately reflects context handlers. Please refer to the handler concept for further clarity. ß A handler definition in a context specifies how that bounded context should handle messages sent to it.\nNote that an Entity can define a handler too, but they are different than the handlers defined in a context. See Entity Handler for more details. There are two kinds of handlers as described in the following sections. They are differentiated by the existence of a for clause in their definition. If they have for clause, then they are [Projection Handlers](#Projection Handler) ; otherwise they are [API Handlers](#API Handler)\nProjection Handler A handler that has a for projection \u0026lt;path\u0026gt; clause specifies how events should update a projection\u0026rsquo;s data set. There can only be one handler per projection defined in the context. The handler definition for a projection must be defined in the same context as the projection.\nAPI Handler When a handler definition does not have a for projection \u0026lt;path\u0026gt; clause, it specifies how to handle the messages sent to the context; in other words it allows a context to represent an arbitrary stateless application programming interface(API). This permits higher level functional gateways to summarize the behavior of entire subdomains and bounded contexts.\nAlways Stateless APIs are always stateless. Any state that needs to be saved when an API function is invoked should be done by sending commands to a persistent entity from an on clause in the handler.\nDefining Multiple Handlers API Handlers A context can define multiple API handlers. The will simply be combined to form the full API. This allows for modula definition of the API.\n"},{"id":85,"href":"/guides/developers/grammar/entity/","title":"Entity","parent":"Grammar","content":" (* RIDDL EBNF Grammar For Entity definition *) entity = entity kind, \u0026#34;entity\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;{\u0026#34;, entity options, entity definitions, \u0026#34;}\u0026#34;, description ; entity kind = [ \u0026#34;device\u0026#34; | \u0026#34;actor\u0026#34; | \u0026#34;concept\u0026#34;] ; entity options = single option | multi options ; single-option = \u0026#34;option\u0026#34;, \u0026#34;is\u0026#34;, entity option kinds; multi-option = \u0026#34;options\u0026#34;, \u0026#34;(\u0026#34;, { entity option kinds }, \u0026#34;)\u0026#34;; entity option kinds = \u0026#34;event sourced\u0026#34; | \u0026#34;value\u0026#34; | \u0026#34;aggregate\u0026#34; | \u0026#34;persistent\u0026#34; | \u0026#34;consistent\u0026#34; | \u0026#34;available\u0026#34;; entity definition = handler | feature | function | invariant | typeDef | state; entity definitions = entity definition { entity definition } ; entity state = \u0026#34;state\u0026#34;, identifier, \u0026#34;is\u0026#34;, \u0026#34;{\u0026#34;, identifier, \u0026#34;is\u0026#34;, typeExpression, \u0026#34;}\u0026#34;, description State A state is defined with the state keyword in the content of an entity using this syntax:\nstate = \u0026#34;state\u0026#34;, identifier, \u0026#34;is\u0026#34;, aggregate, description For details see the following production descriptions\n"},{"id":86,"href":"/language/root/domain/context/entity/handler/","title":"Entity Handler","parent":"Entities","content":" Concept See the handler concept page for general information about handlers.\nNote that a context can define a handlertoo, but they are different compared to the handlers defined in an entity. See Context Handler for details on them. Handlers are specified with the handler keyword and enclose a set of on clauses that specify what to do with a given event when that handler is active. There are four kinds of on clauses distinguished by the kind of message they handle (command, event, query, and reaction) as detailed in the following sections.\nCommand Handler A command handler specifies which persistent event is generated for a given command. For example:\ncommand JustDoIt is { id: Id(AnEntity), encouragement: String } event JustDidIt is { id: Id(AnEntity), encouragement: String } on command JustDoIt yields JustDidIt Event Handler An event handler specifies how an event modifies the state of the entity.\nstate State is { name: String } event NameWasUpdated is { id: Id(AnEntity), newName: String } on event NameWasUpdated { set State.name to NameWasUpdated.newName } Reaction Handler A reaction handler is used to specify how an entity converts a foreign event (from another entity) into a command for altering its own state. This is also a way to avoid corruption of the entity\u0026rsquo;s ubiquitous language by converting another bounded context\u0026rsquo;s concept into the handler\u0026rsquo;s entity\u0026rsquo;s concept.\ndomain Path is { domain To is { context Context is { event ThingThatHappened is { id: Id(Entity), whatHappened: String } } } } domain Foo { context Bar { entity Example { event ExternalThingHappened is { id: Id(Example), whatHappened: String } on event Path.To.Context.ThingThatHappened yields ExternalThingHappened } } } Notes:\nPath.To.Context.ThingThatHappend is known as a path identifier. Query Handler A query handler associates a query message to the result message that the query returns along with the SQL statement that yields the result set.\ntype JustGetIt = query { id: Id(AnEntity) } type JustGotIt = response { id: Id(AnEntity), count: Integer } on query JustGetIt { then return JustGotIt from \u0026#34;SELECT id, count FROM AnEntity WHERE id = %id\u0026#34; Defining Multiple Handlers An entity can make use of multiple handlers so that the behavior of an entity can be changed. There can be only one handler active at any moment, but an entity can change which handler is active for future messages in response to any message. This ability permits a set of handlers to model a finite state machine where each handler is a state and each on clause is a transition. When a handler is active, any messages received that are not explicitly defined by the handler will simply be ignored.\n"},{"id":87,"href":"/language/common/functions/","title":"Functions","parent":"Common","content":" Introduction Functions are pieces of processing that can be defined in various places as a shorthand for often repeated processing steps. A function has a set of inputs (its requirements) and a set of output (what it yields). Functions need not be pure and often have side effects through the state changes of an entity.\nExample Here\u0026rsquo;s an example of a function, named riddle, that requires a Subject(String) type and returns a Riddle (String) type. Presumably, it generates a riddle in any subject.\ntype Subject = String type Riddle = String function riddle is { requires {s: Subject} yields { r: Riddle } } Applicability Functions have applicability across several RIDDL definitions:\nContext APIs - Contexts can define functions for use within their API handler. Handler - As utilities in a handler to encapsulate repeating logic from an on clause Allow internal entity processing to be specified as part of an interaction etc. Further Content: TBD "},{"id":88,"href":"/guides/developers/grammar/","title":"Grammar","parent":"Developer's Guide","content":"This section defines the RIDDL language\u0026rsquo;s grammar formally.\nExtended Backus-Naur Form When RIDDL grammar definitions are shown, we use the EBNF grammar meta-language to specify the grammar. You can read about this grammar meta-language on Wikipedia\nFor example, here\u0026rsquo;s how EBNF can define a quoted string:\nall characters = ? any utf-8 character ? ; quoted string = \u0026#39;\u0026#34;\u0026#39;, { all characters - \u0026#39;\u0026#34;\u0026#39; }, \u0026#39;\u0026#34;\u0026#39;; This form can be quite technical and is intended for those who are familiar with EBNF format and lexical parsing. For a more descriptive introduction to the language, please refer to the Guides section.\nThe RIDDL syntax grammar is broken down into the following portions:\nterminals - Terminal symbols used in the grammar common - Common grammar productions used in other files root - Top level root level (\u0026ldquo;file scope\u0026rdquo;). domain - Defining domains context - Defining contexts entity - Defining entities "},{"id":89,"href":"/future-work/kalix/","title":"Kalix","parent":"Future Work","content":"The Kalix platform-as-a-service system represents one of the easiest methods by which RIDDL models can be turned into running systems. The riddlc program generates Kalix style protobuffers files from the RIDDL model. Kalix uses these files to generate Scala, Java, Javascript or Python code with a fill-in-the-blanks style for just the business logic.\n"},{"id":90,"href":"/tooling/riddlc/translation/","title":"Translation","parent":"riddlc","content":"The RIDDL compiler, riddlc is able to translate RIDDL into a variety of other document types, after the input passes the compilation phases.\nThe various kinds of output from riddlc are described in the following sections:\nHugo - Hugo source input for producing an HTML website where diagrams are all automatically deduced from the RIDDL model It is recommended that you become familiar with the riddlccommand line and configuration options as these control the kind of output generated. "},{"id":91,"href":"/language/root/domain/context/entity/functions/","title":"Function","parent":"Entities","content":"TBD\n"},{"id":92,"href":"/tutorial/rbbq/scenario/chef/","title":"Chef","parent":"Reactive BBQ Case Study","content":"What is your role in the restaurant?\nI oversee the entire kitchen and all of its staff. I source local ingredients required to prepare our menu items. The menu is decided on monthly and distributed via email. I inspect all prepared orders that leave the kitchen.\nWhat challenges do you face?\nI think the worst thing is when the system that prints our orders goes haywire. Sometimes the system crashes and orders get lost. While it is down we don\u0026rsquo;t know what needs to be made. The servers have to resort to handwritten tickets and it\u0026rsquo;s sometimes difficult to read their writing. Some of it is really just gibberish. It results in a lot of orders getting missed or getting made improperly.\nThe servers complain a lot about the system being slow, but we don\u0026rsquo;t really see that in the kitchen. Once they enter an order it usually prints out right away as long as the system is working.\nChef\u0026rsquo;s Key Details Chef sources local ingredients for the menu. Chef inspects all orders that leave the kitchen. Orders get lost when the system fails. Handwritten tickets are a pain. "},{"id":93,"href":"/future-work/akka/","title":"Akka","parent":"Future Work","content":"The goal of the Akka translator is to generate all the infrastructure code needed to support the domain(s) defined in the RIDDL input. While this does produce a working system, it also relieves developers of much of the repetitive, detail oriented infrastructure that is relatively boring compared to the business logic of the system.\nThis translator recognizes that its output will be co-mingled with the business logic output that developers are writing and keeps them separate. When an expected developer file does not exist, it will create it, but otherwise uses Scala inheritance, or other mechanisms, to indicate the portions that ought to be written.\nOutput File Types The Akka translator doesn\u0026rsquo;t just generate Scala code. It aims to generate complete projects that should be familiar to those famliar with Scala and Akka projects. This means generating a mixture of file types, as described in the following sections\nsbt build files build.sbt project/xxx.scala project/build.properties project/plugins.sbt\nprotobuffers definitions Specifically processed by akka-grpc (via scalapb via protoc plugins)\nScala code Build Time Dependencies sbt 1.6 or later sbt-riddl plugin akka-grpc sbt plugin buildinfo sbt plugin Runtime Dependencies Akka 2.6.17 (or later) including streams, http, cluster, persistence, \u0026hellip; Alpakka 3.x Kafka Comparison To Akka Serverless The Akka Translator has an objective to support both the advanced Akka Scala developer and less knowledgeable developers. It does that by using Scala\u0026rsquo;s abstraction features but without completely disconnecting from Akka\u0026rsquo;s powerful features. For example:\nActors are used, but in a fill-in-the-blank way. Advanced programmers can still do more complicated things, neophytes will find it easy. Does not use GRPC as the interface like Akka Serveless does. Scala is the interface and there is no side-car aspect in the runtime. "},{"id":94,"href":"/tutorial/rbbq/corporate/","title":"Corporate","parent":"Example","content":"// insert https://github.com/reactific/riddl-examples/blob/main/src/riddl/ReactiveBBQ/corporate/domain.riddl "},{"id":95,"href":"/language/common/imports/","title":"Imports","parent":"Common","content":" This feature is not implemented yet.\nAn import statement may be used to import a definition from a BAST file that was generated from a prior compilation. Import statements help to save time when a prior compilation has completed and been saved as a BAST file.\n"},{"id":96,"href":"/tutorial/rbbq/","title":"Example","parent":"Tutorial","content":"Some people can learn RIDDL faster by looking at examples than by reading the informal definitions in the language guide or the formal definitions in the grammar section. To support that mode of learning, this section decomposes the domain of a restaurant, Reactive BBQ.\nThis section provides some examples of how RIDDL can be used.\nAbout Reactive BBQ The Reactive BBQ domain is a familiar one for those who have taken the\nLightbend Reactive Architecture Professional (LRA-P) course which uses this example throughout the course to good effect in the workshops. The same premises apply in this domain, but we have chosen to fully specify it in RIDDL.\nAs you might guess from the name, Reactive BBQ is a restaurant chain that serves spicy (reactive!) BBQ dishes. It doesn\u0026rsquo;t exist of course, even if some people may or may not have mistaken R\u0026amp;R BBQ in Salt Lake City for the Reactive version in 2018.\nThe Reactive BBQ case study in the LRA-P course included interviews with several fictitious employees. [Those interviews and the case study material have been replicated in this scenario description with thanks to Lightbend; and we recommend that you read that scenario first.\nThe RIDDL files for Reactive BBQ are arranged into a directory structure, each with an explanation page as follows:\nReactive BBQ Domain Restaurant BackOffice Corporate "},{"id":97,"href":"/tutorial/rbbq/scenario/cook/","title":"Cook","parent":"Reactive BBQ Case Study","content":"What is your role in the restaurant?\nDepending on the day, I work at different stations in the kitchen. The chef tells me where I will be working for that day. I prepare orders according to the tickets that get printed out at my station. Once an order is ready, I take it over to a station where we gather all the pieces of that order. The chef then approves it and we notifiy the server that their order is ready.\nWhat challenges do you face?\nHandwritten tickets. Man do I hate those things. We have this one server that writes in this horrible chicken scratch. Every time he brings me these tickets, I have to get her to explain to me what she has written. It\u0026rsquo;s just awful.\nThen there is the server\u0026rsquo;s attitudes. It\u0026rsquo;s pretty good most of the time, but when things get busy they start to get really annoying. When they get frustrated they kind of take it out on us in the kitchen. They start yelling about their orders taking too long. I try to explain to them that there are other orders that came first and I have to do them before I can get to theirs, but it doesn\u0026rsquo;t help. They end up storming off. I hear them talking sometimes like it\u0026rsquo;s our fault somehow.\nCook\u0026rsquo;s Key Details Printed Ticket provide details on orders to be prepared. Handwritten tickets are a pain. Servers are frustrated. "},{"id":98,"href":"/introduction/how-can-i-get-help/","title":"How Can I Get Help?","parent":"Introduction","content":"Here are some options for getting help. Pick the item below that best fits your needs:\nI Need A Bug Fixed I Need RIDDL To Generate Something Else I Want To Make A Feature Suggestion I Need Commercial Support I Just Want To Chat With Someone About RIDDL I Need A Bug Fixed While RIDDL is competent enough to be used for a production software project, we still consider it to be in a pre-release, early preview stage. Consequently, we are very eager to perfect it and your bug submission will help with that.\nPlease submit your bug via GitHub at this location. In the comment area, please ensure you do the following:\nProvide the release version that the riddlc version command puts out. Provide a clear statement of the symptom of the bug. Provide a minimal reproduction case. Usually that involves providing as small a sample of RIDDL source code as possible that makes the symptom happen. This will be added to RIDDL\u0026rsquo;s regression test suite. NOTE: If we can\u0026rsquo;t reproduce the symptom, we cannot provide a fix to it. Label your new issue with the \u0026ldquo;Bug\u0026rdquo; (red) label, so we are sure to prioritize it. I Need RIDDL To Generate Something Else These kinds of requests are very important to us. We are very interested in creating a set of useful RIDDL translators for many kinds of purposes. For these kinds of feature request, please bypass GitHub and reach out directly to [Reid Spencer](/introduction/who-made-riddl-possible/#reid-spencer at reid@ossum.biz\nI Want To Make A Feature Suggestion There are many things we want to do with RIDDL, some of them are documented on the future work page. You can also find a list of new features already requested by clicking here\nWe would appreciate help with implementing new features and suggest that you clone the repository and submit a pull request.\nIf your feature suggestion is not already recorded, and you\u0026rsquo;re unable to implement the feature yourself, please submit your feature suggestion via GitHub at this location. Please ensure you do the following:\nProvide a clear statement of the feature you are suggesting we implement. Be as detailed as you can. We can handle it! :) Label your new issue with the \u0026ldquo;Enhancement\u0026rdquo; (mint green) label and any other label that helps categorize it (except \u0026ldquo;Bug\u0026rdquo;). I Need Commercial Support Commercial support is available by sending an email describing your needs to [Reid Spencer](/introduction/who-made-riddl-possible/#reid-spencer at reid@ossum.biz. Reid will reflect upon your request and suggest a time to have a Zoom conference call to discuss further.\nI Just Want To Chat With Someone About RIDDL You can use the Discussions feature on GitHub\n"},{"id":99,"href":"/future-work/others/","title":"Other Translators","parent":"Future Work","content":""},{"id":100,"href":"/tutorial/","title":"Tutorial","parent":"Index","content":"Some people can learn RIDDL faster by looking at examples than they can by reading the informal definitions in the language guide or the formal definitions in the grammar section. To support that mode of learning, this tutorial decomposes the domain of a fictitious restaurant, The Reactive BBQ.\nAs you will see, the Reactive BBQ is an expansive domain. As such, this tutorial will not attempt to have you specify the entire domain. Rather, we will work through each feature of the RIDDL language by considering examples from inside the Reactive BBQ domain. We have fully specified it so that you have a concrete reference implementation and the companion language references to guide you. You can find the fully implemented Reactive BBQ RIDDL specification here. The language reference can be found here.\nRead more here\n"},{"id":101,"href":"/tutorial/rbbq/scenario/deliverydriver/","title":"Delivery Driver","parent":"Reactive BBQ Case Study","content":"What is your role in the restaurant?\nI deliver for five locations around the city. We don\u0026rsquo;t get a lot of deliveries. We aren\u0026rsquo;t a pizza place after all. but our wings and ribs are popular delivery options. I am on call for each of the delivery locations. If one of them gets a delivery, I get a notification on my phone. I go pick up the food from the location nearest the customer. Then I drive to the customer, and deliver their food. I collect their payment if necessary. Sometimes they pay online. In that case I don\u0026rsquo;t have to do much, just drop off the food.\nWhat challenges do you face?\nYou mean other than traffic and customers annoyed with the delivery times? I think the app they give me is probably my biggest headache. I have this app on my phone. When I get a delivery it notifies me. It gives me all the details about the order and the customer. I also have a dongle that I attach to my phone that allow me to collect credit/debit payments.\nThe problem is that sometimes it doesn\u0026rsquo;t work. I will be on the way to a customer site when suddenly it just stops. I get some error like \u0026ldquo;unable to communicate with server\u0026rdquo; or something. When that happens I lose everything. I don\u0026rsquo;t have access to the customer address or their order. Thankfully they always print that information out on the bill before the delivery so I can still use that. But then when I go to collect the payment I end up having to use one of those old credit card swipe machines. The manual ones that take an imprint of the card. That doesn\u0026rsquo;t work if the customer planned to pay with debit though. In those cases I am out of luck.\nApparently they are going to start offering customer loyalty cards as well. They tell me that those will go through the same app. That just sounds like more headache. So now when the system goes down I am going to have to write down the customer\u0026rsquo;s loyalty number, and then enter it when manually when the system comes back up.\nDelivery Driver\u0026rsquo;s Key Details Driver gets notifications through the app on their phone. Driver picks up orders and delivers them to the customer. Driver collects payments. Workarounds for unreliable software in the form of printed receipts. "},{"id":102,"href":"/guides/developers/dependencies/","title":"Dependencies","parent":"Developer's Guide","content":" Dependencies The riddl code base targets Java 17 and Scala 2.13.7 with -XSource:3 in preparation for Scala 3.0 code conversion. Moving to Scala 3 requires all dependencies to make the same transition:\nfastparse uses macros and is waiting for bugs in scala 3 to be fixed pureconfig is nearly ready for scala 3 "},{"id":103,"href":"/language/common/options/","title":"Options","parent":"Common","content":"Many definitions can have options. These are hints or processing instructions to the various translator tools.\nneed more detail "},{"id":104,"href":"/tutorial/rbbq/scenario/onlinecustomer/","title":"Online Customer","parent":"Reactive BBQ Case Study","content":"Describe how you place an order online with Reactive BBQ\nWell, I go to the website and they have their menu there. I have a look at the menu and decide what I want. The menu is organized into different sections, like lunch, dinner, appetizers, dessert, that sort of thing. The menu online isn\u0026rsquo;t identical to what I get in the restaurant, but it\u0026rsquo;s pretty close. I have also done it through the phone app they have.\nAs I find things that I want, I add them to my order. Then when I have everything I want, I checkout.\nTo checkout I have to give them some information, like the delivery address, my phone number, that sort of thing. I also have to give them my credit card information so that I can pay for it. I order pretty often though, so they have all of that stuff on file already. I just enter my username and password. Once that is done, I finish the order and then I have to wait.\nAnd what happens when your food is delivered?\nThe driver brings the food to the door. They hand me the food. I usually pay online. I love that when they come to the door, I don\u0026rsquo;t have to give them money. I can enter a tip online too so that I don\u0026rsquo;t have to give them anything, but it always feels a bit weird to tip them when they haven\u0026rsquo;t delivered the food yet. If I have cash I will often pay for the food online but then give them the tip in person. I live pretty far away and it\u0026rsquo;s a bit of a drive for them, so I usually tip them pretty well. I like to see their smile when I give it to them in person.\nDo you ever order pickup?\nSometimes. I order pickup once in a while and just grab it on my way home from work. I can still order online so I usually do that, and then I just choose pickup instead of delivery. Sometimes, if I am away from my computer, I will just phone them and order something instead.\nDo you ever have trouble ordering online?\nSometimes. Their website and app aren\u0026rsquo;t always working. Or if it is working it can be really slow. I don\u0026rsquo;t mind waiting when it\u0026rsquo;s slow, unless I am in a hurry or really hungry. But when it doesn\u0026rsquo;t work at all, I usually just don\u0026rsquo;t bother. When that happens I will usually just order from the other place down the street. The food isn\u0026rsquo;t as good, and their website is kind of hard to use, but it gets the job done in a pinch.\nHave you ever used the online reservation system?\nI have used it once or twice. I usually eat at home so I don\u0026rsquo;t use it that often. But it has been okay when I have used it. I don\u0026rsquo;t get to pick specific tables or anything. I just give them a few details about what I want, like how many people, whether I want a booth, that sort of thing.\nOnline Customer\u0026rsquo;s Key Details Customer adds menu items to their order through the website/app. Customer checks out when they have completed their order. Customer enters delivery or pickup information. Customer authorizes payment and tip through the website/app. Customer makes reservations through the website/app. Website/app doesn\u0026rsquo;t always work, forcing customer to go elsewhere. "},{"id":105,"href":"/future-work/","title":"Future Work","parent":"Index","content":"This section provides some insight into our plans to extend RIDDL or use it in novel ways:\nAkka source generation\nKubernetes deployment descriptors\nProtobuffers message and service definitions\nFast data message streaming infrastructure\nAnalyses - Produce analytical data structures from the AST for use by translators.\nBAST - Binary Abstract Syntax Tree. Generates files that capture the abstract syntax tree (AST) in a transportable binary format\nDiagrams - Data flow, sequence, entity, context maps, and others\nOpenAPI - OpenAPI (formerly called Swagger) specifications for APIs implied in the RIDDL model\nKalix - Kalix protobuffers source generation as input to the Kalix code generator.\nAkka - Akka, protobuffers, Alpakka infrastructure code \u0026amp; skeleton\nOthers - plugins can be written to convert the AST into any other kind of needed data\nGoals This project is currently nascent. It doesn\u0026rsquo;t do anything yet, but eventually we hope it will do all the following things:\nFrom old README \u0026hellip; Generate Kalix Protobuffers Generate Swagger (OpenAPI) YAML files containing API documentation for REST APIs Generate Akka Serverless based microservices to implement bounded contexts Generate Akka/HTTP server stubs Generate Akka/HTTP client library Generate Kafka server stubs Generate Kafka client library Generate graphQL based on domain model Supporting a SaaS system for the generation of the above items working something like https://www.websequencediagrams.com/ by allowing direct typing and immediate feedback Serve as the de facto (or real) standard for defining business domains and reactive systems. Be designed to be used with event storming Designed for a fully reactive implementation with messaging between contexts Support pluggable code generators for targeting different execution environments. Potential executors: Akka Data Pipelines, Akka Serverless, Akka/Scala Incorporate the best interface language ideas from CORBA, Reactive Architecture, DDD, REST, DCOM, gRPC, etc. Support for Read Projections and Read Models (plugins for databases) Support for graphQL and gRPC "},{"id":106,"href":"/guides/developers/grammar/root/","title":"Root","parent":"Grammar","content":" (* RIDDL Grammar For Root - TBD *) root = domain | domain include TBD\n"},{"id":107,"href":"/guides/developers/testing/","title":"testing","parent":"Developer's Guide","content":" Ways To Test RIDDL ScalaTest There are many test points already defined in language/src/tests/scala using ScalaTest. In general, any change in language should be done in TDD style with tests cases written before code to make that test case pass. This is how the parser and validator were created. That tradition needs to continue.\n\u0026ldquo;Check\u0026rdquo; Tests In language/src/test/input there are a variety of tests with .check files that have the same basename as the .riddl file. The .check files have the error output that is expected from validating the correctly parsing . riddl file. This way we can identify changes in error and messages. These tests are performed by the CheckMessagesTest.scala test suite which will read all the riddl files in test/input/check and check them for validity and compare the output messages to what\u0026rsquo;s in the .check file. If there is no corresponding .check file then the .riddl file is expected to validate cleanly with no errors and no warnings.\nThis is where most regression tests should be added. The input should be whittled down to the smallest set of definitions that cause a problem to occur, and then it should succeed after the regression is fixed.\n\u0026ldquo;Examples\u0026rdquo; Tests In examples/src/test/scala there is a CheckExamplesSpec.scala which runs the parser and validator on the examples in examples/src/riddl. Each sub-directory there is a separate example. They are expected to parse and validate cleanly without issue\n"},{"id":108,"href":"/privacy-policy/","title":"Privacy Policy","parent":"Index","content":" Static Web Site This site, https://riddl.tech/ is static. It does not use cookies, has no ability to collect your information, and does not invade your privacy. This site is merely for documentation that you may read without security concerns.\n"},{"id":109,"href":"/guides/developers/releasing/","title":"Releasing RIDDL","parent":"Developer's Guide","content":"This is a \u0026ldquo;how to\u0026rdquo; guide on releasing the software.\nBuild \u0026amp; Test Make sure everything tests correctly from a clean start.\n\u0026gt; cd riddl # top level directory of repository \u0026gt; sbt \u0026#34;clean ; test ; test ; test\u0026#34; ... [info] All tests passed. If all tests do not pass, stop and fix the software. Note that the tests are run three times quickly. This tends to expose parallelism issues.\nStage \u0026gt; sbt stage ... [info] Main Scala API documentation successful. [success] Total time: 29 s, completed Sep 5, 2022, 12:05:58 PM If this task does not successfully complete, stop and fix the documentation which is likely to be references to Scala classes in the docs between [[ and ]]\nTest On A Major Project Now that riddlc is staged, run the hugo command on a large multi-file specification such as the Improving App. This will expose any language change issues. If this doesn\u0026rsquo;t pass, go back and fix the software again and start from scratch. The test case named RunRiddlcOnArbitraryTest will do this for you if you clone that repo and adjust the paths in that test case for your clone. Don\u0026rsquo;t commit that change.\nCommit Changes You\u0026rsquo;ve probably made changes as a result of the above. Commit those to a branch (except the change to RunRiddlcOnArbitraryTest) and push it to GitHub (origin)\nMake a Pull Request Use the branch you just created on GitHub to make a pull request and wait for the workflow(s) to complete. If it does not pass all workflows, resolve those issues and start this releasing process from the beginning. If it does pass the workflows, merge it to main branch\nCheck Out Main branch git checkout main Make sure there are no changes in your working tree. One way to do this is to\nget status If that says:\nOn branch main Your branch is up to date with \u0026#39;origin/main\u0026#39; nothing to commit, working tree clean then you\u0026rsquo;re okay to proceed; otherwise, fix the issues and restart this releasing process.\nPick a Version Number We are trying to follow semantic versioning rules for RIDDL. Use GitHub\u0026rsquo;s features to assess what has changed in the version you are releasing. If the language has changed syntax or semantics you must increase the major version number. Try to batch such changes.\nPick a version number, x.y.z, based on current tagged version and the nature of the changes and the semver.org rules.\nSet Version Now that:\nyou\u0026rsquo;ve got things working, all your code changes are committed and pushed, you\u0026rsquo;ve got a clean working tree on the main branch, you\u0026rsquo;ve picked a version number it is time to\nFormulate a short description string for the release Run this: \u0026gt; git tag -a ${x.y.z} -m \u0026#34;${release description}\u0026#34; \u0026gt; sbt show version # confirm it is the version you just set \u0026gt; git push --tags Release To Maven First, publish the artifacts to oss.sonatype.org % cd riddl % sbt publishSigned When that is complete, log in to Sonatype OSS Repo Check the staged artifacts for sanity. All modules should be published with the same release number Close the repository and add the release number in the notes Press the Release button to publish to maven central Build Release Artifacts % sbt \u0026gt; project riddlc \u0026gt; Universal/packageBin \u0026gt; Universal/packageOsxDmg \u0026gt; graalvm-native-image:packageBin \u0026gt; Create Release On GitHub open https://github.com/reactific/riddl/releases/new pick the tag that you just made write the release notes Upload Artifacts Click the area on github new release page that says: Attach binaries by dropping them here or selecting them.\nAttach these files: riddl/riddlc/target/universal/riddlc-${x.y.z}.zip riddl/riddlc/target/universal/riddlc-${x.y.z}.dmg Update riddl-actions Open https://github.com/reactific/riddl/edit/main/actions/get-riddlc/action.yaml Scroll to the bottom of the page Update the version number value set in the version variable to the ${x.y.z} version you released above. Commit, push, merge. The change to this file does not need to be included in the release tag. Always do this last because other projects are dependent on this action and the action is dependent on the uploaded artifacts.\n"},{"id":110,"href":"/guides/authors/syntaxreference/","title":"Syntax Reference","parent":"Author's Guide","content":"TBD\n"},{"id":111,"href":"/guides/authors/syntaxcheatsheet/","title":"Syntax Cheat Sheet","parent":"Author's Guide","content":"TBD\n"},{"id":112,"href":"/guides/developers/checking-documentation/","title":"Checking Documentation","parent":"Developer's Guide","content":"After making documentation changes, it is best to visualize those changes to check that the documentation is still generating correctly and readable.\nThis is pretty simple.\nInstall Hugo You need to make sure Hugo is installed:\nbrew install hugo Run Hugo Then run the hugo server:\ncd doc/src/hugo hugo server --disableFastRender -D The --disableFastRender means that hugo won\u0026rsquo;t cache results but read from source on each request. The -D option instructs to load all pages, even the ones marked as drafts.\nOpen Browser To view the site in your browser:\nopen http://localhost:1313/ Note that if that port is busy, hugo may use another one. It will print out the URL it used so you should just be able to click on it from your terminal window.\nContinue Editing You can continue editing while the server is running. This allows you to validate your work on the markdown files visually in the browser. Whenever you change a markdown file, Hugo will notice and reload the browser page automatically if the viewed markdown page changed.\n"},{"id":113,"href":"/concepts/action/","title":"Action","parent":"Concepts","content":"An Action is something a program does. Actions are used in the then and but clauses of an example.\nThere are many kinds of Actions, described in the table below\nName Description Append Add an item to a field that is a collection Arbitrary A textually described arbitrary action Ask Send a message to an entity, asynchronously process result Become Instructs an entity change to a new handler Compound Execute a group of nested actions Error Produce an error with a message FunctionCall Call a function to get a result Morph Morph the state of an entity to a new state Publish Publish a message to a pipe Reply Provide the reply message to the entity that invoked a query Return Return a value from a function Set Set a field of the current state of an entity Tell Send a message to an entity, do not wait for result Yield Place a message on an entity\u0026rsquo;s event pipe Applicability Not all actions can be used in every situation. The table below show the exceptions. Examples occur in handlers and they in turn occur in contexts, entities, functions, projections, and states.\nName Context Entity Function Projection State Append ⚠ ✓ ⚠ ✓ ✓ Arbitrary ✓ ✓ ✓ ✓ ✓ Ask ✓ ✓ ✓ ✓ ✓ Become ⚠ ✓ ⚠ ✓ ✓ Compound ✓ ✓ ✓ ✓ ✓ Error ✓ ✓ ✓ ✓ ✓ FunctionCall ✓ ✓ ✓ ✓ ✓ Morph ⚠ ✓ ⚠ ⚠ ✓ Publish ✓ ✓ ✓ ✓ ✓ Reply ⚠ ✓ ⚠ ✓ ✓ Return ✓ ⚠ ✓ ✓ ⚠ Set ⚠ ✓ ⚠ ✓ ✓ Tell ✓ ✓ ✓ ✓ ✓ Yield ⚠ ✓ ✓ ✓ ✓ Occurs In Examples - in the then and but clauses Contains Expressions - to "},{"id":114,"href":"/concepts/actor/","title":"Actor","parent":"Concepts","content":"An Actor is a participant in a Story. The Actor\u0026rsquo;s identifier is typically the name of a representative real user of a system and it is defined by identifying that person\u0026rsquo;s role with respect to the system.\nOccurs In Domains Contains Nothing (Leaf definition)\n"},{"id":115,"href":"/concepts/adaptor/","title":"Adaptor","parent":"Concepts","content":"An adaptor\u0026rsquo;s purpose is to adapt one Context to another Context. In Domain-Driven Design, this concept is known as an anti-corruption layer that keeps the ubiquitous language of one context \u0026ldquo;corrupting\u0026rdquo; the language of another context. The authors of RIDDL didn\u0026rsquo;t like that term for a variety of reasons so we have renamed the concept as adaptor in RIDDL. Same idea, different name.\nMessage Translation Adaptors do their work at the level of messages sent between Contexts. This is done using one or more Handlers. Each handler specifies how messages are translated into other messages and forwarded to the target context.\nTarget Context Adaptors are only definable within a containing [Context]/concepts/context/) which provides one participant of the translation. The other [Context]/concepts/context/), known as the target context, is specified within the definition of the adaptor.\nAdaptation Directionality Adaptors only translate in one direction, between the containing context and the target context. However, multiple Adaptors can be defined to achieve bidirectional adaptation between Contexts. The directionality of an Adaptor is specified in the definition of the adaptor. This leads two twoo kinds of aaptors: inbound and outbound.\nInbound Adaptors Inbound adaptors provide an adaptation that occurs from the [Context]/concepts/context/) referenced in the adaptor to the [Context]/concepts/context/) containing the adaptor.\nOutbound Adaptors Outbound adaptors provide an adaptation that occurs from the [Context]/concepts/context/) containing the Adaptor to the [Context]/concepts/context/) referenced in the adaptor.\nOccurs In Contexts Contains Authors Handlers Terms "},{"id":116,"href":"/concepts/application/","title":"Application","parent":"Concepts","content":"An application in RIDDL represents an interface portion of a system where an actor (human or machine) initiates an action on the system. Applications only define the net result of the interaction between the actor and the application. They are abstract on purpose. That is, there is nothing in RIDDL that defines how information is provided to a user nor received from a user. This gives free latitude to the user interface designer to manage the entire interaction between human and machine.\nThere are also no assumptions about the technology used for the implementation of an application. RIDDL\u0026rsquo;s notion of an application is general and abstract, but they can be implemented as any of the following:\nMobile Application On Any Platform Web Application Native Operating System Application (graphical or command line) Interactive Voice Recognition Virtual Reality with Haptics and other things yet to be invented. This means a RIDDL application specification can be used as the basis for creating multiple implementations of the specification using a variety of technologies.\nGroups Applications abstractly design a user interface by containing a set of groups. Groups can be nested which allows them to define the structure of a user interface.\nHandlers Applications have message handlers like many other RIDDL definitions. However, application handler\u0026rsquo;s only receive their messages from actors, unlike other handlers. Typically, the handling of messages in handlers will ultimately send further messages to other components, like a context or entity\nOccurs In Domain Contains Type Group Handler "},{"id":117,"href":"/concepts/element/","title":"Application Element","parent":"Concepts","content":"Elements are the definitions that define the actor interface for an application. Every element is associated with a data type for either input or output. Actors using an application are either sending information\nElement Types There is one RIDDL definition for each of the four typical categories of User Interface elements1 as shown in the table below\nUI Element RIDDL Description Input Give input of data items to fill an aggregate Input Select select item(s) from a list Output View presents a data value for consideration Navigation Activate cause the application to change its context Container Group groups elements together Activate An Activate definition instructs the application to change context to a different group of elements.\nOccurs In Applications Contains Elements Handlers See Critical UI Elements of Remarkable Interfaces\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":118,"href":"/concepts/author/","title":"Author","parent":"Concepts","content":"An author definition merely describes one of the authors that wrote the encapsulating definition. An author definition contains the usual profile information for a human including:\nfull name email address name of an organization (optional) title at that organization (optional) url for more information (optional) Occurs In All vital definitions\nContains No other definitions\n"},{"id":119,"href":"/concepts/context/","title":"Context","parent":"Concepts","content":"A context definition in RIDDL represents the notion of a bounded context from Domain Driven Design (DDD). A bounded context is an isolated portion of some knowledge domain. Consequently, in RIDDL we defined a context inside a domain. DDD uses bounded contexts to divide complexity in large knowledge domains into manageable portions. Since large knowledge domains are difficult for a single human to comprehend in its entirety, DDD uses bounded contexts as a primary structuring tool. Bounded contexts must be able to be fully comprehended by any individual person. RIDDL utilizes both of these concepts the way DDD intends.\nSince bounded contexts are also subdomains, we distinguish them from subdomains with a few characteristics as discussed below.\nAs the name suggests, a context has a finite and precise definitional boundary. That means that it can be implemented easily because there is no vagueness. A bounded context defines its boundary via a ubiquitous language that facilitates a common comprehension of the context between humans. Indeed, this is one of its primary reasons for its existence: to assist in eliminating the confusion and miscommunication of imprecisely defined concepts that human languages tend to produce, even within a single language. For example, consider the English word \u0026ldquo;order\u0026rdquo; in various contexts:\nrestaurant - a list of food items to be made and delivered to a table backoffice - a list of things to be received from a shipper politics - a state of peace, freedom from unruly behavior, and respect for law mathematics - a sequence or arrangement of successive things. sociology - a group of people united in a formal way society - a rank, class, or special group in a community or society architecture - a type of column and entablature forming the unit of a style economics - a written direction to pay money to someone military - a directive or command from a superior to a subordinate And that\u0026rsquo;s just the confusion resulting from one common business word!\nA context\u0026rsquo;s ubiquitous language arises from the named definitions it contains. The names are specific terms used with precision by the subject-matter (knowledge domain) expert. Other practitioners (designers, developers, testers) must use these terms so that the language truly is ubiquitous and everyone is on the same page.\nWhen modelling a system with RIDDL, the ubiquitous language boils down to the names of the definitions that RIDDL permits inside a context definition, as shown in the list below. You can correctly think of a contexts ubiquitous language as the interface to that knowledge domain. It is very analogous to an API (Application Programming Interface) as the interface to a program. The API\nTo further your understanding, watch this 34-minute video by /concepts/entity/ Eric Evans from DDD Europe 2020 conference\nOccurs In Domains Contains Adaptors Authors Entities Functions Handlers Includes Processors Projections Sagas Terms Types "},{"id":120,"href":"/concepts/definition/","title":"Definition","parent":"Concepts","content":"RIDDL is a declarative language, in that it declares the definition of certain concrete concepts in a hierarchical fashion. The notion of a definition is abstract since there are many types of definitions, all described in this concepts section. Succinctly, a definition is anything that has a unique name that we call its identifier.\nCommon Attributes All definitions have some common attributes:\nloc: The location of the definition in its input file. (line \u0026amp; column) id: The name, or identifier, of the definition. briefly: A string to briefly describe the definition. These are used in the documentation output and the glossary. description: A block of Markdown that fully describes the definition. All the facilities provided by the\nhugo-geekdoc template for hugo are supported. These attributes merely provide supplemental information about the definition but are not part of the definition.\nVital Definitions The vital definitions share a set of attributes that, like the Common Attributes, are informational rather than definitional.\n"},{"id":121,"href":"/concepts/description/","title":"Description","parent":"Concepts","content":"Descriptions describe definitions. You can add a description to any kind of definition. Descriptions are written in Markdown format and can include any of the capabilities provided by the GeekDoc hugo formatter including mermaid based diagrams. Descriptions can also be provided in separate files and via public (no password required) HTTP URLs.\nOccurs On Every kind of definition.\nContains Markdown text either directly in RIDDL, in a file, or via a URL.\n"},{"id":122,"href":"/concepts/domain/","title":"Domain","parent":"Concepts","content":"A domain is the top-most definitional level in RIDDL. We use the word domain in the sense of a knowledge domain; like an entire business, a field of study, or some portion of these. It has nothing to do with Internet domain names. A domain is an arbitrary boundary around some subset of concepts in the universe. As with Domain Driven Design, RIDDL uses the concept of a domain to group together a set of related concepts.\nDomains in RIDDL are inert. That is they only serve to contain definitions that do things, but they don\u0026rsquo;t do things themselves.\nDomains can recursively contain other nested domains so that a hierarchy of domains and subdomains is established. Because of this, we can organize any large, complex knowledge domain or field of study, into an hierarchical ontology.\nFor example, if you were modelling the domain of Two Wheeled Vehicles you might devise a domain hierarchy like this:\nTwo Wheeled Vehicle Motorized ICE powered motorcycles Scooter Electric Bicycles Segway UnMotorized Bicycles Oxcart Handtruck Human With Training Wheels Occurs In Root Domains - domains can be nested in a super-domain. Contains Within a domain, you can define these things:\nActors - someone or thing that uses the domain Applications - an actor interface Authors - who defined the domain Contexts - a precisely defined bounded context within the domain Domains - domains can have nested domains (subdomains) Includes - inclusion of entity content from a file Options - optional declarations about a definition Plants - a data processing plant Stories - a story about external entities interacting with the domain Terms - definition of a term relevant to the domain Types - information definitions used throughout the domain "},{"id":123,"href":"/concepts/entity/","title":"Entity","parent":"Concepts","content":"An entity in RIDDL is the same as it is in DDD which defines it this way:\nEntity Definitions\nAn object primarily defined by its identity is called an Entity.\nand\nMany objects are not fundamentally defined by their attributes, but rather by a thread of continuity and identity.\nThere are three main aspects to this definition of entity:\nEntities in the software implementation of the model are objects, containing both state and function. They can both be and do.\nThis means they can represent any physical object, a concept, etc. Entities have an identity; they are identified by some unique value that no other entity of the same type may have. Entities are continuous; they have a lifecycle, evolving from creation, through their useful lifespan, to destruction. An entity is the fundamental processor of work in a reactive system and in a RIDDL model. Entities are most often implemented in software using one of these techniques:\nusing the actor model where actors process messages and encapsulate state. object-oriented programming which also encapsulate states and defines functions to manipulate that state. functional programming where a collection of functions process messages or function calls using exclusive access to some data and a queue of messages; this simulates the actor model. Identity Entities have a unique immutable persistent identifier, much like people have names except our personal names are not unique. The unique identifier is used to locate the entity in a computing system and for other computing purposes. These immutable and unique identifiers convey equivalence. That is when two values of an identifier are the same, then by definition, they must refer to the same entity. Changing the state of the entity does not break this equivalence. Type Id, which provides the means to reference the entity in its context or between contexts. An Entity\u0026rsquo;s immutable identity conveys equivalence. Individual pieces of data of an entity can change their values (mutable).\nEquality Entities hold state, whether that state is persistent or not. However, for entities, the most important state value is the unique identifier for that entity. Consider this diagram:\nTwo instances of the same Entity may have different attribute values, but because both instances have the same identity value, they represent the same Entity. The identifier \u0026ldquo;John Smith\u0026rdquo; is used in two entities that differ in their state. By definition, this means they refer to the same entity. However, when you compare \u0026ldquo;John Smith\u0026rdquo; with \u0026ldquo;Jane Smith\u0026rdquo;, they are not the same entity, even if all their other attributes are the same.\nOptions Entities can have various optional characteristics as shown in the sections below\ntechnology Arguments: Multiple, a list of the names of technologies intended to be used in the implementation. Implication: This does not impact the behavior of the entity except in the differences provided by various implementation technologies.\nevent sourced Arguments: None Implication: The entity should use event sourcing to store its state as a log of change events\nvalue Arguments: None Implication: The entity should store only its latest value without using event sourcing. transient Arguments: None Implication: The entity should not persist its state at all and is only\navailable in transient memory. All entity values will be lost when the service is stopped. aggregate Arguments: None Implication: The entity is an aggregate root entity through which all commands and queries are sent on behalf of the aggregated entities. consistent Arguments: None Implication: The entity\u0026rsquo;s implementation should favor consistency over\navailability in Erik Brewer\u0026rsquo;s CAP theorem. available Arguments: None Implication: The entity\u0026rsquo;s implementation should favor availability over consistence in Erik Brewer\u0026rsquo;s CAP theorem. finite state machine Arguments: None Implications: The entity is intended to implement a finite state machine. message queue Arguments: None Implications: The entity should allow receipt of commands and queries via a message queue. kind Arguments: one string indicating the kind of entity Implications: The general kind of entity being defined. This option takes a single value which provides the kind of entity. Examples of useful kinds are \u0026ldquo;device\u0026rdquo;, \u0026ldquo;actor\u0026rdquo;, \u0026ldquo;concept\u0026rdquo;, \u0026ldquo;machine\u0026rdquo;. This entity option may be used by downstream AST processors, especially code generators. Downstream processors may require additional entity kind values. Occurs In Contexts Contains Authors - define who the authors of the entity are Functions - named definitions of processing Handler - how to handle messages sent to an entity Includes - inclusion of entity content from a file Invariants - logical expressions that must always hold true Options - define translation options for the entity State - the data an entity holds Types - the definition of a type of information Terms - the definition of a term related to the entity "},{"id":124,"href":"/concepts/example/","title":"Example","parent":"Concepts","content":"The concept for a RIDDL Examples is very similar to Dan North\u0026rsquo;s Gherkin Examples. Gherkin has been used for many years to specify test cases that serve as functional specifications as well. Gherkin is simple enough for anyone to understand them.\nIn RIDDL this idea is used to specify the functionality for any of the vital definitions. An Example is structured like this:\nSCENARIO identifier - provides the name of the example or scenario (optional) GIVEN condition (optional) WHEN condition (optional) THEN action ELSE action (optional) The intent here is to express how in the context of some circumstance (GIVEN), when a particular thing happens (WHEN), take some action (THEN), otherwise, in that context, if that thing does not happen take some other action (ELSE).\nSince four of those things are optional, it often just comes down to THEN.\nOccurs In Functions, Handlers, SagaSteps, Stories. Contains Actions Conditional Expressions "},{"id":125,"href":"/concepts/expression/","title":"Expression","parent":"Concepts","content":"TBD - This part of RIDDL may change significantly in the future.\nLiteral Expressions (#literal) TBD\nNumeric Expressions (#numeric) TBD\nConditions (Boolean Expressions) TBD\nOccurs In Actions Contains Nothing\n"},{"id":126,"href":"/concepts/field/","title":"Field","parent":"Concepts","content":"Fields are the unit of composition of an aggregate type, state, or projection. A field is a simple mapping of a name to a type. For example:\nname: Number\nspecifies that the field named name has type Number. Fields are most often referenced in actions and expressions to supply values over which computations are performed.\nOccurs In Types States Projections Contains Nothing\n"},{"id":127,"href":"/concepts/function/","title":"Function","parent":"Concepts","content":"A function definition provides a way to not repeat yourself in other definitions. We can define functions in several places and then use them in an expression or action. This way, we only need to define the logic for something once.\nOccurs In Contexts Entities Handlers Contains Fields Examples Functions "},{"id":128,"href":"/concepts/group/","title":"Group","parent":"Concepts","content":"A group is the abstract structuring concept for an application. Groups can be nested which allows them to form a hierarchy that defines the structure of a user interface. Each group can also contain UI elements such as inputs and outputs as well as types. To make this more tangible, groups could be used to model the following implementation concepts:\nHTML forms, pages, containers, and sections mobile application screens, pages, forms and containers accordions (vertically stacked list of items with show/hide functionality) A UI designer is free to arrange the contained elements in any fashion, but presumably in a way that is consistent with their overall UI design theme.\nOccurs In Application Group Contains Group Type Input Output "},{"id":129,"href":"/concepts/handler/","title":"Handlers","parent":"Concepts","content":"A handler is a very important definition in RIDDL because it is RIDDL\u0026rsquo;s way of expressing both business logic and relationships between the various components in a model. Handlers do that by specifying what should be done whenever a message of a particular type is received by its parent definition. Handlers are composed as a set of on clauses that connect a message with an [example]/concepts/example/. The example specifies the business logic that should be executed upon receipt of the message. Because that business logic can send and publish further messages to other component, a relationship can be inferred between the component receiving the message sent and the component that contains the handler.\nThere are several kinds of handlers depending on the handler\u0026rsquo;s containing definition, as shown in this table:\nOccurs In Handler Focus Adaptor Translate messages between [contexts](/concepts/context/ Application Handling the messages received from the user Context Implements API of the stateless context Entity Handler to use on new entity before any morph action Processor Provide ETL logic for moving inputs to outputs Projection Handle updates and queries on the projection Repository Handle updates and queries on the repository State Handle messages while entity is in that state The types of definition in which Handlers occur are known as the \u0026ldquo;active\u0026rdquo; definitions. More details are provided in the sections below.\nAdaptor Handlers Adaptor handlers provide the translation of messages from context to another.\nApplication Handlers Application handlers process the events generated by the Application\u0026rsquo;s user to invoke business logic that typically results in sending further messages to the \u0026ldquo;back end\u0026rdquo; (typically a gateway context). This allows the application to be connected to the rest of the model.\nContext Handlers Context handlers imply a stateless API for the context, perhaps encapsulating the other things defined within the context.\nEntity Handlers Entity handlers specify the default or \u0026ldquo;catch all\u0026rdquo; handler for an entity.\nWhen the entity is new, or is not in a specific state, this default handler is used to process each message. If the message is not processed by the handler, then the entity\u0026rsquo;s processing for that message is null (message ignored). When an entity is in a specified state, it processes messages defined by the handler within that state (see below).\nProjection Handler Projections provide\nState Handler State handlers process messages while an entity is in that specific state, presumably with the intent of updating that state by generating events from commands.\nOccurs In Adaptors Applications Contexts Entities Processors Projections Repositories State Contains On Clauses - a specification of how to handle an event "},{"id":130,"href":"/concepts/include/","title":"Includes","parent":"Concepts","content":"Includes permit you to include content from a file into the definition in which it occurs.\nOccurs In All vital definitions\nContains Content relevant to the definition in which it is used. The input must conform to the hierarchy shown in the index\n"},{"id":131,"href":"/concepts/inlet/","title":"Inlets","parent":"Concepts","content":"An Inlet is a component of a Processor that specifies a named input through which data of a particular type streams into the processor.\nOccurs In Processors Contains Nothing\n"},{"id":132,"href":"/concepts/input/","title":"Input","parent":"Concepts","content":"An Input is the abstract notion of some information provided to an application by its user (an actor). To make this more tangible, inputs could be implemented as any of the following:\nthe submission of a typical htML form a user could fill in, the tap of a button on a mobile device, the selection of items from a list on a native application, a voice response providing information via any IVR system, a thought interpreted by a neural link, a physical movement interpreted by a motion-detection device, a retinal scan, picking items from lists of information by looking and blinking or any other system by which a human may provide information to a machine The nature of the implementation for an input is up to the UI Designer. RIDDL\u0026rsquo;s concept of it is based on the net result: the data type received by the application.\nAn input is a named component of an application that receives data of a specific type from an\nactor (user) of the application. Each input can define data types and declares a command message as the data received by the application\u0026rsquo;s input.\nOccurs In Group Contains Type Message "},{"id":133,"href":"/concepts/invariant/","title":"Invariants","parent":"Concepts","content":"An invariant is a logical expression that must always hold true. They can be used to validate state changes in entities, or parameter values in functions.\nOccurs In Entities - specifies a rule on the state of an entity Functions - specifies a rule on the input parameters of a function Contains Nothing\n"},{"id":134,"href":"/concepts/joint/","title":"Joints","parent":"Concepts","content":"Joints join Processor Inlets or Outlets to pipes. There are two kinds of joints:\nInletJoint - connects an Inlet to a Pipe OutletJoint - connects and Outlet to a Pipe Joints are necessary to set up a pipeline in a Plant which must flow data from source to [sink](/concepts/processor/].\nOccurs In Plants Contains Nothing\n"},{"id":135,"href":"/concepts/message/","title":"Messages","parent":"Concepts","content":"Messages are a foundational concept in RIDDL because a RIDDL model implies an implementation that is a message-driven system per the Reactive Manifesto. Messages in RIDDL are a special case of an aggregate type and the lingua franca of many RIDDL definitions. They define the API for:\nadaptors\napplications\ncontexts\nentitys\n[processors](/concepts/processor/\nprojections\nand repositories\nThat is, these are the fundamental building blocks of a message-driven system\nDifferences Between Kinds of Messages RIDDL follows Bertrand Meyer\u0026rsquo;s notion of command/query separation which states, in the context of object-oriented programming in Eiffel that:\nevery method should either be a command that performs an action, or a query that returns data to the caller, but not both. In other words, asking a question should not change the answer.1\nConsequently, RIDDL adheres to this principal and employs the notion in message definitions since RIDDL is message-oriented not object-oriented. However, RIDDL also includes message types for the responses from commands and queries, events and results, respectively. The following subsections provide definitions of these four things\nCommand A directive to perform an action, likely resulting in a change to some information.\nEvent A recordable fact resulting from a change to some information.\nQuery A request for information from something\nResult A response to a query containing the information sought.\nSummary The various characteristics of the four kinds of messages are shown in the table below.\nKind Request? Response? Cancellable? Relationship Command Yes No Yes Independent Event Maybe Yes No Consequent Of Command Query Yes No Yes Independent Result No Yes No Consequent Of Result The truth table above helps you understand the relationship between the kind of message and how it is handled by a model component. The sections below get even more specific.\nHow Messages Are Handled By Adaptors Kind In Regard To Handling By Projection Command Intent To Translate For Context Event Intent To Translate For Context Query Intent to Translate For Context Result Intent to Translate For Context How Messages Are Handled By Applications Kind In Regard To Handling By Projection Command Data given from user to application Event Not Applicable Query Not Applicable Result Data provided to user from application How Messages Are Handled By Contexts Kind In Regard To Handling By Projection Command Intent To Take Some Stateless Action Event Notification That a Command Completed Query Intent to Read From The Context Result Result Of Reading From Context How Messages Are Handled By Entities Kind In Regard To Handling By Entity Command Intent To Modify Entity State Event Entity State Was Changed Query Intent To Read Entity state Result Consequent Of Query How Messages Are Handled By Processors Kind In Regard To Handling By Processor Command Intent To Update Projection State Event The Projection\u0026rsquo;s State Was Modified Query Intent to Read Projection State Result Result Of Reading Projection State How Messages Are Handled By Projections Kind In Regard To Handling By Projection Command Intent To Update Projection State Event The Projection\u0026rsquo;s State Was Modified Query Intent to Read Projection State Result Result Of Reading Projection State Occurs In All Vital Definitions\nContains Fields\nMeyer, Bertrand. \u0026ldquo;Eiffel: a language for software engineering\u0026rdquo;. p. 22\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"},{"id":136,"href":"/concepts/onclause/","title":"On Clauses","parent":"Concepts","content":"An On Clause specifies how to handle a particular kind of message as part of the definition of a [handler](/concepts/handler/. An On Clause is associated with a specific message definition and contains an example that defines the handling of that message by the handler\u0026rsquo;s parent. An On Clause is also optionally associated with an entity or pipe) as the sender of a message.\nOccurs In Handlers - the handler to which the On clause is applied Contains Examples - specifies what should happen when the event occurs "},{"id":137,"href":"/concepts/option/","title":"Options","parent":"Concepts","content":"Options are instructions to translators on how a particular definition should be regarded. Any translator can make use of any option. Options can take a list of string arguments much like the options and arguments to a program. If none are specified, the option is considered to be a Boolean value that is true if specified.\nEvery vital definition in RIDDL allows a technology option that takes any number of string arguments. These can specify the technologies intended for the implementation. This idea was adapted from a similar idea in Simon Brown\u0026rsquo;s C4 Model For Software Architecture\nOther options are specific to the kind of vital definition. See the vital definition\u0026rsquo;s page for details on the options they take. Non-vital definitions do not allow options.\nOccurs In All vital definitions\nContains Option values which are simple identifiers with an optional set of string arguments.\n"},{"id":138,"href":"/concepts/outlet/","title":"Outlets","parent":"Concepts","content":"An Outlet is a component of a Processor that specifies a named input through which data of a particular type streams out of the processor.\nOccurs In Processors Contains Nothing\n"},{"id":139,"href":"/concepts/output/","title":"Output","parent":"Concepts","content":"An Output definition is concerned with providing information to the user (an actor) without regard to the form of that information when presented to the user. To make this more tangible, an Output could be implemented as any of the following:\nthe text shown on a web page or mobile application the display of an interactive graphic, chart, etc. the presentation of a video or audio recording haptic, olfactory or gustatory feedback any other way in which a human can receive information from a machine. The nature of the implementation for an output is up to the UI Designer. RIDDL\u0026rsquo;s concept of it is based on the net result: the data type received by the user.\nAn Output is a named component of an application that sends data of a specific type from the application to its user (an actor)\nEach input can define data types and declares a result message as the data sent to the user.\nOccurs In Group Contains Type Message "},{"id":140,"href":"/concepts/pipe/","title":"Pipes","parent":"Concepts","content":"Pipes are uni-directional conduits for reliably transmitting data of a particular type. Pipes always make connections between an InletJoint (the source of data) and an OutletJoint. These joints are always attached to a processor, even possibly the same processor (making a feedback loop).\nData Transmission Type Pipes can transmit any data type that RIDDL can specify. There is only one data type that flows in a pipe. The transmission type is often used with an alternation of messages such as the commands and queries that an entity might receive.\nPipe Options Pipes may play a large role in the resiliency of a reactive system, so we permit a variety of options to be specified on them. These options are only intended as advice to the translators converting the pipe into something else. For example, a pipe may or may not need to be persistent. If a pipe has the burden of persistence removed, it is likely much more performant because the latency of storage is not involved.\npersistent The messages flowing through the pipe are persisted to stable, durable storage, so they cannot be lost even in the event of system failure or shutdown. This arranges for a kind of bulkhead in the system that retains published data despite failures on either end of the pipe\ncommitable With this option, pipes support the notion of being commitable. This means the consuming processors of a pipe\u0026rsquo;s data may commit to the pipe that they have completed their work on one or more data items. The pipe then guarantees that it will never transmit those data items to that processor again. This is helpful when the processor is starting up to know where it left off from its previous incarnation.\npartitions(n) For scale purposes, a pipe must be able to partition the data by some data value that is in each data item (a key) and assign the consumption of the data to corresponding members of a consumer group. This permits multiple instances of a consuming processor to handle the data in parallel. The n value is the minimum recommended number of partitions which defaults to 5 if not specified\nlossy By default, pipes provide the guarantee that they will deliver each data item at least once. The implementation must then arrange for data items to be idempotent so that the effect of running the event two or more times is the same as running it once. To counteract this assumption a pipe can be use the lossy option which reduces the guarantee to merely best reasonable effort, which could mean loss of data. This may increase throughput and lower overhead and is warranted in situations where data loss is not catastrophic to the system. For example, some IoT systems permit this kind of data loss because the next transmission is imminent.\nProducers \u0026amp; Consumers Attached to the ends of pipes are producers and consumers. These are processors of data and may originate, terminate or flow data through them, connecting two pipes together. Producers provide the data, consumers consume the data. Sometimes we call producers sources because they originate the data. Sometimes we call consumers sinks because they terminate the data.\ngraph LR; Producers --\u003e P{{Pipe}} --\u003e Consumers Source --\u003e P1{{Pipe 1}} --\u003e Flow --\u003e P2{{Pipe 2}} --\u003e Sink Pipes may have multiple publishers (writers of data to the pipe) and multiple consumers (readers of data from the pipe). In fact, because of the partitioned consumption principle, there can be multiple groups of consumers, each group getting each data item from the pipe.\nSubscriptions Not Implemented This feature is not implemented as of 0.16.1 When a pipe has multiple consumers, they are organized into subscriptions. Each subscription gets every datum the pipe carries. Consumers attach to a subscription and there is generally one consumer per partition of the subscription. Sometimes subscriptions are known as consumer groups as is the case for Kafka.\nOccurs In Plants Contains Nothing\n"},{"id":141,"href":"/concepts/plant/","title":"Plants","parent":"Concepts","content":"RIDDL supports the definition of complex data streaming models. There are three basic definitions involved in setting up a pipeline: a plant, a pipe, and a processor. There are several kinds of pipes and processors, and they can be combined to form entire systems of data processing known as a plant. These metaphors come from chemical processing concepts which you can visualize as something like this:\nAll you have to do is remember the 3 P\u0026rsquo;s:\nPipes - Pipes are conduits for reliably transmitting messages of a particular type of data between processors that are connected to the pipe. Processors - While pipes reliably transport data from its producers to its consumers, processors are the producers, consumers, and transformers of data. Notably, entities are processors of pipes too. Plants - Plants combine pipes and processors together with support for rich semantics so that arbitrarily complex streams can be modeled in RIDDL. A RIDDL plant is a definition that combines pipes with processors to specify a model of how data should flow. You may define as many plants as needed but each plant is a closed system without the ability of the RIDDL model to express the sharing of data between the plants. This is done deliberately to prevent unintentional contamination of data in large models.\nJoints The purpose of a plant definition is to provide the blueprint for how a set of pipes, processors, and entities are joined together so that data may flow end-to-end. This is done by using:\nthe names and types of inlets in processors the names and types of outlets in processors the names and content types of pipes the definition of a joint to connect pipes and processors Type Safety Plants are entirely type safe. This means the data type that a pipe transmits must match the data type of the publishing processors (outlets) and the data types of the consuming processors (inlets). When riddlc processes a plant specification, it ensures that all the inlet and outlet data types match the data types of the connected pipes.\nEntities as Processors An entity may also be used as a processor under some special circumstances:\nas a source - An entity may be used as a source of events if a command handler is defined for the entity. as a sink - An entity may be used as a sink for events if a reaction handler is defined for the entity. as a flow - An entity may be used as a flow to convert commands into events Bulkheads Not Implemented This section has not been completed. TBD\nOccurs In Domains Contexts Contains Processors Pipes Joints "},{"id":142,"href":"/concepts/processor/","title":"Processors","parent":"Concepts","content":"A processor is a component of any vital definition. Processors perform some transformation, typically, of the data flowing in from itsinlet(s) and produces some, potentially different, data to its [outlet(s)]({{\u0026gt; relref outlet \u0026gt;}}).\nInlets An inlet provides the name and data type for an input to the processor. There can be multiple inlets to the processor or none. A processor with no inlets defined is called a source since it originates data by itself.\nOutlets An outlet provides the name and data type for an output from the processor. There can be multiple outlets defined by the processor or none. A processor with no outlets is called a sink since it terminates data flow.\nKinds Of Processors RIDDL supports six kinds of processors. The kind of processor depends solely on the number of inlets and outlets that are defined by the processor, as shown in the table:\n# Inlets # Outlets Kind Description 0 any Source Sources originate their data, and publish it to an outlet any 0 Sink Sinks terminate their data, and consume it from their inlet 1 1 Flow Flows transform their data from inlet to outlet 1 any Split Splits their data from one source to multiple outlets any 1 Merge Merges their data from multiple intles to a single outlet any any Multi Any other combination is a many-to-many flow Handlers A processor contains handlers that specify how the business logic should proceed. For sources, sinks, and flows, this is trivial. But for splits, merges and multis, there is a need to specify how the messages received on inlets are processed (transformed) and then put out to the outlets.\nOccurs In Contexts Plants Contains Inlets Outlets Handlers "},{"id":143,"href":"/concepts/projection/","title":"Projections","parent":"Concepts","content":"Projections get their name from\nEuclidean Geometry but are probably more analogous to a relational database view. The concept is very simple in RIDDL: projections gather data from entities and other sources, transform that data into a specific record type, and support querying that data arbitrarily.\nProjections transform update events from entities into a data set that can be more easily queried. Projections have handlers that specify both how to apply updates to the projections state and satisfy queries against that state. A projection\u0026rsquo;s data is always duplicate and not the system of record for the data. Typically persistent entities are the system of record for the data.\nOccurs In Contexts Contains Authors Fields Handlers Includes Options Terms "},{"id":144,"href":"/concepts/repository/","title":"Root","parent":"Concepts","content":"A RIDDL repository is an abstraction for anything that can retain information(e.g. messages)for retrieval at a later time. This might be a relational database, NoSQL database, a data lake, an API, or something not yet invented. There is no specific technology implied other than the retention and retrieval of information. You should think of repositories more like a message-oriented version of the Java Repository Pattern than any particular kind of database.\nSchemas Repositories have traditionally had data schemas as part of their design definition; but RIDDL regards schemas as a technical detail of the implementation and leaves them unspecified. Repositories are only defined in terms of their message handling.\nHandling Messages A repository has a handler that processes messages with respect to the repository\u0026rsquo;s stored information.\nQuery messages sent to the repository are requests for retrieval of some information. The handler should define how the processing of that query should proceed and yield a Result message.\nCommand messages sent to the repository are updates to the repository. The handler should define how the update work and may optionally yield an Event message but generally that is handled at a higher level of abstraction.\nOccurs In Context Contains Types Messages Handler "},{"id":145,"href":"/concepts/root/","title":"Root","parent":"Concepts","content":"The root concept refers to the container of domains. Domains are the top level definition in RIDDL but because RIDDL is hierarchical, and you can have more than one domain definition at the top level, something has to contain those top level domains. We call that the root. A root is not a definition since it has no name. You can think of a root as the file in which a domain is defined.\nOccurs In At the file root of the first file riddlc reads.\nContains Domains Includes "},{"id":146,"href":"/concepts/sagastep/","title":"Saga Steps","parent":"Concepts","content":"One step in a saga. Each step has input arguments and yields output. It also has both do and undo examples for its action and compensating action.\nOccurs In Contexts Contains Examples "},{"id":147,"href":"/concepts/saga/","title":"Sagas","parent":"Concepts","content":"A Saga is a distributed persistent transaction that uses the Saga Pattern. Sagas are used to coordinate state changes across multiple components (typically entities) in a system. Every change (action) has a compensating action to undo the action. This permits an organized rollback if one component cannot proceed with the transaction.\nOccurs In Contexts Contains SagaStep "},{"id":148,"href":"/search/","title":"Search Result","parent":"Index","content":""},{"id":149,"href":"/concepts/state/","title":"States","parent":"Concepts","content":"A State defines the state of an entity. It is defined as a set of fields with a handler that defines how messages cause changes to the value of those fields.\nAn entity can have multiple state definitions with the implication that this entity would be considered a Finite State Machine. However, it would only be such if the entity used the finite state machine option.\nOccurs In Entities Contains Fields Handler "},{"id":150,"href":"/concepts/story/","title":"Stories","parent":"Concepts","content":"A story in RIDDL is a definition that defines a user story. This is the same concept as the idea Kent Beck introduced in 1997. In RIDDL, a story gets a little more involved than the usual formulations of a user story:\nAs an {actor}, I would like {capability}, so that {benefit}\nor\nIn order to receive {benefit}, as an {actor}, I can {capability}\nwhich have these three ideas:\nAn actor that provides the role played by the narrator of the story A capability that provides the capability used by the narrator A benefit that provides the reason why the narrator wants to use the capability A RIDDL Story also provides a set of cases that relate the story to other RIDDL components through the steps taken for each [case](/concepts/case/. Each case specifies a set of interactions that define and label the interactions between other RIDDL definitions such as elements, entities, and projections. Cases can also define\nexamples, to outline user acceptance testing.\nStories are designed to produce sequence diagrams. This allows the intended interaction of some actor (human or not) with the system being designed in RIDDL to support a detailed definition of a user story.\nOccurs In Domains Contains) Cases "},{"id":151,"href":"/concepts/case/","title":"Story Case","parent":"Concepts","content":"Stories are specified with multiple case definitions that it contains. A case in this context is a use case, that is, a set of steps that define the interaction between components. Multiple cases are often needed to show both happy and unhappy paths.\nA case is composed of a set of steps. Those steps consist of a described relationship between two components. These can be general (any component to any component) or specific for certain pairs of components.\nThe following table shows the pairings recognized:\nkeyword From To Description arbitrary any any Arbitrary relationship between components tell any entity Send a message to an entity asynchronously publish any pipe Publish a message to a pipe subscribe any pipe Subscribe to a pipe saga any saga Initiate a saga select actor element Select an item from application element provide actor element Provide input data too application present actor element Cause an application to present info Occurs In Stories Contains) Examples "},{"id":152,"href":"/tags/","title":"Tags","parent":"Index","content":""},{"id":153,"href":"/concepts/term/","title":"Terms","parent":"Concepts","content":"A Term is merely a glossary entry. Since DDD requires bounded contexts to have precise terminology, the Term definition allows model authors to include a word definition that is not a definition in the model.\nOccurs In All vital definitions\nContains Nothing\n"},{"id":154,"href":"/concepts/type/","title":"Types","parent":"Concepts","content":" Introduction The RIDDL language allows users to define types of data, or information. RIDDL\u0026rsquo;s type system is fairly rich, for a specification language, providing abstractions for many concretely common information structures. This is done to make it easier for domain engineers and experts to understand the models they are creating.\nA type defines the shape of some information. There are many kinds of type definitions allowed, so we have grouped them into categories:\nIntroduction Predefined Types Simple Predefined Types Parameterized Predefined Types Compounds Enumeration Alternation Aggregation Key/Value Mapping Messages Cardinality Suffixes Prefixes Occurs In Contains Predefined Types RIDDL supports several predefined types that just \u0026ldquo;exist\u0026rdquo; because they are:\napplicable to nearly all fields of study or knowledge domains fundamental in nature, covering the SI base units fundamental in business, covering basic financial quantities such as currency easily represented in any computing environment RIDDL inherently knows about these predefined types so to use them you just use their name, no further definition is required. Here are the simple predefined types:\nSimple Predefined Types Name Description Abstract An unspecified, arbitrary type, compatible with any other type Nothing A type that cannot hold any value, commonly used as a placeholder Boolean A Boolean value, with values true or false Current An SI unit of electric current, measured in Amperes Date A date value comprising a day, month and year DateTime A combination of Date and Time Duration An amount of time, measured in SI units of seconds Length An SI unit of distance measured in meters Luminosity An SI unit of luminous intensity, measured in candelas Mass An SI unit of mass measured in kilograms Mole An SI unit of an amount of substance, measured in mol Number An arbitrary number, integer, decimal or floating point String A sequence of Unicode characters Temperature An SI unit of thermodynamic temperature, measured in Kelvin Time A time value comprising an hour, minute, second and millisecond TimeStamp A fixed point in time UUID A randomly unique identifier with low likeliness of collision Parameterized Predefined Types Some predefined types take parameters to customize their content, we call these parameterized predefined types.\nName Parameters Description String (min,max, enc) A String, as above, of a specific length range and encoding. Id (entity) A unique identifier for a kind of entity given by entity URL (scheme) A URL for a specific URL scheme (e.g. http) Range (min,max) A integer from min to max LatLong (lat, long) A location based on latitude and longitude Currency (country-code) The currency of a nation using ISO 3166 country codes Pattern (regex) A string value that conforms to a regular expression, regex Compounds Compound types add structure around the predefined types and require further definition in RIDDL.\nEnumeration An enumeration defines a type that may take the value of one identifier from a closed set of constant identifiers using the any keyword and the set of identifiers enclosed in square brackets, like this:\ntype Color = any of [Red, Orange, Yellow, Green, Blue, Indigo, Violet] Alternation A type can be defined as any one type chosen from a set of other type names using the select keyword followed by type names separated by |, like this:\ntype References = select String | URL There must be at least two types in an alternation.\nAggregation A type can be defined as an aggregate of a group of values of types. DDD calls this a \u0026ldquo;value object\u0026rdquo;. Aggregations can be nested, even recursively. Each value in the aggregation has an identifier (name) and a type separated by a colon. For example, here is the type definition for a rectangle located on a Cartesian coordinate system at point (x,y) with a given height and width:\ntype Rectangle = { x: Number, y: Number, height: Number, width: Number } Key/Value Mapping A type can be defined as a mapping from one type (the key) to another type (the value). For example, here is a dictionary definition that maps a word (lower case letters) to a type named DictionaryEntry that presumably contains all the things one would find in a dictionary entry.\ntype dictionary = mapping from Pattern(\u0026#34;[a-z]+\u0026#34;) to DictionaryEntry Messages An aggregate type (value object in DDD) can be declared to be one of four kinds of message types using the command, event, query, and result keywords. These type definitions are useful for sending messages to entities or across pipes.\nFor example, here is a command definition:\ntype JustDoIt = command { id: Id(AnEntity), encouragement: String, swoosh: URL } Cardinality You can use a cardinality suffix or prefix with any of the type expressions defined above to transform that type expression into the element type of a collection.\nSuffixes The suffixes allowed are adopted from regular expression syntax with the following meanings:\nSuffix Meaning Required: exactly 1 instance of the preceding type ? Optional: either 0 or 1 instances of the preceding type * Zero or more instances of the preceding type + One or more instances of the preceding type ... One or more instances of the preceding type ...? Zero or more instances of the preceding type Note the empty first item in the table; without the suffix, the cardinality of a type expression is \u0026ldquo;required\u0026rdquo; (exactly one). For example, in this:\ntype MyType = { ids: Id+, name: String? } the MyType type is an aggregate that contains one or more Id values in the ids field and an optional string value in name\nPrefixes The prefixes allowed have a similar meaning to the suffixes:\nSuffix Meaning required Required: exactly 1 instance of the preceding type optional Optional: either 0 or 1 instances of the preceding type many Zero or more instances of the preceding type many required One or more instances of the preceding type Occurs In All Vital Definitions\nContains Fields (in aggregations only) "},{"id":155,"href":"/concepts/vital/","title":"Vital Definitions","parent":"Concepts","content":"Not all definitions are equal. The RIDDL language considers some definitions to be more important than others, and we call these \u0026ldquo;vital definitions\u0026rdquo;. You can recognize a vital definition because they all have\nExamples somewhere in their definitional hierarchy.\nThese are the vital definitions:\nAdaptors, [Applications]/concepts/application/), Contexts, Domains, Functions, Entities, Handlers, Plants, Processors, Projections, Repositories Sagas, and Stories. "}]