[{"id":0,"href":"/","title":"Introduction","parent":"","content":"RIDDL, the Reactive Interface to Domain Definition Language, is a tool for generating code and documentation from a high level definition based on Domain Driven Design (DDD) and reactive software architecture concepts.\n"},{"id":1,"href":"/introduction/","title":"Introduction","parent":"Introduction","content":"RIDDL is a specification language for large systems using concepts from domain driven design and reactive system architecture. It aims to capture business level concepts in a way that can be directly translated into software that implements the scaffolding for those business concepts; leaving programmers to augment that scaffolding with the business logic.\nBased On DDD     RIDDL is based on the concepts from Domain Driven Design (DDD). This allows domain experts and software developers to work at a higher level of abstraction using a ubiquitous language to develop a system specification that is familiar and comprehensible by business and technology leaders alike.\nFor best comprehension of the language, it is best to be familiar with the DDD concepts. For a four-minute overview, watch this video. For a more in depth understanding, we recommend reading Vaughn Vernon\u0026rsquo;s more concise book Domain Driven Design Distilled or Eric Evans\u0026rsquo; original tome Domain Driven Design.\nRIDDL relieves developers of the need to write redundant, boilerplate code for micro-service implementations due to its code generation features. The DDD-inspired specification language allows domain experts and developers to work at higher levels of abstraction and specification than they would if they were coding directly in a programming language. RIDDL aims to relieve developers of the burden of maintaining infrastructural code through the evolution of the domain model. It also aims to aid the domain expert with a rigorous but simple language to use for a specification.\nCode Generation     RIDDL has its own compiler, riddlc, which can compile specifications written in RIDDL syntax into many kinds of output:\n .bast - generates files that capture the abstract syntax tree (AST) in a transportable binary format docs - generates a Hugo based website for sharing the model with coworkers in their browser diagrams - data flow, sequence, entity, context maps, and other diagrams all automatically deduced from the code api - OpenAPI (formerly called Swagger) specifications for APIs implied in the model code - generates Scala/Akka code for the framework of the system with clean separation for the parts that a programmer must implement. others - plugins can be written to convert the AST into any other kind of data  The compiler also performs AST syntax checking, semantic validation, and statistical summaries. Together, these tools make a compelling offering for rapidly capturing business models, validating the semantics of those models, and speeding up the development process to deliver a system based on the model.\n"},{"id":2,"href":"/translation/options/","title":"riddlc options","parent":"Translation","content":"Introduction     Like many other complex programs, riddlc implements a variety of commands, each with their own functionality and their own options. As there are overlaps\nOptions come and go as riddlc evolves. If you experience issues with the command line options, you can always run riddlc without any options and it will explain the options your version supports.  Common Options     Some options are common to all the commands.\n-h (\u0026ndash;help)     Causes riddlc to print out help and usage information and exit.\n-t (\u0026ndash;show-times)     Translation is done in various stages (parsing, validating, loading, translating, etc.). This option causes riddlc to print out how long each of these stages takes\n-v (\u0026ndash;verbose)     Causes riddlc to be more verbose in its output, what it is doing, etc. So far this doesn\u0026rsquo;t add any additional output but the option is reserved for this use case.\n-q (\u0026ndash;quiet)     Do not print out any output, just do the requested command.\n-d (\u0026ndash;dry-run)     Go through the motions of processing the options and teeing up the command to run, but don\u0026rsquo;t actually run it.\n-w (\u0026ndash;suppress-warnings)     Causes all warnings to be squelched from the output. riddlc has many general warnings, lots of warnings about missing things, and even stylistic or idiomatic suggestions. This option suppresses all of them to make the output less verbose.\n-m (\u0026ndash;suppress-missing-warnings)     Warnings about missing constructs are normally turned off, this option turns them back on so the messages are put out by riddlc. This can be quiet verbose in early RIDDL specifications that do not have much documentation in them.\n-s (\u0026ndash;suppress-style-warnings)     Warnings about RIDDL style are normally turned off, this option turns them back on so the messages are put out by riddlc\nparse [options] Command     The parse command causes riddlc to only parse the provided RIDDL file for syntactic compliance with the RIDDL language. No validation or translation is done on the input. Note that riddlc terminates after the first syntax error message has printed.\nIn addition to the common options, you can specify the options described in the following subsections.\n-i (--input-file)     This is a required option that provides the file to be parsed.\nvalidate [options] Command     This command does everything that the parse command does, but also semantically validates the input if parsing succeeds.\nIn addition to the common options, you can specify the options described in the following subsections.\n-i (--input-file)     This is a required option that provides the file to be parsed.\nreformat [options] Command     This command regurgitates its input but in a consistent style with options to affect that style in various ways.\nIn addition to the common options, you can specify the options described in the following subsections.\n-i (--input-file)     This is a required option that provides the file to be parsed.\n-o (--output-dir)     This is a required option that provides the directory into which the output will be placed. Generated files will have the same names as the input files.\n-s (--single-file)     This option causes all the include statements in the input to be removed and the entire input generated into a single file.\nCurrently this option is forced on whether you specify the option or not. The only output supported is a single file. This will be remedied in a later release.  hugo [options] Command     This command causes riddlc to parse, validate and translate its input into the input needed for a hugo based website that described the RIDDL input.\nIn addition to the common options, you can specify the options described in the following subsections.\n-i (--input-file)     This is a required option that provides the file to be translated to a hugo website.\n-o (--output-dir)     This is a required option that provides the directory into which the hugo website source files will be placed.\n-p, --project-name \u0026lt;value\u0026gt;     This options provides the hugo command with the overall name of the project that is being described by the RIDDL input. This is used in the meta tags for the title of the page, and other places where the title is needed.\n-e, --erase-output \u0026lt;value\u0026gt;     Erase the entire output directory before putting out any files.\nIt is highly recommended that you use this option, but it defaults to off to prevent the new user from deleting the wrong directory structure. All files under --output-dir will be unceremoniously deleted so specifying --output-dir incorrectly can yield significant data loss.  -b, --base-url \u0026lt;value\u0026gt;     This option provides the first part of the URL at which the generated site is publicly accessible. It defaults to http://localhost:1313 which is the default for hugo.\n-s, --source-url \u0026lt;value\u0026gt;     The generated site offers the ability to link to the source document for any page. The \u0026lt;value\u0026gt; provided must be a valid URL for a website.\nThis corresponds to the geekdoc hugo theme\u0026rsquo;s geekdocRepo parameter.  -h, --edit-path \u0026lt;value\u0026gt;     This option is used to extend the funtionality of the --source-url option to allow editing as well as linking to the source. This option provides the source repository\u0026rsquo;s intermediate URL path that can be used to edit a page.\n-l, --site-logo-url \u0026lt;value\u0026gt;     URL to the site\u0026rsquo;s logo image for use by hugo\nhugo-git-check [options] Command     This command is the same as the hugo command, and takes the same options, except you also provide a URL to a directory in a git repository. Any changes to the git repository below that direction, as reported by git, will cause the hugo command to run. Otherwise nothing happens. This allows an auto-update upon changes when combined with the repeat command.\nfrom \u0026lt;path-to-config-file\u0026gt; Command     This command repeats\nrepeat \u0026lt;cycle-delay\u0026gt; \u0026lt;max-cycles\u0026gt; \u0026lt;path-to-config-file Command     This command repeats whichever command is specified in the configuration file at \u0026lt;path-to-config-file\u0026gt;. It will cycle \u0026lt;max-cycles\u0026gt; times and insert a delay of \u0026lt;cycle-delay\u0026gt; which must be specified with a duration suffix like s(seconds) m(minutes), etc. The full set of possibilities are defined here\nthe input needed for a hugo based website that described the RIDDL input.\nIn addition to the common options, you can specify the options described in the following subsections.\nOptions From Configuration Files     The from and repeat commands use HOCON configuration files to determine what to do. The HOCON syntax is [fully explained here](https://github. com/lightbend/config/blob/main/HOCON.md) but it is simpler than that in the case of riddlc, just follow these rules:\n Assign the command you want to run to the \u0026ldquo;command\u0026rdquo; option. All the common options can be specified at the top level. Command specific options must appear in a section named after the command. All the configuration items have the same names as the long form names that\nriddlc prints out with the help command.  So, for example, to reformat a file to another file without warnings you could set up a configuration file like this:\ncommand = reformat suppress-warnings = true reformat { input-file = \u0026#34;path/to/input.riddl\u0026#34; output-dir = \u0026#34;path/to/output/dir\u0026#34; single-file = true } Similarly for other commands. You can even specify all the options for all the commands and then just change the command selector when you want to do something different. Or, put them each in separate files and use commandline completion to specify which file.\nExample of riddlc help command     RIDDL Compiler (c) 2022 Reactive Software LLC. All rights reserved. Version: 0.2.1-131-f6486929  This program parses, validates and translates RIDDL sources to other kinds of documents. RIDDL is a language for system specification based on Domain Drive Design, Reactive Architecture, and Agile principles.  Usage: riddlc [parse|validate|reformat|hugo|hugo-git-check|from|help|repeat] [options] \u0026lt;args\u0026gt;...   -V | --version   -h | --help  Print out help/usage information and exit  -t | --show-times  Show compilation phase execution times  -d \u0026lt;value\u0026gt; | --dry-run \u0026lt;value\u0026gt;  go through the motions but don\u0026#39;t write any changes  -v | --verbose  Provide detailed, step-by-step, output detailing riddlc\u0026#39;s actions  -q | --quiet  Do not print out any output, just do the requested command  -w | --suppress-warnings  Suppress all warning messages so only errors are shown  -m | --suppress-missing-warnings  Show warnings about things that are missing  -s | --suppress-style-warnings  Show warnings about questionable input style. Command: parse [options] Parse the input for syntactic compliance with riddl language. No validation or translation is done on the input  -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt;  required riddl input file to read Command: validate [options] Parse the input and if successful validate the resulting model. No translation is done on the input.  -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt;  required riddl input file to read Command: reformat [options] Parse and validate the input-file and then reformat it to a standard layout written to the output-dir.  -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt;  required riddl input file to read  -o \u0026lt;value\u0026gt; | --output-dir \u0026lt;value\u0026gt;  required output directory for the generated output  -s \u0026lt;value\u0026gt; | --single-file \u0026lt;value\u0026gt;  Resolve all includes and imports and write a single file with the same  file name as the input placed in the out-dir Command: hugo [options] Parse and validate the input-file and then translate it into the input needed for hugo to translate it to a functioning web site.  -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt;  required riddl input file to read  -o \u0026lt;value\u0026gt; | --output-dir \u0026lt;value\u0026gt;  required output directory for the generated output  -p \u0026lt;value\u0026gt; | --project-name \u0026lt;value\u0026gt;  Optional project name to associate with the generated output  -e \u0026lt;value\u0026gt; | --erase-output \u0026lt;value\u0026gt;  Erase entire output directory before putting out files  -b \u0026lt;value\u0026gt; | --base-url \u0026lt;value\u0026gt;  Optional base URL for root of generated http URLs  -t \u0026lt;value\u0026gt; | --themes \u0026lt;value\u0026gt;   -s \u0026lt;value\u0026gt; | --source-url \u0026lt;value\u0026gt;  URL to the input file\u0026#39;s Git Repository  -h \u0026lt;value\u0026gt; | --edit-path \u0026lt;value\u0026gt;  Path to add to source-url to allow editing  -l \u0026lt;value\u0026gt; | --site-logo-url \u0026lt;value\u0026gt;  URL to the site\u0026#39;s logo image for use by site  -p \u0026lt;value\u0026gt; | --site-logo-path \u0026lt;value\u0026gt;  Path, in \u0026#39;static\u0026#39; directory to placement and use  of the site logo. Command: hugo-git-check [options] git-clone-dir This command checks the \u0026lt;git-clone-dir\u0026gt; directory for new commits and does a `git pull\u0026#34; command there if it finds some; otherwise it does nothing. If commits were pulled from the repository, then the hugo command is run to generate the hugo source files and hugo is run to make the web site available at hugo\u0026#39;s default local web address: |http://localhost:1313/   git-clone-dir  Provides the top directory of a git repo clone that contains the \u0026lt;input-file\u0026gt; to be processed.  -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt;  required riddl input file to read  -o \u0026lt;value\u0026gt; | --output-dir \u0026lt;value\u0026gt;  required output directory for the generated output  -p \u0026lt;value\u0026gt; | --project-name \u0026lt;value\u0026gt;  Optional project name to associate with the generated output  -e \u0026lt;value\u0026gt; | --erase-output \u0026lt;value\u0026gt;  Erase entire output directory before putting out files  -b \u0026lt;value\u0026gt; | --base-url \u0026lt;value\u0026gt;  Optional base URL for root of generated http URLs  -t \u0026lt;value\u0026gt; | --themes \u0026lt;value\u0026gt;   -s \u0026lt;value\u0026gt; | --source-url \u0026lt;value\u0026gt;  URL to the input file\u0026#39;s Git Repository  -h \u0026lt;value\u0026gt; | --edit-path \u0026lt;value\u0026gt;  Path to add to source-url to allow editing  -l \u0026lt;value\u0026gt; | --site-logo-url \u0026lt;value\u0026gt;  URL to the site\u0026#39;s logo image for use by site  -p \u0026lt;value\u0026gt; | --site-logo-path \u0026lt;value\u0026gt;  Path, in \u0026#39;static\u0026#39; directory to placement and use  of the site logo. Command: from [options] config-file Load riddlc options from a config file  config-file  A HOCON configuration file with riddlc options  -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt;  required riddl input file to read  -o \u0026lt;value\u0026gt; | --output-dir \u0026lt;value\u0026gt;  required output directory for the generated output Command: help Print out how to use this program Command: repeat config-file [refresh-rate] [max-cycles] This command supports the edit-build-check cycle. It doesn\u0026#39;t end until \u0026lt;max-cycles\u0026gt; has completed or EOF is reached on standard input. During that time, the selected subcommands are repeated.   config-file  The path to the configuration file that should be repeated  refresh-rate  Specifies the rate at which the \u0026lt;git-clone-dir\u0026gt; is checked for updates so the process to regenerate the hugo site is started  max-cycles  Limit the number of check cycles that will be repeated.  -n | --interactive  This option causes the repeat command to read from the standard  input and when it reaches EOF (Ctrl-D is entered) then it cancels  the loop to exit. "},{"id":3,"href":"/translation/akka/","title":"Akka","parent":"Translation","content":"The goal of the Akka translator is to generate all the infrastructure code needed to support the domain(s) defined in the RIDDL input. While this does produce a working system, it also relieves developers of much of the repetitive, detail oriented infrastructure that is relatively boring compared to the business logic of the system.\nThis translator recognizes that its output will be co-mingled with the business logic output that developers are writing and keeps them separate. When an expected developer file does not exist, it will create it, but otherwise uses Scala inheritance, or other mechanisms, to indicate the portions that ought to be written.\nOutput File Types     The Akka translator doesn\u0026rsquo;t just generate Scala code. It aims to generate complete projects that should be familiar to those famliar with Scala and Akka projects. This means generating a mixture of file types, as described in the following sections\nsbt build files     build.sbt project/xxx.scala project/build.properties project/plugins.sbt\nprotobuffers definitions     Specifically processed by akka-grpc (via scalapb via protoc plugins)\nScala code     Build Time Dependencies      sbt 1.6 or later sbt-riddl plugin akka-grpc sbt plugin buildinfo sbt plugin  Runtime Dependencies      Akka 2.6.17 (or later) including streams, http, cluster, persistence, \u0026hellip; Alpakka 3.x Kafka  Comparison To Akka Serverless     The Akka Translator has an objective to support both the advanced Akka Scala developer and less knowledgeable developers. It does that by using Scala\u0026rsquo;s abstraction features but without completely disconnecting from Akka\u0026rsquo;s powerful features. For example:\n Actors are used, but in a fill-in-the-blank way. Advanced programmers can still do more complicated things, neophytes will find it easy. Does not use GRPC as the interface like Akka Serveless does. Scala is the interface and there is no side-car aspect in the runtime.  "},{"id":4,"href":"/language/hierarchy/domain/context/","title":"Bounded Contexts","parent":"Domains","content":"Introduction     DDD defines the notion of a bounded context which is a portion of the domain in which the terminology is well-defined. Contexts in RIDDL represent exactly the same concept and are basically a container of various definitions that make up the bounded context. Contexts are introduced with the context keyword and have a name. They form the leaves of the definitional hierarchy so they must occur within domain definitions.\nSyntax     context BBQ is { ??? } Contained Definitions     Contexts may contain all the definitions of a DDD bounded context, as defined in the sections that follow.\nType     Types are used in bounded contexts to define messages, function input and output, the state of entities, etc. For more on type definitions see types\nAdaptor     API     Entity     Saga     Projection     "},{"id":5,"href":"/language/hierarchy/domain/context/entity/","title":"Entities","parent":"Bounded Contexts","content":"An entity in RIDDL is the same as it is in DDD which defines it this way:\nEntity Definitions\n An object primarily defined by its identity is called an Entity.\n and\n Many objects are not fundamentally defined by their attributes, but rather by a thread of continuity and identity.\n  There are three main aspects to this definition of entity:\n Entities are objects (containing both state and function) which means they can represent physical objects, mental constructs, concepts, etc. It also means they can be implemented as objects, actors, or collections of functions that share exclusive access to some data Entities have an identity; they are identified by some unique value that no other entity of the same type may have. Entities are continuous; they have a lifecycle, evolving from creation, through their useful lifespan, to destruction.  An entity is the fundamental processor of work in a reactive system and in a RIDDL specification.\nEntities are most often implemented in software as an actor or a OOP class.\nIdentity     Entities have a unique immutable persistent identifier, much like people have names except our personal names are not unique. The unique identifier is used to locate the entity in a computing system and for other computing purposes. These immutable and unique identifiers convey equivalence. That is when two values of an identifier are the same, then by definition, they must refer to the same entity. Changing the state of the entity does not break this equivalence. type Id, which provides the means to reference the entity in its context or between contexts. an Entity\u0026rsquo;s immutable identity conveys equivalence. Individual pieces of attribute of entity can change.\nEntities can also contain business Logic. Actors in Akka, Entities in Lagom. Contrary to Value Objects,\nConsumption     Entities consume commands and queries and produce events and results, correspondingly. They also hold state, whether persistent or not. Entities use event sourcing to keep track of the entire history of changes to the entity\u0026rsquo;s state. This is important because two instances of the same Entity may have different attribute values, but because both instances have the same identity value, they represent the same Entity. Which, then, is correct? The answer is neither. Both would need to reference the Event Log for the Entity to get the most current and correct state of this Entity. Thus, entities are the single source of truth for a particular id. They are the same entity. For example:\nentity Printer is { options(value, available, kind(\u0026#34;device\u0026#34;)) // ... } Aspects     Entities also have several contained definitions which specify various aspects of the entity. These aspects are detailed on the following pages:\n Options - Various options that provide high level optional aspects of the entity. States - The information retained by the entity through its lifecycle Handlers - A specification of how the entity processes commands, events, queries, and reactions to events from other entities in the same bounded context. Functions - Auxiliary function definitions to implement the frequently used business logic referenced from the Handler definitions Invariants - Logical assertions that must always be true through an entity\u0026rsquo;s lifecycle to enforce business rules Features - High level descriptions of features as an outline for both developing the system and to test the entity functionality. Adaptors - An adaptor converts events from another bounded context into commands to this entity. This is how an entity reacts to its external environment while the handler provides a way to react to events within the internal environment (its bounded context).  "},{"id":6,"href":"/examples/","title":"Example","parent":"Introduction","content":"Some people can learn RIDDL faster by looking at examples than by reading the informal definitions in the language guide or the formal definitions in the grammar section. To support that mode of learning, this section decomposes the domain of a restaurant, Reactive BBQ.\nThis section provides some examples of how RIDDL can be used.\nAbout Reactive BBQ     The Reactive BBQ domain is a familiar one for those who have taken the\nLightbend Reactive Architecture Professional (LRA-P) course which uses this example throughout the course to good effect in the workshops. The same premises apply in this domain but we have chosen to fully specify it in RIDDL.\nAs you might guess from the name, Reactive BBQ is a restaurant chain that serves spicy (reactive!) BBQ dishes. It doesn\u0026rsquo;t exist of course, even if employees may or may not have mistaken R\u0026amp;R BBQ in Salt Lake City for the Reactive version in 2018.\nThe Reactive BBQ case study in the LRA-P course included interviews with several fictitious employees. Those interviews and the case study material have been replicated here with thanks to Lightbend; and we recommend that you read that scenario first.\nThe RIDDL files for Reactive BBQ are arranged into a directory structure, each with an explanation page as follows:\n Reactive BBQ Domain  Restaurant BackOffice Corporate    "},{"id":7,"href":"/language/conventions/","title":"Language Conventions","parent":"Language","content":"Introduction     Syntax conventions of RIDDL are very simple and lenient. The intended audience is business owners, business analysts, domain engineers, and software architects. It is intentionally simple and readable. The language is free in its formatting. It does not require indentation and its various constructs can be arranged on any line. RIDDL supports the definition of a variety of concepts taken directly from Domain Driven Design and the Unified Modeling Language as well as software architecture.\nThe following language conventions are adhered to throughout the language for ease of use (special cases and rule contraventions cause confusion).\nLanguage Consistency     Most things in RIDDL are consistent throughout the language. We believe this makes learning the language easier since there are no exceptions to fundamental constructs. The sections below define the consistent language features.\nDeclarative Definitions     The language is declarative. You don\u0026rsquo;t say how to do something, you specify the end result you want to see. The language aims to capture a detailed and concise definition of the abstractions that a complex system will require. It does not specify how those abstractions should be built. RIDDL is not a programming language, but its compiler can generate structurally sound code that can be implemented by a software engineer.\nEvery Definition Can Be Documented     Every thing you can define can has a described by or explained by suffix which lets you document the definition using markdown.\nHierarchy Of Definitions     Definitions are specified in a strict containment hierarchy. Definitions that can contain other definitions are known as containers. For example, a domain definition is a recursively nested definition, as follows:\ndomain root is { domain branch is { domain leaf { } } } That is, domains are definitions that can contain the definition of (sub) domains. Similarly context can define entity\ncontext foo is { entity bar is { ... } } Definitions And References     A definition introduces a named instance of some RIDDL concept at its point. The specification of that definition proceeds directly following the is keyword.\nIf RIDDL supported the concept of a Cat and its owner (it doesn\u0026rsquo;t in both those cases), then you might specify a cat named \u0026ldquo;Smudge\u0026rdquo; with an owner named \u0026ldquo;Reid\u0026rdquo; like this:\ncat Smudge is {  owner is entity Reid } Here is an explanation of each of these tokens:\n cat is the kind of concept that the author wants to define Smudge is the name the author wants to assign to this cat concept is is a required keyword for readability { starts the definition of Smudge the cat owner is the name of a property that all \u0026ldquo;cat\u0026rdquo; concepts have is is another keyword required for readability entity Reid is a reference to an instance of a concept, an entity, of type Reid. References to many kinds of RIDDL concepts are made in this way, by name (type) with a prefix for the kind of concept. } completes the definition of Smudge the cat.  This is a simple convention used throughout the language for all concept definitions and references to them.\nContainers     Containers are definitions that contain other, nested, definitions. Between the { and the } that define the boundaries of a definition, you may place other definitions. Such nested definitions are deemed to be contained. Not every definition is a container as it only applies to concepts like domain, context and entity.\nThe full list of all Container types is as follows:\n topic feature entity adaptor context interaction domain  Leaves     Definitions that may not contain other definitions are called \u0026ldquo;leaves\u0026rdquo; because, like tree leaves, they occur at the extremity (most nested) part of the definitional hierarchy.\nWork In Progress     Modelling a domain can be hard work. New ideas come up that must be flushed out. Sometimes things get left undefined. That\u0026rsquo;s okay! Riddl uses a special construct, ??? to mean \u0026ldquo;we don\u0026rsquo;t know yet\u0026rdquo;. It can be used as the body of any definition. For example it is entirely legal to write:\ncat Smudge is { ??? } If we aren\u0026rsquo;t sure of the characteristics of the cat named \u0026ldquo;Smudge\u0026rdquo;\nDirectives     RIDDL supports the notion of directives that are specified as a complete line whose first character is the hash mark. The directive extends to the end of that line. Hash marks at other locations on a line are not recognized as directives. The sub-sections below define the kinds of directives supported by RIDDL\u0026rsquo;s compiler.\nSubstitutions     For example:\n#define x = expialidocious defines a symbol x that has the value expialidocious . Wherever $x is seen in the input it will be replaced with expialidocious before being lexically interpreted by the compiler.\nFile Inclusion     RIDDL allows source input to be included, inline, from other files. That is, the parser will substitute the text of an included file, replacing the include directive. This is much like the C preprocessor #include directive. RIDDL always parses the entire specification but the include directive allows you to organize that specification into many (even nested) files. Note that include directives only permitted within container definitions. Doing so prevents fragments of definitions from being separated into individual files.\nFor example, this is allowed:\ndomain ThingAmaJig { #include \u0026#34;thingamajig/thing-context\u0026#34; #include \u0026#34;thingamajig/ama-topic\u0026#34; #include \u0026#34;thingamajig/jig-context\u0026#34; } while this is not:\ndomain #include \u0026#34;ThingAmaJig-domain\u0026#34; because it is not specified within the contained portion of a container. A domain is a container, but it needs a name and that name cannot be buried in an include file. As a rule of thumb, you can always use #include right after an opening curly brace of a container definition.\nDescriptions (Explanations)     A definition may also be accompanied by some text or markup at its end to describe or explain the purpose of that definition. We call these descriptions or explanations because this is the text that is used to describe or explain the RIDDL definition, and it is used to generate documentation for the definition. A description occurs directly after the definition\u0026rsquo;s closing curly bracket and is preceded using either the described as or explained as keyword phrase. Essentially it looks like this:\ncat Smudge is { ??? } explained as \u0026#34;TBD but owned by Reid\u0026#34; The grammar for a description is this:\ndescription = (\u0026#34;described\u0026#34; | \u0026#34;explained\u0026#34;), \u0026#34;as\u0026#34;, \u0026#34;{\u0026#34;, description body, \u0026#34;}\u0026#34; ; description body = literal string description | doc block description ; literal string description = (literal string)+ ; literal string = \u0026#34;\\\u0026#34;\u0026#34; ; doc-block-description = ... tbd  What occurs within a description/explanation can be one of three things:\n A single literal string in quotations: \u0026quot;this string\u0026quot;, as shown above. A curly brace enclosed list of \u0026ldquo;docblock\u0026rdquo; lines which consists of a group of lines, each preceded by a vertical bar. The bar denotes the left margin. Markdown syntax is accepted. A curly brace enclosed list of four sections: brief, details, items and see  Each of these is explained in more detail in the sections that follow.\nSingle Literal String     Pretty simple, like this:\ndomain SomeDomain is { ??? } explained as \u0026#34;Not very helpful\u0026#34; Documentation Block     Allowing markdown syntax, like this:\ndomain SomeDomain is { ??? } explained as { |## Overview |This domain is rather vague, it has no content. |## Utility |The utility of this domain is dubious because: |* It has no content |* Its name is not useful |* It is only an example of RIDDL syntax } Separate Sections     When more formal documentation is required for major definitions (domains, contexts, entities), then you should use the sectioned style to group your documentation into standard sections, like this:\n brief is a simple text description of the definition details is a longer textual description enclosed in a block { }, avoiding the need to quote the text. This property may include Markdown directives that will be rendered in any generated documentation. items is a means of including references to other entities or definitions is also enclosed withing a block { }. see is a block where additional resources supporting the description may be listed.  All of these nested blocks can use markdown in a doc block or simple literal strings depending on your needs. For example:\ndomain SomeDomain is { ??? } explained as { brief { \u0026#34;this domain is rather vague, it has no content\u0026#34; } description { |The utility of this domain is dubious because: } items(\u0026#34;Aspects Of Utility\u0026#34;) { |* It has no content |* Its name is not useful |* It is only an example of RIDDL syntax } } "},{"id":8,"href":"/language/hierarchy/domain/context/entity/state/","title":"State","parent":"Entities","content":"The state definitions of an entity define the structure of the information that the entity retains as its current state.\nSyntax Example     The state of an entity is defined with the state keyword within the content of an entity definition, like this:\nentity Car { type Propulsion = any of { ICE, Electric, Steam, Diesel, EMDrive } state Static is { wheels: Integer doors: Integer rightHandDrive: Boolean propulsion: Propulsion } } One of the primary purposes of an entity is to represent the characteristics of the entity with state information. We call it state because it represents the current state of the entity at any given point in time.\nThe above example definition associates a state, named Static with the entity named Car having these fields in its aggregate data type:\n wheels - an Integer value providing the number of wheels on the car. doors - an Integer value providing the number of doors on the car. rightHandDrive - a Boolean value indicating if it is right hand drive. propulsino - a Propulsion enum value presumably representing the kind of propulsion the vehicle uses.  Multiple State Definitions     It is entirely possible to specify multiple named state definitions for a single entity. This is provided in the language to support finite state machines which are frequently used with entities. The state of an entity can be modelled as simply transitions of states as each handler processes a command. Multiple state values are useful when the state of the entity has different modes of operation where different sets of state values are needed.\n"},{"id":9,"href":"/grammar/terminals/","title":"Terminals","parent":"Grammar","content":"This file shows the definition of the terminal symbols, as productions, and grouped in categories:\n (* Terminal symbol definitions in various categories *) Terminals = Punctuation | Options | Keywords | Predefined |  Readability | Operators;  Punctuation = asterisk | comma | colon | curlyOpen | curlyClose | dot |  equals | ellipsis | ellipsisQuestion | plus | question | quote | roundOpen |  roundClose | squareOpen | squareClose | undefined | verticalBar ;  asterisk = \u0026#34;*\u0026#34;; comma = \u0026#34;,\u0026#34;; colon = \u0026#34;:\u0026#34;; curlyOpen = \u0026#34;{\u0026#34;; curlyClose = \u0026#34;}\u0026#34;; dot = \u0026#34;.\u0026#34;; equals = \u0026#34;=\u0026#34;; ellipsis = \u0026#34;...\u0026#34;; ellipsisQuestion = \u0026#34;...?\u0026#34;; plus = \u0026#34;+\u0026#34;; question = \u0026#34;?\u0026#34;; quote = \u0026#34;\\\u0026#34;\u0026#34;; roundOpen = \u0026#34;(\u0026#34;; roundClose = \u0026#34;)\u0026#34;; squareOpen = \u0026#34;[\u0026#34;; squareClose = \u0026#34;]\u0026#34;; undefined = \u0026#34;???\u0026#34;; verticalBar = \u0026#34;|\u0026#34;; Options = actor |aggregate | async | available | consistent | device eventSourced | function | gateway | persistent | reply | concept | sync value | wrapper ; actor = \u0026#34;actor\u0026#34;; aggregate = \u0026#34;aggregate\u0026#34;; async = \u0026#34;async\u0026#34;; available = \u0026#34;available\u0026#34;; consistent = \u0026#34;consistent\u0026#34;; device = \u0026#34;device\u0026#34;; eventSourced = \u0026#34;event sourced\u0026#34;; function = \u0026#34;function\u0026#34;; gateway = \u0026#34;gateway\u0026#34;; persistent = \u0026#34;persistent\u0026#34;; reply = \u0026#34;reply\u0026#34;; concept = \u0026#34;concept\u0026#34;; sync = \u0026#34;sync\u0026#34;; value = \u0026#34;value\u0026#34;; wrapper = \u0026#34;wrapper\u0026#34;; Keywords = action | adaptor | all | any | append | background | brief | call | causing | command | commands | consumer | context | described | details | domain | each | else_ | entity | event | events | example | execute | explained | feature | function | handles | include | input | interaction | invariant | items | many | mapping | on | one | option | optional | options | output | publish | query | queries | range | remove | requires | result | results | role | see | send | set | state | then_ | topic | type | value | when | yields action = \u0026#34;action\u0026#34;; adaptor = \u0026#34;adaptor\u0026#34;; all = \u0026#34;all\u0026#34;; any = \u0026#34;any\u0026#34;; append = \u0026#34;append\u0026#34;; background = \u0026#34;background\u0026#34;; brief = \u0026#34;brief\u0026#34;; call = \u0026#34;call\u0026#34;; causing = \u0026#34;causing\u0026#34;; command = \u0026#34;command\u0026#34;; commands = \u0026#34;commands\u0026#34;; consumer = \u0026#34;consumer\u0026#34;; context = \u0026#34;context\u0026#34;; described = \u0026#34;described\u0026#34;; details = \u0026#34;details\u0026#34;; domain = \u0026#34;domain\u0026#34;; each = \u0026#34;each\u0026#34;; else_ = \u0026#34;else\u0026#34;; entity = \u0026#34;entity\u0026#34;; event = \u0026#34;event\u0026#34;; events = \u0026#34;events\u0026#34;; example = \u0026#34;example\u0026#34;; execute = \u0026#34;execute\u0026#34;; explained = \u0026#34;explained\u0026#34;; feature = \u0026#34;feature\u0026#34;; function = \u0026#34;function\u0026#34;; handles = \u0026#34;handles\u0026#34;; include = \u0026#34;include\u0026#34;; input = \u0026#34;input\u0026#34;; interaction = \u0026#34;interaction\u0026#34;; invariant = \u0026#34;invariant\u0026#34;; items = \u0026#34;items\u0026#34;; many = \u0026#34;many\u0026#34;; mapping = \u0026#34;mapping\u0026#34;; on = \u0026#34;on\u0026#34;; one = \u0026#34;one\u0026#34;; option = \u0026#34;option\u0026#34;; optional = \u0026#34;optional\u0026#34;; options = \u0026#34;options\u0026#34;; output = \u0026#34;output\u0026#34;; publish = \u0026#34;publish\u0026#34;; query = \u0026#34;query\u0026#34;; queries = \u0026#34;queries\u0026#34;; range = \u0026#34;range\u0026#34;; remove = \u0026#34;remove\u0026#34;; requires = \u0026#34;requires\u0026#34;; result = \u0026#34;result\u0026#34;; results = \u0026#34;results\u0026#34;; role = \u0026#34;role\u0026#34;; see = \u0026#34;see\u0026#34;; send = \u0026#34;send\u0026#34;; set = \u0026#34;set\u0026#34;; state = \u0026#34;state\u0026#34;; then_ = \u0026#34;then\u0026#34;; topic = \u0026#34;topic\u0026#34;; type = \u0026#34;type\u0026#34;; value = \u0026#34;value\u0026#34;; when = \u0026#34;when\u0026#34;; yields = \u0026#34;yields\u0026#34;; Predefined = Boolean | Date | DateTime | Decimal | Duration | Id | Integer | LatLong | Nothing | Number | Pattern | Real | String | Time | TimeStamp | UniqueId | URL ; Boolean = \u0026#34;Boolean\u0026#34;; Date = \u0026#34;Date\u0026#34;; DateTime = \u0026#34;DateTime\u0026#34;; Decimal = \u0026#34;Decimal\u0026#34;; Duration = \u0026#34;Duration\u0026#34;; Id = \u0026#34;Id\u0026#34;; Integer = \u0026#34;Integer\u0026#34;; LatLong = \u0026#34;LatLong\u0026#34;; Nothing = \u0026#34;Nothing\u0026#34;; Number = \u0026#34;Number\u0026#34;; Pattern = \u0026#34;Pattern\u0026#34;; Real = \u0026#34;Real\u0026#34;; String = \u0026#34;String\u0026#34;; Time = \u0026#34;Time\u0026#34;; TimeStamp = \u0026#34;TimeStamp\u0026#34;; UniqueId = \u0026#34;UniqueId\u0026#34;; URL = \u0026#34;URL\u0026#34;; Readability = and | are | as | by | for | from | is | of | on | to ; and = \u0026#34;and\u0026#34;; are = \u0026#34;are\u0026#34;; as = \u0026#34;as\u0026#34;; by = \u0026#34;by\u0026#34;; for = \u0026#34;for\u0026#34;; from = \u0026#34;from\u0026#34;; is = \u0026#34;is\u0026#34;; of = \u0026#34;of\u0026#34;; on = \u0026#34;on\u0026#34;; to = \u0026#34;to\u0026#34;; Operators = and | or | not | plus | minus | times | div | mod ; not = \u0026#34;not\u0026#34;; plus = \u0026#34;+\u0026#34;; minus = \u0026#34;-\u0026#34;; times = \u0026#34;*\u0026#34;; div = \u0026#34;/\u0026#34;; mod = \u0026#34;%\u0026#34;;  "},{"id":10,"href":"/language/common/","title":"Common","parent":"Language","content":"Some definitions are fundamental to RIDDL and can appear in many RIDDL container definitions. Before exploring the hierarchy of definitions, we will define some things that are common to many definitions:\n include - lexically including files into the current file descriptions - describing definitions for documentation purposes types - defining types of information or data examples - defining Gherkin examples to express testable behavior expressions - defining expressions in various places functions - the syntax of a function body import - importing definitions from a previous compilation  "},{"id":11,"href":"/language/common/descriptions/","title":"Descriptions","parent":"Common","content":"The RIDDL syntax is simply a hierarchical arrangement of definitions. Each definition can have a description. Descriptions are used to generate documentation and follow markdown conventions.\nExamples     There are several ways to describe a definition. In each of the examples we attach a description to some domain named Foo. The definition is not important for our purposes here. Descriptions come after the definition using one of four phrases:\n described by described as explained by explained as  These four phrases are equivalent but provided to suit the nature of the definitions to which they may be applied. For example:\ndomain Foo is { } explained as \u0026#34;Foo is not a very good domain name\u0026#34; is equivalent to:\ndomain Foo is { } described by \u0026#34;Foo is not a very good domain name\u0026#34; Quoted String Format     The examples show above use a single string as the description. This is appropriate when the description is short, as is typical for small definitions.\nQuoted Strings Format     Alternatively, a large description may be provided as a set of quoted strings enclosed in curly braces. For example:\ndomain Foo is { } described by { \u0026#34;Foo is not a very good domain name\u0026#34; \u0026#34;And an empty domain doesn\u0026#39;t define anything!\u0026#34; } Note in this case that we have embedded markdown syntax into the description.\nMarkdown Format     Alternatively, to make things a little more free-form, and aligned on the left column, a description may be formed using just a vertical bar character to indicate the line start. For example:\ndomain Foo is { } described by { |# Warning |Foo is not a very good domain name |And an empty domain doesn\u0026#39;t define anything! } Note in this case that we have embedded markdown syntax into the description. The # Warning syntax is an indication to a markdown processor that a new heading with the text \u0026ldquo;Warning\u0026rdquo; should be started. All descriptions are encouraged to use this markdown syntax style.\nUsing Markdown Syntax     Markdown syntax is encouraged in descriptions because the riddlc compiler can translate RIDDL specifications into the input of the website generator hugo, which expects markdown. In this way, a large RIDDL specification can be translated automatically into a beautiful website.\nThe full range of markdown, html, and shortcode syntax that hugo supports may be used in RIDDL descriptions. See this link for more details on hugo\n"},{"id":12,"href":"/language/hierarchy/domain/context/entity/options/","title":"Options","parent":"Entities","content":"The optional entity kind prefix is a directive that suggests how the entity might handle its state and received messages. In the example above, we expect the \u0026ldquo;Printer\u0026rdquo; entity to be a physical device. An \u0026ldquo;actor\u0026rdquo; entity in of the same name could be expected to be a person who prints.\nThe options available suggest how the entity might handle its state and message input:\n kind - indicates the intended kind of entity in an argument to the kind entity. event sourced - indicates that event sourcing is used in the persistence of the entity\u0026rsquo;s states, storing a log of change events value - indicates that only the current value of the entity\u0026rsquo;s state is persisted, recording no history off the change events aggregate - indicates this entity is an \u0026lsquo;aggregate root entity\u0026rsquo; as defined by DDD. persistent - indicates that this entity should persist its state to stable storage. consistent - indicates that this entity tends towards Consistency as defined by the CAP theorem and therefore uses sharding and the single writer principle to ensure a consistent view on state changes available - indicates that this entity tends towards Availability as defined by the CAP theorem and therefore replicates its entity state to multiple locations or even across data centers using CRDTs (conflict-free replicated data types). grpc - indicates that the entity should be accessible via gRPC api invocations mq - indicates that commands and queries may be sent by a message queue such as Kafka, Pulsar, or Google Pub Sub  "},{"id":13,"href":"/language/hierarchy/root/","title":"Root","parent":"Definitional Hierarchy","content":"At the root (file) level you can only do two things: include definitions from another file or define a domain.\nFor example:\ninclude \u0026#34;other-file\u0026#34; domain foo is { ??? } ``` "},{"id":14,"href":"/language/hierarchy/domain/context/adaptor/","title":"Adaptors","parent":"Bounded Contexts","content":"Adaptors are translators between contexts and (sub-)domains. DDD calls these \u0026ldquo;anti-corruption layers\u0026rdquo; which we find awkward, hence we renamed them as adaptors. However, the name DDD chose is apt. Adaptors aim to solve a language problem that often exists in large domain modelling exercises: conflation and overloading of terms.\nFor example, consider the word \u0026ldquo;order\u0026rdquo; in various contexts:\n military - a directive or command from a superior to a subordinate restaurant - a list of items to be purchased and delivered to a table mathematics - A sequence or arrangement of successive things. sociology - A group of people united in a formal way architecture - A type of column and entablature forming the unit of a style  And there are several more. To disambiguate these definitions we use bounded contexts in DDD, and RIDDL, that precisely define the meaning of a term in that context. But, what happens when two bounded contexts use the same term for different purposes? That\u0026rsquo;s where Adaptors come in.\nUse Cases     There are several use cases in which the need for an Adaptor occurs as in the following subsections\nNon-DDD External Systems     An adaptor can adapt a non-DDD external system to a DDD system. The DDD system can then interact with the non-DDD system using messages as if it was a DDD system by simply interacting with the corresponding Adaptor.\nSee this stackoverflow article for more on this.\nReactions     Some entities need to react to the occurrence of events from other bounded contexts. These adaptations are often handled directly by an entity handler but sometimes the model needs to specify reactions at the bounded context level where they can be converted into commands on the appropriate entities.\nVersioning     Bounded contexts and their entities undergo version changes and those changes can affect the structure and composition of the messages used. To support smooth transitions between versions, the software needs to support older versions of messages seamlessly. This is handled in RIDDL by adapting the old messages to the new messages, even if that means ignoring them.\nDefining Adaptors     An adaptor can only be defined as part of the definition of a bounded context. It can specify how to handle the messages received from another bounded context, or even from a pipe. For example, we adapt context Bar below to the event from context Foo\ncontext Foo is { type FooEventName is event { ??? } } context Bar is { type BarCommandName is command { ??? } adaptor FromFooContext for Foo is { adapt FooEventName to BarCommandName as { given \u0026#34;entity\u0026#34; } } } "},{"id":15,"href":"/language/hierarchy/domain/context/api/","title":"APIs","parent":"Bounded Contexts","content":"An api definition represents a stateless application programming interface. RIDDL supports this definition in domains and bounded contexts. This permits higher level functional gateways to summarize the behavior of entire subdomains and bounded contexts.\nAlways Stateless     APIs are always stateless. Any state that needs to be saved when an API function is invoked should be done by sending commands to an entity from an API function.\nFunctions     APIs are collections of functions. TBD\n"},{"id":16,"href":"/grammar/common/","title":"Common","parent":"Grammar","content":"A number of frequently used productions are useful to understand in the sections that follow. Commentary follows the grammar.\n(* Common RIDDL EBNF Grammar Productions *)  (******************************************************************** COMMON *)  any char = ? any UTF-8 character ? ;  any but newline = any char - ( \u0026#34;\\n\u0026#34; | \u0026#34;\\r\u0026#34; ) ;  nonquote = any char - \u0026#39;\u0026#34;\u0026#39; ;  digits = \u0026#34;0\u0026#34; | \u0026#34;1\u0026#34; | \u0026#34;2\u0026#34; | \u0026#34;3\u0026#34; | \u0026#34;4\u0026#34; | \u0026#34;5\u0026#34; | \u0026#34;6\u0026#34; | \u0026#34;7\u0026#34; | \u0026#34;8\u0026#34; | \u0026#34;9\u0026#34; ;  literalInteger = digits  literalString = quote nonquote quote ;  literalStrings = literalString { literalString } ;  markdownLine = verticalBar, any but newline, newline ;  markdownLines= markdownLine { markdownLine.rep(1)) } ;  docBlock = (open, (markdownLines | literalStrings), close) | literalString ;  optionalNestedContent(content) = open [ content ] close ;  brief = \u0026#34;brief\u0026#34;, [ ( literalString | docBlock ) ] ;  details = \u0026#34;details\u0026#34;, [ (literalString | docBlock) ] ;  items = \u0026#34;items\u0026#34;, [ \u0026#34;(\u0026#34;, literalString \u0026#34;)\u0026#34; ],  open, { identifier, \u0026#34;is\u0026#34;, docBlock), close ;  citations = \u0026#34;see\u0026#34;, docBlock ;  as = \u0026#34;as\u0026#34; | \u0026#34;by\u0026#34;;  detailedDescription = brief, details, items, citations ;  literalStringsDescription = literalStrings ;  docBlockDescription = markdownLine ;  description = ( \u0026#34;described\u0026#34; | \u0026#34;explained\u0026#34; ), as, open,  (literalStringDescription | docBlockDescription | detailedDescription),  close ;  literalDecimal = plusOrMinus, digits{digits}, \u0026#34;.\u0026#34; {digits} ;  idHeadChars = ? upper and lower case letters ? ; idTailChars = ? letters digits and underscore ? ;  simpleIdentifier = idHeadChars, { idTailChars } ;  quotedIdentifier = \u0026#34;\u0026#39;\u0026#34;, any char { any char }, \u0026#34;\u0026#39;\u0026#34; ;  identifier = simpleIdentifier | quotedIdentifier ;  pathIdentifier = identifier { \u0026#34;.\u0026#34;, identifier } ;  is = \u0026#34;is\u0026#34; | \u0026#34;are\u0026#34; | \u0026#34;:\u0026#34; | \u0026#34;=\u0026#34; ) ;  open = \u0026#34;{\u0026#34; ;  close = \u0026#34;}\u0026#34; ;  options(validOptions) = \u0026#34;options\u0026#34;, \u0026#34;(\u0026#34; validOptions{validOptinos} \u0026#34;)\u0026#34; |  \u0026#34;option\u0026#34;, \u0026#34;is\u0026#34;, validOptions ;  commandRef = \u0026#34;command\u0026#34;, pathIdentifier ;  eventRef = \u0026#34;event\u0026#34;, pathIdentifier ;  queryRef = \u0026#34;query\u0026#34;, pathIdentifier ;  resultRef = \u0026#34;result\u0026#34;, pathIdentifier ;  messageRef = commandRef | eventRef | queryRef | resultRef ;  entityRef = \u0026#34;entity\u0026#34;, pathIdentifier ;  topicRef = \u0026#34;topic\u0026#34;, pathIdentifier ;  typeRef = \u0026#34;type\u0026#34;, pathIdentifier;  actionRef = \u0026#34;action\u0026#34;, pathIdentifier ;  contextRef = \u0026#34;context\u0026#34;, pathIdentifier ;  domainRef = \u0026#34;domain\u0026#34;, pathIdentifier;  "},{"id":17,"href":"/language/hierarchy/","title":"Definitional Hierarchy","parent":"Language","content":"RIDDL utilizes a hierarchy of nested definitions. This hierarchy defines the basic structure of any Riddl specification. The list below shows this hierarchical model and also serves as a handy way to navigate the various kinds of definitions that Riddl supports.\n Root  Include Domain  Domain - yes, recursively Context  Adaptor API Entity  Action Function Feature Handler Invariant Producer State Type   Projection Saga Type   Topic  Event Command Query Result   Type Interaction      Path Identifiers     In several places in RIDDL, you may need to reference a definition in another definition. Such references are called Path Identifiers. They work a lot like a Unix file system with files (leaves) and directories (branches).\nPlease consider the following example as you read the sections below\ndomain A { domain B { context C { type Simple = String(,30) } type BSimple = A.B.C.Simple // full path context D { type DSimple = .E.ESimple // partial path entity E { type ESimple = ...C.Simple // partial path } } } } Path Identifier Syntax     Path identifiers are composed of only the names of the definitions and the period character like the one at the end of this sentence \u0026ndash;\u0026gt;. Separating the names by periods allows us to distinguish the names of the enclosing definitions that contain the definition of interest.\nFull Path Identifier     A full path starts from the root of the hierarchy and mentions each definition name until the sought leaf definition is reached. Here\u0026rsquo;s the full path identifier to the Simple type definition in the example above: A.B.C.Simple which is also used in the definition of the BSimple type\nPartial Path Identifiers     Path identifiers can be partial too. All partial path identifiers start with a period. A single period indicates the current container definition in the hierarchy, two periods indicates the container\u0026rsquo;s container, three periods indicates the container\u0026rsquo;s container\u0026rsquo;s container, and etc.\nIn the example, the definitions of both DSimple and ESimple use partial paths to name the type. For Dsimple the partial path, .E.ESimple is broken down like this:\n . - start with the current container (D) E - go to the E container in D . - current container (E) ESimple - select the type named ESimple For the ESimple example, the path is broken down like this: . - start with the current container(E) . - go to its parent container (D) . - go to its parent container (B) C - go to its child container (C) . - current container C Simple - select the type named Simple  "},{"id":18,"href":"/introduction/conventions/","title":"Documentation Conventions","parent":"Introduction","content":"This page defines the conventions we use throughout this documentation.\nRIDDL Snippets     Whenever we include RIDDL code in the documentation it will be in a fixed sized font like this:\ndomain MyDomain is { ??? } Extended Backus-Naur Form     When RIDDL grammar definitions are made, we utilize the EBNF grammar meta-language to specify the grammar. You can read about this grammar meta-language on Wikipedia For example, here\u0026rsquo;s how EBNF can define a quoted string:\nall characters = ? any utf-8 character ? ; quoted string = \u0026#39;\u0026#34;\u0026#39;, { all characters - \u0026#39;\u0026#34;\u0026#39; }, \u0026#39;\u0026#34;\u0026#39;; Notes     Whenever an incidental note needs to be presented, it will be shown in blue like this paragraph.  Recommendations     Whenever an important recommendation needs to be made it will be shown in green like this paragraph.  Warnings     Whenever a point that is often a source of confusion needs to be made, it will be shown in yellow like this paragraph.  Dangers     Whenever a point that will lead to errors or have dangerous consequences needs be made, it will be shown in red like this paragraph.  Language Definitions     Whenever an important RIDDL language definition is made, it will appear in a box like this.  "},{"id":19,"href":"/translation/hugo/","title":"Hugo Docs","parent":"Translation","content":"One of the main features of the RIDDL compiler is generating HTML documentation. The documentation enjoys the advantage of being more complete and accurate due to the compiler\u0026rsquo;s rigorous correctness validations. The riddlc compiler generates Hugo sources for conversion to Hugo by the hugo generator\n"},{"id":20,"href":"/language/hierarchy/domain/context/entity/invariants/","title":"Invariants","parent":"Entities","content":"Invariants specify rules about the state of an entity that must never be violated. Invariants typically come from business logic assertions. For example, a business axiom of a warehouse might be that the supply of a product should never be below 1. That is, the warehouse should never completely run out of a product it is storing. Reality, of course, must account for the supply running out; nevertheless specifying an invariant on the business intent may be important. This can be done in an entity with the invariant keyword:\ninvariant InSupply is { ProductState.supply \u0026gt; 0 } Invariants are checked every time the corresponding entity\u0026rsquo;s state is modified. If an invariant fails to be satisfied, the state change is aborted and an error is generated.\nSyntax     Specifying an invariant may use a variety of common conditional operators familiar to most programming languages and mathematics. The expression provided must evaluate to a boolean value, either true or false. A true value means the invariant is satisfied and a false value means the invariant is not satisfied.\nComparison Operators      = equality - The two operands must be equal: op1 = op2 != inequality - The two operands must not be equal op1 != op2 \u0026lt; less - The first operand must be less than the second operand: op1 \u0026lt; op2 \u0026lt;= less-or-equal - The first operand must be less than or equal to the second operand: op1 \u0026lt;= op2 \u0026gt; greater - The first operand must be greater than the second operaond: op1 \u0026gt; op2 \u0026gt;= greater-or-equal = The first operand must be greater than or equal to the second operand: op1 \u0026gt;= op2  Logic and Grouping Operators      and - conjunction - Both operands must evaluate to true: op1 and op2 or - disjunction - Either operand must evaluate to true: op1 or op2 not - inverse - The inverse boolean value of the only operand: not op1 () - grouping - Parentheses are used to group operands into a single value: ( ... )  Operand Types      constant - Constant values like numbers and strings may be used as operands function - Function invocations that return the right type of value may be used to compare runtime computed values. state - State values of the entity can be used as operands; when multiple state objects are specified, the name of the object must be used with the name of the field, separated by a period.  "},{"id":21,"href":"/language/","title":"Language","parent":"Introduction","content":"Overview     This section describes the RIDDL syntax. RIDDL is aimed not at software developers but business analysts, domain experts, and system architects. It tries hard to be readable in English and not overly technical while still retaining the ability to be precise, concise and specific. The principles of Domain Driven Design are upheld while some details have been changed or adapted specifically for implementation purposes (since code must be generated from the RIDDL definitions). Thus, RIDDL is opinionated and specific. It does not attempt to solve every kind of computing problem nor even every kind of knowledge domain. Several distributed software architecture patterns have been adopted as natural extensions of domain driven design.\nSections      Conventions - This section covers the language conventions that riddl adheres to. Common - This section describes first the kinds of definitions Hierarchy - This section  "},{"id":22,"href":"/language/hierarchy/domain/streaming/pipe/","title":"Pipes","parent":"Streaming","content":"Pipes are uni-directional conduits for reliably transmitting data of a particular type between the publishers and consumers attached at the ends of the pipe.\nSyntax Example     pipe WeatherForecast is { options rate(1000), paritions(7), transmits type Forecast } In the foregoing, a pipe named WeatherForecast is defined to transmit the data type named Forecast and with two options:\n rate - an expected sustained rate of 1000 data points per second partitions - a minimum number of partitions on the data of 7  Data Transmission Type     Pipes can transmit any data type that RIDDL can specify. There is only one data type that flows in a pipe. The transmission type is often used with an alternation of message types such as the commands and queries that an entity might receive.\nOptional Pipe Characteristics     Pipes may play a large role in the resiliency of a reactive system so we permit a variety of options to be specified no them. These options are intended only as advice to the translators converting the pipe into useful code. For example, a pipe may or may not need to be persistent. If a pipe has the burden of persistence removed, it is likely much more performant because the latency of storage is not involved.\npersistent     The messages flowing through the pipe are persisted to stable, durable storage, so they cannot be lost even in the event of system failure or shutdown. This arranges for a kind of [bulkhead](bulkhead pattern) in the system that retains published data despite failures on either end of the pipe\ncommitable     With this option, pipes support the notion of being commitable. This means the consuming processors of a pipe\u0026rsquo;s data may commit to the pipe that they have completed their work on one or more data items. The pipe then guarantees that it will never transmit those data items to that processor again. This is helpful when the processor is starting up to know where it left off from its previous incarnation.\npartitions(n)     For scale purposes, a pipe must be able to partition the data by some data value that is in each data item (a key) and assign the consumption of the data to corresponding members of a consumer group. This permits multiple instances of a consuming processor to handle the data in parallel. The n value is the minimum recommended number of partitions which defaults to 5 if not specified\nlossy     By default, pipes provide the guarantee that they will deliver each data item at least once. The implementation must then arrange for data items to be idempotent so that the effect of running the event two or more times is the same as running it once. To counteract this assumption a pipe can be use the lossy option which reduces the guarantee to merely best reasonable effort, which could mean loss of data. This may increase throughput and lower overhead and is warranted in situations where data loss is not catastrophic to the system. Some IoT systems can have this characteristic.\nProducers \u0026amp; Consumers     Attached to the ends of pipes are producers and consumers. These are processors of data and may originate, terminate or flow data through them, connecting two pipes together. Producers provide the data, consumers consume the data. Sometimes we call producers sources because they originate the data. Sometimes we call consumers sinks because they terminate the data.\ngraph LR; Producers -- P{{Pipe}} -- Consumers Source -- P1{{Pipe 1}} -- Flow -- P2{{Pipe 2}} -- Sink  Pipes may have multiple publishers (writers of data to the pipe) and multiple consumers (readers of data from the pipe). In fact, because of the partitioned consumption principle, there can be multiple groups of consumers, each group getting each data item from the pipe.\nSubscriptions     When a pipe has multiple consumers, they are organized into subscriptions. Each subscription gets every datum the pipe carries. Consumers attach to a subscription and there is generally one consumer per partition of the subscription. Sometimes subscriptions are known as consumer groups as is the case for Kafka.\n"},{"id":23,"href":"/examples/scenario/","title":"RBBQ Scenarios","parent":"Example","content":"Case Study     The Reactive BBQ restaurant chain has determined that their existing restaurant operations system is not suitably meeting their needs and have hired a high technology consulting company to provide some needed guidance on how they can improve their customer service, tracking, and reliability.\nWhat follows are the interviews conducted with key personnel at Reactive BBQ in order to identify the issues.\nCEO of Reactive BBQ      How would you describe your restaurants?\n Reactive BBQ is a family restaurant with 500 locations across 20 countries. We\u0026rsquo;re open for breakfast, lunch and supper. Our specialty at Reactive BBQ is our award winning Reactive Ribs, but we are also well known for our tender steaks and our slow roasted chicken. We take traditional BBQ flavours and give them a bit of a spicy punch. The customer experience at each Reactive BBQ should have the same high level of quality across the globe.\n What challenges do you face?\n The challenge is that our original system was designed for one restaurant, and as more were opened, we started moving into the cloud. We started by moving inventory management into the cloud. Then we moved the customers facing areas: reservations, ordering etc. into the same application. We created a website on top of this so that customers can place orders for pickup or delivery, but they can also make reservations online.\nAs we add more locations, the system becomes unresponsive during peak hours as it seems to be struggling to keep up with all the reservations, the servers entering orders, orders being filled, payments, all of these drag everything down to a crawl. Staff gets frustrated, customers even more so, it can take 30 seconds to make a reservation, or enter an order.\nThe Operations team attempted to address the peak time performance issue by adding more instances of the application in the cloud, but this turned out to be quite expensive, and we still see a noticeable lag in response times during peak hours.\nAnother issue is that our application seems to be brittle. When one thing goes wrong, it seems like everything else goes wrong at the same time. I keep hearing reports of outages across the board. And these outages have a huge impact on our business. In the early days, when a problem happened, it affected a single restaurant. But now that we are in the cloud, when the application becomes unavailable it can affect many restaurants or even all of them.\nWe have been forced to limit certain activities during certain times of the day. For example, during the lunch hour on the east coast we aren\u0026rsquo;t allowed to generate certain kinds of reports. The same applies for the west coast. As our operation expands into more time zones, it is become harder to find the right time to do these reports. Ideally doing an inventory report during the lunch rush shouldn\u0026rsquo;t make the system crawl.\nAnother issue is upgrades. Every time we want to upgrade the software we have to take the whole system offline. This is also affected by things like the east coast lunch rush. So again we have to look for specific windows during the day to deploy. Those windows are getting smaller, and the deployments are taking longer. Sometimes when we do an upgrade something goes wrong and the system is unavailable during the times we need it the most. This gets very expensive and very annoying.\nWe have been wanting to implement a loyalty program that requires tracking data about our customers, but our development team tells us this would be a \u0026ldquo;major refactor\u0026rdquo;, and that sounds expensive and risky. I don\u0026rsquo;t really understand the details, but it feels like adding a loyalty program to do the tracking shouldn\u0026rsquo;t be that big of a deal.\nI wanted to implement a new electronic menu for the restaurants. You know, with the tablets on the tables? I thought it would be more environmentally friendly than printing new menus every month. It would also help us follow the trends. Anyway, that apparently was problematic as well. The system that deals with the online menu is really tightly tied up with the fact that it is online and deliveries and all that. I don\u0026rsquo;t really understand the details, but apparently adapting it to work in the restaurant is apparently going to be a lot of work. I would also like to put screens in the kitchen so we could get rid of paper completely.\nCEO\u0026rsquo;s Key Details      500+ Locations Existing Cloud Infrastructure Online Delivery/Pickup Orders, Reservations Experiencing too much downtime  Due to upgrades or failures   System responds slowly Outages can be very expensive Actions being taken to \u0026ldquo;work around\u0026rdquo; the problems with the system Want to implement a loyalty program but it\u0026rsquo;s risky Want to implement electronic menus but it is also risky  Corporate Head Chef      What is your role in the restaurant?\n Corporate wants each restaurant to have a consistent experience. My job is to create new recipes to be included in the menu. I spend a lot of time trying out different ingredients and flavours to try to get the right balance for our menu. I have to be careful to stick to ingredients that we can buy in sufficient quantities. Most people think that a restaurant like ours prepares everything from scratch. Sometimes we do, but a lot of our stuff is bought premade in bulk and then shipped to the restaurants. Our Reactive BBQ sauce is a perfect example. Very few people know what goes into the sauce. Even the companies we get to prepare it don\u0026rsquo;t have all the details.\nOnce I have a new dish figured out I talk to the marketing team. They work on preparing a nice description of the dish. We also have a food photographer so I work with him to make sure that the dish looks nice and is presentable for his photos.\n What challenges do you face?\n Well, as I mentioned there is the issues with sourcing ingredients. It can be a tricky business with all of the regions we have restaurants in. That\u0026rsquo;s part of the reason why so many things have to be shipped from our warehouses. Some of our ingredients are sourced locally, but not all of them.\nWe have these crazy processes around updating the actual menus. We can\u0026rsquo;t just do it whenever we want. Menus are only updated once a month. That makes sense because there are printer costs and distribution issues we have to think about. Basically once a month, after everything is prepared, I send an email out to all the restaurants with new menu items and recipes. But then we have to coordinate with the printers to make sure they get hard copies delivered in time. And then we have to also coordinate with the website to make sure they are up to date. It becomes a bit of a hassle. Basically near the end of every month we have this flurry of activity to get everything prepared.\nHead Chef\u0026rsquo;s Key Details      Corporate Chef updates the menu once a month. Corporate Chef works with photographer on menu photographs. Corporate Chef deals with supply chain for the restaurants. Menu updates must be coordinated with printing and website.  Host      What is your role in the restaurant?\n I answer phones and record reservations. I also greet and seat guests as they arrive at the restaurant. Guests can either call, or use the website to make reservations, so it is necessary for me to consult the system before I seat customers. I also need to update the reservations system when I seat customers so that someone online can\u0026rsquo;t reserve the same table.\n What challenges do you face?\n I think the biggest problem I have is the reservations system. It seems like it is never working properly. Sometimes I try to add a reservation and it takes forever. I have customers lined up waiting for their tables and I don\u0026rsquo;t have time to be dealing with the slow software. Or I might go to look up the reservation for a customer and it takes so long to find it. The customers get frustrated and I am always apologizing to them for the slow software. Sometimes, after waiting forever for the information to come back, the system just crashes and I get nothing. Then it takes minutes or in rare cases hours for it to come back up. In the meantime I am struggling to figure out who is supposed to have a reservation and who isn\u0026rsquo;t.\nI have started printing out all the reservations periodically during the day. It helps to speed things up because I don\u0026rsquo;t have to use the software. But it doesn\u0026rsquo;t work for more recent reservations, so I end up looking at the print outs first and then only going to the software if I don\u0026rsquo;t find the person on the sheet.\nHost\u0026rsquo;s Key Details      Host takes reservations in person or via phone Reservations can also be made online Host seats reservations as well as walk ins. Reservation system is unresponsive System often fails Printouts being used to deal with the failures of the software  Server      What is your role in the restaurant?\n I greet guests at their table, help them understand the menu and make recommendations, then take their food and drink orders. After taking their order I input it into our computer system. When the order is ready I pick it up from the kitchen or bar and deliver it to the table.\nWhen the guest is finished, I present the bill and settle at the table. At the end of the shift I pay out my cash bills to the restaurant, bundle and submit my receipts and collect my tips.\n How do you know which prepared order from the kitchen/bar is for which table?\n Orders are input into the computer system with the table number, the prepared order is presented with a printout including the table number.\n How do you settle a bill at the table?\n Guests can pay with cash or card.\n How do you track how much you\u0026rsquo;ve made in tips for a shift?\n Our computer system keeps track of that for me and gives me a total at the end of the shift.\n What challenges do you face?\n During peak times things can get a little hectic. Entering orders seems to take longer when we get busy. We have a limited number of computer terminals to enter the information into, so as things slow down the other servers start to line up to enter their orders. We have asked for more terminals, but apparently they are really expensive so they won\u0026rsquo;t give us more.\nSome of us have tried going around the system and just asking the kitchen to start making something before we enter the order, but the cooks really don\u0026rsquo;t like when we do that. They say it\u0026rsquo;s too hard for them to keep track so they want us to use the computer.\nServer\u0026rsquo;s Key Details      Server enters orders into the system. Server collects orders from the kitchen and delivers it to the table. Server delivers bills to the tables and collects payments. Server helps customers to understand the menu choices. Software tracks tips etc. System slows down when it\u0026rsquo;s busy. Servers bottleneck on using the computers. Kitchen doesn\u0026rsquo;t like servers working around the system.  Bartender      What is your role in the restaurant?\n I take drink orders at the bar and entertain the guests. I mix the drinks and take them to the customers when they are ready. When the customer is done for the day I help them settle their tab.\nI also mix drink orders for the servers in the restaurant. The servers deliver those drinks. I just get them ready and leave them on a tray with the table number so the servers know where they go.\nAt the end of a shift I cash out with the restaurant and take my tips.\n What challenges do you face?\n Sometimes drink orders will sit for a really long time. When a drink is ordered a ticket prints out at my station and I usually make it right away. But the servers get busy, or they forget to check for the order. The drink ends up sitting on the counter for a while before they are able to come and get it. This means the ice is melting and it can really ruin a good drink.\nIt would be nice if there was a way to let the server know that their order is ready. Sometimes I end up looking around and trying to signal them if the drink has been sitting for a while, but they aren\u0026rsquo;t always easy to track down because they might be busy talking to customers. It would be nice if there was some way to get someone else to deliver the drinks. I would do it, but I am not allowed to leave the bar unattended.\nBartender\u0026rsquo;s Key Details      Bartender takes drink orders at the bar. Bartender prepares drinks for customers at the bar. Bartender delivers drink orders to customers at the bar. Bartender collects payments for the customers at the bar. Bartender prepares drinks for tables to be taken out be the servers. Collect tips, similar to the server. Would like a way to notify servers when something is ready.  Chef      What is your role in the restaurant?\n I oversee the entire kitchen and all of its staff. I source local ingredients required to prepare our menu items. The menu is decided on monthly and distributed via email. I inspect all prepared orders that leave the kitchen.\n What challenges do you face?\n I think the worst thing is when the system that prints our orders goes haywire. Sometimes the system crashes and orders get lost. While it is down we don\u0026rsquo;t know what needs to be made. The servers have to resort to handwritten tickets and it\u0026rsquo;s sometimes difficult to read their writing. Some of it is really just gibberish. It results in a lot of orders getting missed or getting made improperly.\nThe servers complain a lot about the system being slow, but we don\u0026rsquo;t really see that in the kitchen. Once they enter an order it usually prints out right away as long as the system is working.\nChef\u0026rsquo;s Key Details      Chef sources local ingredients for the menu. Chef inspects all orders that leave the kitchen. Orders get lost when the system fails. Handwritten tickets are a pain.  Cook      What is your role in the restaurant?\n Depending on the day, I work at different stations in the kitchen. The chef tells me where I will be working for that day. I prepare orders according to the tickets that get printed out at my station. Once an order is ready, I take it over to a station where we gather all the pieces of that order. The chef then approves it and we notifiy the server that their order is ready.\n What challenges do you face?\n Handwritten tickets. Man do I hate those things. We have this one server that writes in this horrible chicken scratch. Every time he brings me these tickets, I have to get her to explain to me what she has written. It\u0026rsquo;s just awful.\nThen there is the server\u0026rsquo;s attitudes. It\u0026rsquo;s pretty good most of the time, but when things get busy they start to get really annoying. When they get frustrated they kind of take it out on us in the kitchen. They start yelling about their orders taking too long. I try to explain to them that there are other orders that came first and I have to do them before I can get to theirs, but it doesn\u0026rsquo;t help. They end up storming off. I hear them talking sometimes like it\u0026rsquo;s our fault somehow.\nCook\u0026rsquo;s Key Details      Printed Ticket provide details on orders to be prepared. Handwritten tickets are a pain. Servers are frustrated.  Delivery Driver      What is your role in the restaurant?\n I deliver for five locations around the city. We don\u0026rsquo;t get a lot of deliveries. We aren\u0026rsquo;t a pizza place after all. but our wings and ribs are popular delivery options. I am on call for each of the delivery locations. If one of them gets a delivery, I get a notification on my phone. I go pick up the food from the location nearest the customer. Then I drive to the customer, and deliver their food. I collect their payment if necessary. Sometimes they pay online. In that case I don\u0026rsquo;t have to do much, just drop off the food.\n What challenges do you face?\n You mean other than traffic and customers annoyed with the delivery times? I think the app they give me is probably my biggest headache. I have this app on my phone. When I get a delivery it notifies me. It gives me all the details about the order and the customer. I also have a dongle that I attach to my phone that allow me to collect credit/debit payments.\nThe problem is that sometimes it doesn\u0026rsquo;t work. I will be on the way to a customer site when suddenly it just stops. I get some error like \u0026ldquo;unable to communicate with server\u0026rdquo; or something. When that happens I lose everything. I don\u0026rsquo;t have access to the customer address or their order. Thankfully they always print that information out on the bill before the delivery so I can still use that. But then when I go to collect the payment I end up having to use one of those old credit card swipe machines. The manual ones that take an imprint of the card. That doesn\u0026rsquo;t work if the customer planned to pay with debit though. In those cases I am out of luck.\nApparently they are going to start offering customer loyalty cards as well. They tell me that those will go through the same app. That just sounds like more headache. So now when the system goes down I am going to have to write down the customer\u0026rsquo;s loyalty number, and then enter it when manually when the system comes back up.\nDelivery Driver\u0026rsquo;s Key Details      Driver gets notifications through the app on their phone. Driver picks up orders and delivers them to the customer. Driver collects payments. Workarounds for unreliable software in the form of printed receipts.  Online Customer      Describe how you place an order online with Reactive BBQ\n Well, I go to the website and they have their menu there. I have a look at the menu and decide what I want. The menu is organized into different sections, like lunch, dinner, appetizers, dessert, that sort of thing. The menu online isn\u0026rsquo;t identical to what I get in the restaurant, but it\u0026rsquo;s pretty close. I have also done it through the phone app they have.\nAs I find things that I want, I add them to my order. Then when I have everything I want, I checkout.\nTo checkout I have to give them some information, like the delivery address, my phone number, that sort of thing. I also have to give them my credit card information so that I can pay for it. I order pretty often though, so they have all of that stuff on file already. I just enter my username and password. Once that is done, I finish the order and then I have to wait.\n And what happens when your food is delivered?\n The driver brings the food to the door. They hand me the food. I usually pay online. I love that when they come to the door, I don\u0026rsquo;t have to give them money. I can enter a tip online too so that I don\u0026rsquo;t have to give them anything, but it always feels a bit weird to tip them when they haven\u0026rsquo;t delivered the food yet. If I have cash I will often pay for the food online but then give them the tip in person. I live pretty far away and it\u0026rsquo;s a bit of a drive for them, so I usually tip them pretty well. I like to see their smile when I give it to them in person.\n Do you ever order pickup?\n Sometimes. I order pickup once in a while and just grab it on my way home from work. I can still order online so I usually do that, and then I just choose pickup instead of delivery. Sometimes, if I am away from my computer, I will just phone them and order something instead.\n Do you ever have trouble ordering online?\n Sometimes. Their website and app aren\u0026rsquo;t always working. Or if it is working it can be really slow. I don\u0026rsquo;t mind waiting when it\u0026rsquo;s slow, unless I am in a hurry or really hungry. But when it doesn\u0026rsquo;t work at all, I usually just don\u0026rsquo;t bother. When that happens I will usually just order from the other place down the street. The food isn\u0026rsquo;t as good, and their website is kind of hard to use, but it gets the job done in a pinch.\n Have you ever used the online reservation system?\n I have used it once or twice. I usually eat at home so I don\u0026rsquo;t use it that often. But it has been okay when I have used it. I don\u0026rsquo;t get to pick specific tables or anything. I just give them a few details about what I want, like how many people, whether I want a booth, that sort of thing.\nOnline Customer\u0026rsquo;s Key Details      Customer adds menu items to their order through the website/app. Customer checks out when they have completed their order. Customer enters delivery or pickup information. Customer authorizes payment and tip through the website/app. Customer makes reservations through the website/app. Website/app doesn\u0026rsquo;t always work, forcing customer to go elsewhere.  "},{"id":24,"href":"/language/hierarchy/domain/story/","title":"Story","parent":"Domains","content":"A story is a domain definition the defines an agile user story. This is the same concept that Kent Beck popularized in the early 2000s with eXtreme Programming. In RIDDL, a story is composed of the following things:\n An role specification giving the role played by the narrator of the story A capability specification giving the capability used by the narrator A benefit specification providing the reason why the narrator wants to use the capability A accepted by specification expressed as Gherkin examples that defines done. A implemented by specification that links the story to the various RIDDL definitions involved in the implementation of this story  Example     story WritingABook is { role is \u0026#34;Author\u0026#34; capability is \u0026#34;edit on the screen\u0026#34; benefit is \u0026#34;revise content more easily\u0026#34; accepted by { example one { given \u0026#34;I need to write a book\u0026#34; when \u0026#34;I am writing the book\u0026#34; then \u0026#34;I can easily type words on the screen instead of using a pen\u0026#34; } described by \u0026#34;nothing\u0026#34; example two { given \u0026#34;I need to edit a previously written book\u0026#34; when \u0026#34;I am revising the book\u0026#34; then \u0026#34;I can erase and re-type words on the screen\u0026#34; } described as \u0026#34;nothing\u0026#34; } implemented by { ??? } } described as \u0026#34;A simple authoring story\u0026#34; "},{"id":25,"href":"/language/hierarchy/domain/context/saga/","title":"Saga","parent":"Bounded Contexts","content":"Introduction     A Saga defines a way for an external application to invoke a distributed transaction via the Saga Pattern. Sagas are necessary in distributed services that use the Database per Service Pattern, like RIDDL. The Saga Pattern definition describes the context in which Sagas are used:\n You have applied the Database per Service pattern. Each service has its own database. Some business transactions, however, span multiple service so you need a mechanism to implement transactions that span services. For example, lets imagine that you are building an e-commerce store where customers have a credit limit. The application must ensure that a new order will not exceed the customers credit limit. Since Orders and Customers are in different databases owned by different services the application cannot simply use a local ACID transaction.\n The goal of a saga is to define a function across multiple entities that must atomically succeed with state changes, or fail with no state changes. So, a saga defines a set of commands to send to incur changes on entities, and a set of commands to undo those changes in case it cannot be atomically completed.\nSagas are very like functions but they only involve the sending of commands to entities. Sagas generally involve one or more different kinds of entities, or multiple entities of the same kind.\nExample     saga AllOrNothing is { options(parallel) requires { p1: String, p2: String } yields { result: String } action Step1 for entity Thingy is { command DoIt reverted by UnDoIt as { example One is { then \u0026#34;pass p1 to entity Thingy with DoIt\u0026#34; } } } action Step2 for entity Thingy is { command CheckIt reverted by UnCheckIt as { example One is { then \u0026#34;pass p2 to entity Thingy with CheckIt\u0026#34; and \u0026#34;yield the result from the reply from Thingy\u0026#34; } } } } defines saga, AllOrNothing, with two input parameters, an output string, and two steps to be done in parallel.\n"},{"id":26,"href":"/translation/bast/","title":"Binary AST","parent":"Translation","content":"When the riddlc compiler parses a RIDDL document, it translates it to an Abstract Syntax Tree (AST) in memory. The AST is then used by other passes to validate and translate the AST into other forms. The binary AST (BAST) translator converts the AST in memory into a binary format that is stored for later usage. Saving the BAST format and then reading it back into the compiler avoids the time to both parse the RIDDL document and validate it for consistency.\nConsequently, the riddlc offers a translator from validated AST to BAST format and the ability to read BAST files instead of RIDDL files. The content of a BAST file must contain a valid domain definition from which portions can be imported with the import keyword like this:\nimport domain Kitchen from \u0026#34;rbbq.bast\u0026#34; "},{"id":27,"href":"/introduction/compilation/","title":"Compilation","parent":"Introduction","content":"Introduction     The Riddl compiler performs several functions which are described in this section. There are several phases, as described in the following sections.\nLexical Analysis     Riddl uses the excellent fastparse library by Li Haoyi. This phase parses the raw textual input to make sure it is syntactically correct. From that syntax, an abstract syntax tree (AST) is produced. Incorrect syntax leads to errors without further analysis.\nStructural Analysis     The Riddl AST is scanned to identify all the definitions (things with names), create a symbol table from those names, and deduce the containment hierarchy of the model defined by the AST.\nValidity Analysis     The Riddl AST is very flexible. It can accept a wide range of input, even input that doesn\u0026rsquo;t make logical sense. For example, suppose you wrote this:\nentity MyLittlePachyderm {  state: {  thing: SomeType  } } This defines an entity with a value, thing, in its state of type SomeType. The specification does not define SomeType and it is not recognized as one of the pre-defined types. Logically then, we don\u0026rsquo;t know the type of thing so our specification is incomplete.\nValidation is the process of finding all such omissions as well as:\n references to undefined things, references to existing things of the wrong type, constructs that may be confusing, deviations from stylistic conventions definitional inconsistencies and, etc.  The validation phase generates messages that identify the omissions and inconsistencies in the input specification. These validity issues typically stop the compiler from proceeding because using an invalid input model tends to produce output that flawed and not useful.\nTranslation     A RIDDL AST, having been successfully analyzed for structure and validity, is ready to be translated into another form, which is the point of all this bother in the first place.\nRIDDL supports translation to:\n Hugo Websites - Complete documentation of the RIDDL model with structural diagrams to facilitate rapid comprehension. Akka - An implementation of the model. Anything else you like since RIDDL code generators are extensible.  "},{"id":28,"href":"/grammar/domain/","title":"Domain","parent":"Grammar","content":"See domains for examples and explanations of the following grammar productions\n(* RIDDL EBNF Grammar for knowledge domains *)  domain include = \u0026#34;include\u0026#34;, literalString  domain content = typeDef | topic | interaction | context | domain | domainInclude  domain = \u0026#34;domain\u0026#34;, identifier, \u0026#34;is\u0026#34;, \u0026#34;{\u0026#34;, (undefined | domainContent), \u0026#34;}\u0026#34;, description  "},{"id":29,"href":"/language/common/examples/","title":"Examples","parent":"Common","content":"RIDDL uses Gherkin examples in various places to express a functionality or behavior requirement on the definition that uses it. Gherkin examples are used in these places:\n Adaptors Entity Handlers Functions Processors Saga Actions Story  Structure     Gherkin is a language developed by SmartBear Software, a vendor of software quality tools, for the cucumber testing system. RIDDL uses a subset of the language as SmartBear has defined it. Four constructs are used in RIDDL:\n GIVEN - A description of the scenario, environment, or setting of the example WHEN - A condition that must be true for this example to be applicable THEN - An action, or set of actions, that are to be performed BUT - An action, or set of actions, that are not to be performed  Example     example AllDone is { Given \u0026#34;I am out shopping\u0026#34; And \u0026#34;I have eggs\u0026#34; And \u0026#34;I have milk\u0026#34; And \u0026#34;I have butter\u0026#34; When \u0026#34;I check my list\u0026#34; Then \u0026#34;I don\u0026#39;t need anything\u0026#34; } "},{"id":30,"href":"/language/hierarchy/domain/streaming/processor/","title":"Processors","parent":"Streaming","content":"As the name indicates, a RIDDL processor definition specifies the inputs and outputs of some processor of data. The inputs to the processor are declared with inlet statements and the outputs from the processor are declared with outlet statements.\nInlets     An inlet statement in the definition of a processor provides the name and data type for an input to the processor. There can be multiple inlets to the processor but each one must have a separate inlet statement. A processor with no inlets defined is called a source since it originates data and only has an outlet.\nOutlets     An outlet statement in the definition of a processor provides the name and data type for an output of the processor. There can be multiple outlets to the processor but each noe must have a separate outlet statement. A processor with no outlets is called a sink since it terminates data and only has an inlet.\nKinds Of Processors     RIDDL supports six kinds of processors that are used as the keyword to introduce the processor. The kind of processor depends solely on the number of inlet sand outlets that are defined. The keyword used ensures RIDDL knows how to validate the intention for the number of inlets and outlets.\n   # of Inlets # of Outlets Kind Description     0 1 Source Sources originate their data, and publish it to an outlet   1 0 Sink Sinks terminate their data, and consume it from their inlet   1 1 Flow Flows transform their data from inlet to outlet   1 any Split Splits their data from one source to multiple outlets   any 1 Merge Merges their data from multiple intles to a single outlet   any any Multi Any other combination is a many-to-many flow    Syntax Examples     source GetWeatherForecast is { outlet Weather is type Forecast } explained as \u0026#34;This is a source for Forecast data\u0026#34; flow GetCurrentTemperature is { inlet Weather is type Forecast outlet CurrentTemp is type Temperature } explained as \u0026#34;This is a Flow for the current temperature, when it changes\u0026#34; sink AttenuateSensor is { inlet CurrentTemp is type Temperature } explained as \u0026#34;This is a Sink for making sensor adjustments based on temperature\u0026#34; The above example shows the definition of three processors of different types. GetWeatherForecast is a source of data that generates weather forecast data as type Forecast. Presumably, that data could be used as the input to the flow named GetCurrentTemperature which takes the forecast and puts out temperate changes as indicated by the latest Forecast received. Finally, the AttenuateSenso processor is a sink of data that makes adjustments to a sensor\u0026rsquo;s attenuation based on the temperature.\n"},{"id":31,"href":"/language/hierarchy/domain/context/projections/","title":"Projections","parent":"Bounded Contexts","content":"Introduction     A projection is a read-only view of entity information. Projections are necessary since entities use event sourcing which is not a query-friendly format.\nHere\u0026rsquo;s the projection process. Usually, events are logged as they are kept appended at the end of the log file. Logs are string and text. To retrieving meaningful information out of logs, logs are transformed into a more query-friendly format and stored in queriable repository or DB.\n"},{"id":32,"href":"/examples/reactivebbq/","title":"Reactive BBQ","parent":"Example","content":"domain ReactiveBBQ is { author is { name: \u0026#34;Reid Spencer\u0026#34; email: \u0026#34;reid@reactific.com\u0026#34; organization: \u0026#34;Reactific Software LLC\u0026#34; title: \u0026#34;President\u0026#34; url: http://reactific.com/ } include \u0026#34;restaurant/domain\u0026#34; include \u0026#34;backoffice/domain\u0026#34; include \u0026#34;corporate/domain\u0026#34; } explained as { |{{\u0026lt; figure src=\u0026#34;/images/RBBQ.png\u0026#34; \u0026gt;}} |A domain to encapsulate the entire enterprise named Reactive BBQ. |It is divided into three subdomains: |* Restaurant -- handles each of the restaurant locations |* Back Office -- handles all the back office supplies and menus |* Corporate -- handles the corporate web site, marketing, accounting and HR |This domain definition is designed to be instructive in the RIDDL language. |It uses the case study from the Lightbend Reactive Architecture course as |the basis for defining the domain. The course uses a set of interviews with |Reactive BBQ employees and customers to define the requirements. This domain |specification is a possible result of analyzing that domain: the Reactive BBQ |restaurant. }  Everything in RIDDL revolves around creating domains and subdomains. These are logical groupings of definitions that belong together, presumably because they mimic and organizations structure or some other logical, real world groupings. Domains can be nested.\nAt this top level of definition we can see that a single domain named ReactiveBBQ represents the entire enterprise. The details of that top level domain is abstracted away via three include statements within its body, one for each of the subdomains:\n Restaurant Back Office Corporate  "},{"id":33,"href":"/language/common/types/","title":"Types","parent":"Common","content":"Introduction     The RIDDL language allows users to define data types. Definitions of types are more limited in RIDDL than in programming languages on purpose. The type system must be easily understandable by non-programmers as the domain engineer or domain expert is likely the most frequent user.\nPredefined Types     RIDDL supports several predefined types that just \u0026ldquo;exist\u0026rdquo; because they are fundamental and well understood in any targeted computing environment. These predefined type names can be used anywhere that a type definition is needed, for example in a field of an entity\u0026rsquo;s state definition see here\nThe predefined types are:\n String - a sequence of characters of any length Boolean - a binary value for true/false logic Number - a numeric value either integer or decimal Integer - a numeric value that excludes fractional parts Decimal - a numeric value that includes fractional parts Real - a real number Id - a globally unique identifier Date - a date value Time - a time of day value DateTime - a date and a time value together TimeStamp - a date and time combined with at least millisecond accuracy Duration - the amount of time between a start and stop time LatLong - a position on earth Nothing - a type that cannot hold a value URL - a uniform resource locator of any scheme  Named Type Definitions     In addition to the predefined types, RIDDL supports the definition of new types using a name and a type expression with this syntax:\ntype name = \u0026lt;type-expression\u0026gt; When defining values, one must use a named type defined with the type keyword. This enforces legibility by naming every type expression.\nType Expressions     RIDDL supports a variety of type expressions for defining named types. The following sections define the kinds of expressions allowed.\nRenames     It is possible to rename a predefined or previously defined type as another type name. This is common to increase domain applicability of the name of a predefined type. For example,\ntype FirstName = String // rename a predefined type for clarity might be used to make it clear that the intended use of the String value is to provide a person\u0026rsquo;s first name.\nBounded Strings     The predefined types allow use of unbounded strings but when you want to fix the minimum or maximum length of a string, it may only be used in a type expression. The expression String(\u0026lt;min\u0026gt;, \u0026lt;max\u0026gt;) can be used to define such a type. Both \u0026lt;min\u0026gt; and \u0026lt;max\u0026gt; are optional. \u0026lt;min\u0026gt; defaults to 0, and max defaults to infinite. For example;\ntype FirstName = String(2, 30) // string between 2 and 30 chars inclusive type LastName = String(,30) // string between 0 and 30 chars type Unbounded = String(,) // unbounded, same as just \u0026#34;String\u0026#34; Patterns     When you need a string to conform to a regular expression, you can use the Pattern type expression. The expression Pattern(\u0026lt;regex\u0026gt;) will define a string that validates its content according to \u0026lt;regex\u0026gt; which must be a quoted Scala regular expression. If assignment to the string does not match the\u0026lt;regex\u0026gt; then an InvalidateEstateException will be generated. For example, here\u0026rsquo;s a pattern for extracting the three components of a North American telephone number:\ntype NATelephoneNumber = pattern(\u0026#34;\\(?([0-9]{3})\\)?-?([0-9]{3})-?([0-9]{4})\u0026#34;) Range     The predefined types allow the use of unbounded integers but when you want to constrict the range of values, you need a Range type expression. The expression Range(\u0026lt;min\u0026gt;,\u0026lt;max\u0026gt;) will define an integer value whose range is restricted to the \u0026lt;min\u0026gt; and \u0026lt;max\u0026gt; values provided. As with bounded strings, the \u0026lt;min\u0026gt; and \u0026lt;max\u0026gt; values are optional and default to 0 and infinity respectively. For example:\ntype Percent = range(,100) // only value 0 to 100 inclusive Restricted Scheme URL     The predefined types allow the use of any URL, but when you want to restrict the URL to a specific scheme (e.g. \u0026ldquo;http\u0026rdquo;, \u0026ldquo;mailto\u0026rdquo;) then you can use the URL type expression. The expression URL(\u0026lt;scheme\u0026gt;) specifies a URL that is restricted to the \u0026lt;scheme\u0026gt; specified. For example:\ntype HTTPS_URL = url(\u0026#34;https\u0026#34;) Unique Identifier     To define a type that uniquely identifies a runtime entity the Id type expression can be used. It requires a pathIdentifier parameter which specifies the full path (from the root domain) to the runtime entity. For example:\ntype ModelXRef = Id(Autos.Tesla.ModelX) Enumeration     An enumeration defines a type that may take the value of one identifier from a closed set of constant identifiers using the any keyword and the set of identifiers enclosed in square brackets, like this:\ntype Color = any of [Red, Orange, Yellow, Green, Blue, Indigo, Violet] Alternation     A type can be defined as any one type chosen from a set of other type names using the select keyword followed by type names separated by |, like this:\ntype References = select String | URL There must be at least two types in an alternation.\nAggregation     A type can be defined as an aggregate of a group of values of types. DDD calls this a \u0026ldquo;value object\u0026rdquo;. Aggregations can be nested, even recursively. Each value in the aggregation has an identifier (name) and a type separated by a colon. For example, here is the type definition for a rectangle located on a Cartesian coordinate system at point (x,y) with a given height and width:\ntype Rectangle = { x: Number, y: Number, height: Number, width: Number } Key/Value Mapping     A type can be defined as a mapping from one type (the key) to another type (the value). For example, here is a dictionary definition that maps a word (lower case letters) to a type named DictionaryEntry that presumably contains all the things one would find in a dictionary entry.\ntype dictionary = mapping from Pattern(\u0026#34;[a-z]+\u0026#34;) to DictionaryEntry Messages     An aggregate type (value object in DDD) can be declared to be one of four kinds of message types using the command, event, query, and result keywords. These type definitions are useful for sending messages to entities or across pipelines.\nFor example, here is a command definition:\ntype JustDoIt = command { id: Id(AnEntity), encouragement: String, swoosh: URL } Cardinality     A type expression can be adorned with a symbol (adopted from regular expressions) that specifies the cardinality of the type, as follows:\n ? - optional, 0 or 1 instances * - zero or more instances + - one or more instances  Without the adornment, the cardinality is \u0026ldquo;required\u0026rdquo; (exactly one). For example, in this:\ntype MyType = { ids: Id+, name: String? } the MyType type is an aggregate that contains one or more Id values in the ids field and an optional string value in name\n"},{"id":34,"href":"/language/common/expressions/","title":"Expressions","parent":"Common","content":"RIDDL allows expressions to be specified in various places. Most frequently they are the operands to message constructors and when clauses in Gherkin examples. This page shows you what you can do with expressions in RIDDL.\nExpressions     Expressions compute values of arbitrary types. Since RIDDL is not a programming language, the syntax used for expressions is minimal and abstract. There is no attempt in RIDDL to be computationally complete. Supporting expression is merely for the convenience to requirements writers.\nConditional Expressions     Conditional expressions, or just conditionals, are expressions that can only evaluate to a boolean value. These are used in places where a conditional value is expected, like in a when clause in a Gherkin example. While any expression value can be considered a conditional, there are several operators (or, and, not and the six comparison operators) that will only yield a conditional value. Arithmetic operators are not considered conditional expression. Function call, field selection, and arbitrary expressions are considered conditionals.\nLISP Style Prefix Syntax     RIDDL expressions uses prefix syntax. That is the name of each operator comes first (prefix) and its arguments follow within parentheses and comma separated. For example:\nsqrt(+(4,*(3,@MyState.numberField))) This expression says multiply 3 by the value of \u0026ldquo;MyState.numberField\u0026rdquo; (presumably a numeric field in the state named \u0026ldquo;MyState\u0026rdquo;), add 4 to that, then take the square root of that sum. Note that \u0026ldquo;sqrt\u0026rdquo;, \u0026ldquo;+\u0026rdquo; and \u0026ldquo;*\u0026rdquo; and \u0026ldquo;@\u0026rdquo; are all operators. In the case of @, no parentheses are required.\nOperators     In the subsections below we will discuss each of the operators that are defined by RIDDL.\nUndefined Expression: ???     If you don\u0026rsquo;t know what expression is needed, just use RIDDL\u0026rsquo;s undefined operator, which is ???. This can be considered a placeholder for future definition.\nArbitrary Expression: \u0026ldquo;expression\u0026rdquo;     RIDDL allows an arbitrary expression which is just a quoted string. When you don\u0026rsquo;t have time, inclination or the details of a computation, just describe it in text. For example:\nexample Foo { when \u0026#34;conditions are right\u0026#34; then set State.Field to \u0026#34;the correct value\u0026#34; } In this example, two \u0026ldquo;arbitrary\u0026rdquo; expressions are used:\n conditions are right presumably resolves to a conditional (boolean) value \u0026quot;the correct valuepresumably resolves to a value compatible with the type of the fieldState.Field`  Value Selection: @     The @ operator selects the value of a named thing in the RIDDL definition. The @ is followed immediately by a path identifier such as Domain.Context. Entity.State.Field. The path identifier chosen must specify something that holds a value, for example the fields in a state definition or the message of an on clause (in a handler).\nArithmetic: +, -, / *, %, name     Arithmetic values perform computations. The usual five arithmetic operators, + - / * % are permitted and they each take two arguments. Additionally, any function name in all lower case, with 0 or more arguments can be used. The function name is not checked except that it must be in all lower case. For example, sqrt(n), log(n), empty(@list) are all valid expressions.\nFunction Call: Path.To.Function(arg1=expression,\u0026hellip;)     An expression may invoke a RIDDL defined function to obtain the expression\u0026rsquo;s value. To make such an invocation, a path identifier is used to locate the function to be invoked and each of its arguments must be supplied between parentheses. Arguments in a function call must be named, unlke in an arbitrary arithmetic operator. For example:\nfunction A { requires { i: Integer} yields { j: Integer } A(i=3) This invokes function A with the required value 3 for \u0026ldquo;i\u0026rdquo; parameter\nComparison Condition: \u0026lt;, \u0026lt;=, ==, !=, \u0026gt;=, \u0026gt;     The typical six comparison operators are supported. Each takes two operaonds only and compares them in different ways. The result is a conditional, true or false, depending on how the two values compare. The operators are:\n \u0026lsquo;\u0026lt;\u0026rsquo; - return true if operand 1 is less than operand 2 \u0026lsquo;\u0026lt;=\u0026rsquo; - return true if operand 1 is less than or equal to operand 2 \u0026lsquo;==\u0026rsquo; - return true if operand 1 is equal to operand 2 \u0026lsquo;!=\u0026rsquo; - return true if operand 1 is not equal to operand 2 \u0026lsquo;\u0026gt;=\u0026rsquo; - return true if operand 1 is greater than or equal to operand 2 \u0026lsquo;\u0026gt;\u0026rsquo; - return true if operand 1 is greater than operand 2  Logical: not, or, xor, and     Conditional expressions can be combined with the three logical operators:\n not - evaluates to the opposite of its operand, e.g. if the operand is truethen not(true) yields false. Requires exactly 1 operand. or - evaluates to true if any of its operands are true. Requires a minimum of 2 operands xor - evaluates to true if only one of its operands are true and the others are all false. Requires a minimum of 2 operands. and - evaluates to true if all of its operands are true. Requires a minimum of 2 operands.  Constants: True, False, Numbers     Constant values such as true and false (both conditionals as well), or any real, floating point, or integer number can be interpreted as expressions too.\nTernary Expression: if(condition,then,else)     A computation may include the if operator with three operands. The first operand, condition, is a conditional (true/false) expression that determines whether then, an expression, is the result (condition ==true case) or then, also an expression, is the result (condition == false case).\nGroup Expression: (expression)     If if aids in clarity, you may place parentheses around an expression to group it together. With prefix operator notation, this isn\u0026rsquo;t strictly needed but is provided for convenience.\n"},{"id":35,"href":"/grammar/context/","title":"Context","parent":"Grammar","content":"DDD bounded contexts are represented in RIDDL with the context definition whose syntax is:\n(* RIDDL EBNF Grammar for bounded contexts *)  context options = options(\u0026#34;wrapper\u0026#34; | \u0026#34;gateway\u0026#34; | \u0026#34;function\u0026#34;)  context include = \u0026#34;include\u0026#34;, literalString  context definitions = typedef | entity | adaptor | interaction | contextInclude  context = \u0026#34;context\u0026#34;, identifier, is, open,  (undefined | context options, context definitions),  close, description }  "},{"id":36,"href":"/language/hierarchy/domain/","title":"Domains","parent":"Definitional Hierarchy","content":"A domain is the top definitional level in RIDDL. Domains in RIDDL are domains of knowledge, for example an entire business, or some portion of it. The language uses the concept of a domain to group together a set of related concepts. Within domains you find types, contexts, topics, and interactions.\nDomains can declare themselves as the subdomain of another domain. For example, a Car is a subdomain of the more general Automotive domain. In RIDDL you would write it like so:\ndomain Automotive { domain Cars { ??? } domain Trucks { ??? } domain Repairs { ??? } } This indicates that in the knowledge domain named Automotive there are three subdomains of interest: Cars, Trucks and Repairs.\n"},{"id":37,"href":"/language/hierarchy/domain/context/features/","title":"Features","parent":"Bounded Contexts","content":"A Feature is a requirement on a context. Features are specified very similarly to the Gherkin language. The same keywords are used and the style is more like RIDDL syntax. If you\u0026rsquo;re already familiar with Gherkin then an example should suffice:\nFeature \u0026#34;Guess the word\u0026#34; is { // The first example has two steps Scenario \u0026#34;Maker starts a game\u0026#34; is { When the Maker starts a game Then the Maker waits for a Breaker to join } // The second example has three steps Scenario \u0026#34;Breaker joins a game\u0026#34; is { Given the Maker has started a game with a word When the Breaker joins the Maker\u0026#39;s game Then the Breaker must guess a word knowing the length of the Maker\u0026#39;s word choice. } Scenario \u0026#34;Breaker makes a guess\u0026#34; is { Given the Maker and Breaker have joined the same game When the Breaker makes a guess And the guess is correct Then the Breaker wins the game And the game is over Else the Breaker may guess again } described by { |The word guess game is a turn-based game for two players. |The Maker makes a word for the Breaker to guess. The game |is over when the Breaker guesses the Maker\u0026#39;s word. } "},{"id":38,"href":"/language/common/includes/","title":"Includes","parent":"Common","content":"An include statement is not a RIDDL definition but an instruction to the compiler to lexically replace the include statement with the content of another file. The name of the file to include is the statement\u0026rsquo;s only parameter, like this:\ninclude \u0026#34;other-file.riddl\u0026#34;  The include statement is only permitted where major definitions are expected, specifically at root level, and in the bodies of domain, context, entity, and pipe definitions.\n "},{"id":39,"href":"/translation/openapi/","title":"OpenAPI","parent":"Translation","content":""},{"id":40,"href":"/language/hierarchy/domain/streaming/plant/","title":"Plants","parent":"Streaming","content":"A RIDDL plant is a definition that combines pipes with processors to specify a model of how data should flow. You may define as many plants as needed but each plant is a closed system without the ability of the RIDDL model to express the sharing of data between the plants. This is done deliberately to prevent unintentional contamination of data in large models.\nJoints     The purpose of a plant definition is to provide the blueprint for how a set of pipes, processors, and entities are joined together so that data may flow end-to-end. This is done by using:\n the names and types of inlets in processors the names and types of outlets in processors the names and content types of pipes the definition of a joint to connect pipes and processors  For example, consider this complete plant definition:\ndomain AnyDomain is { plant SensorMaintenance is { source GetWeatherForecast is { outlet Weather is Forecast } described by \u0026#34;This is a source for Forecast data\u0026#34; flow GetCurrentTemperature is { inlet Weather is Forecast outlet CurrentTemp is Temperature } explained as \u0026#34;This is a Flow for the current temperature, when it changes\u0026#34; sink AttenuateSensor is { inlet CurrentTemp is Temperature } explained as \u0026#34;This is a Sink for making sensor adjustments based on temperature\u0026#34; pipe WeatherForecast is { transmit Forecast } explained as \u0026#34;Carries changes in the current weather forecast\u0026#34; pipe TemperatureChanges is { transmit temperature } explained as \u0026#34;Carries changes in the current temperature\u0026#34; joint forecast is outlet GetWeatherForecast.Weather to pipe WeatherForecast joint temp_in is inlet GetCurrentTemperature.weather from pipe WeatherForecast joint temp_out is outlet GetCurrentTemperature.CurrentTemp to pipe TemperatureChanges joint temp_changes is inlet AttenuateSensor.CurrentTemp from pipe TemperatureChanges } explained as \u0026#34;A complete plant definition for temperature based sensor attenuation.\u0026#34; } explained as \u0026#34;Plants can only be specified in a domain definition\u0026#34;  In other words, the above plant definition produces this kind of data pipeline: graph LR; subgraph GetWeatherForecast subgraph Weather:outlet end end subgraph GetCurrentTemperature subgraph Weather:inlet end subgraph CurrentTemperature:outlet end end subgraph AttenuateSensor subgraph CurrentTemperature:inlet end end Weather:outlet --|WeatherForecast| Weather:inlet CurrentTemperature:outlet --|TemperatureChange| CurrentTemperature:inlet  In the diagram, the arrows represent pipes, yellow boxes represent processors and the grey boxes represent the inlet and outlet connection points.\nType Safety     Plants are entirely type safe. This means the data type that a pipe transmits must match the data type of the publishing processors (outlets) and the data types of the consuming processors (inlets). When riddlc processes a plant specification, it ensures that all the inlet and outlet data types match the data types of the connected pipes.\nIn the above example, note that each inlet/outlet pair has the same type name (Weather and CurrentTemperature).\nEntities as Processors     An entity may also be used as a processor under some special circumstances:\n as a source - An entity may be used as a source of events if a command handler is defined for the entity. as a sink - An entity may be used as a sink for events if a reaction handler is defined for the entity. as a flow - An entity may be used as a flow to convert commands into events  Bulkheads     "},{"id":41,"href":"/introduction/principles/","title":"Principles","parent":"Introduction","content":"RIDDL is a high level system specification language and as such must obey some principles of such languages. This page provides those principles.\n1: Declarative     RIDDL is not an implementation language and does not pretend to be computationally complete. RIDDL adopts this what not how principle. Details are for software developers. The analyst or architect that writes RIDDL documents wants to only specify what the system is while abstracting away the process of constructing it. It is like city planning, not the processes of laying pipes, providing power and paving roads. The end user ought to be as comfortable reading it as the developer.\nA specification is a statement of what needs to be produced, but not how it is to be realized (implemented). RIDDL specifications are aimed at modelling large, complicated knowledge domains. A RIDDL model must be complete enough that all the parts of it are recognizable and what it will do is discernable, but without understanding how it will be produced.\nConsequently, RIDDL is a declarative specification language.\n2: Both Data And Process     RIDDL models appreciate that the dichotomy between \u0026ldquo;doing\u0026rdquo; (process) and \u0026ldquo;being\u0026rdquo; (data) is false. Modern computing systems that model reality must be both in our view. Thus, strictly data-oriented specification languages nor strictly process-oriented specification languages will suffice. RIDDL must be both. While we are human beings we must also be human doings; or as Kurt Vonnegut published in \u0026ldquo;Deadeye Dick\u0026rdquo;:\n Socrates: To be is to do\nSartre: To do is to be\nSinatra: Do be do be doooo.\n 3: Completeness     The specification must provide the implementors all the information they need to complete the implementation of the system, and no more.\n4: Sufficiently Formal     A RIDDL specification should be sufficiently formal so that it can conceivably be tested for consistency, correctness, completeness, and other desirable properties. Theriddlc compiler for RIDDL input aims to achieve exactly this, automatically.\n5: Familiar Terms     The specification should discuss the system in terms that are normal and common for the users, implementors and subject-matter experts of the system. While RIDDL does introduce keywords that require some explanation (hence this documentation), one of the primary motivations for using DDD as a primary model for the language is to reinforce this principle.\n6: Rapidly Translatable     The RIDDL specification language exists to reduce the burden on system architects, business analysts, and others who must manage complexity and large volumes of concepts. Without the ability to rapidly translate the specification into other useful artifacts, the language would not have high utility. RIDDL can therefore be used to produce:\n Complete documentation websites for the model specified in RIDDL Various kinds of diagrams for better visual comprehension of the model Various kinds of code artifacts to ease the software developers burden Other artifacts through extension plugins  "},{"id":42,"href":"/examples/restaurant/","title":"Restaurant","parent":"Example","content":"domain Restaurant is { type CustomerId is Id(Customer.Customer) explained as \u0026#34;Unique identifier for a customer\u0026#34; type OrderId is Id(Order.Order) described as \u0026#34;Unique identifier for a customer\u0026#39;s order\u0026#34; type LocationId is Id(Location.Location) type LoyaltyId is Id(Loyalty.LoyaltyAccount) type OrderViewerId is Id(Kitchen.OrderViewer) type ReservationId is Id(Reservation.Reservation) type PaymentId is Id(Payment.Payment) type ServerId is Id(Server.Server) type TableId is Id(Table) include \u0026#34;Customer\u0026#34; include \u0026#34;Kitchen\u0026#34; include \u0026#34;Location\u0026#34; include \u0026#34;Loyalty\u0026#34; include \u0026#34;Menu\u0026#34; include \u0026#34;Order\u0026#34; include \u0026#34;Payment\u0026#34; include \u0026#34;Reservation\u0026#34; include \u0026#34;Server\u0026#34; include \u0026#34;Table\u0026#34; } explained as { |This subdomain pertains to all processes and data associated with a single restaurant location. |It includes several bounded contexts, as noted by the include statements above. To make the entity |Id\u0026#39;s ubiquitous for the domain, their type definitions are defined at the domain level. }  "},{"id":43,"href":"/language/hierarchy/domain/streaming/","title":"Streaming","parent":"Domains","content":"RIDDL supports the definition of complex data streaming models. There are two basic definitions involved in setting up a pipeline: a pipe, and a a processor. There are several kinds of pipes and processors, and they can be combined to form entire systems of data processing known as a plant. These metaphors come from chemical processing\nconcepts which you can visualize as something like this:\n Pipes - Pipes are conduits for reliably transmitting messages of a particular type of data from publishers to consumers of that data type that are connected to the pipe. Processors - While pipes reliably transport data from its producers to its consumers, processors are the producers, consumers, and transformers of data. Notably, entities are processors of pipes too. Plants - Plants combine pipes and processors together with support for rich semantics so that arbitrarily complex streams can be modeled in RIDDL.  "},{"id":44,"href":"/translation/","title":"Translation","parent":"Introduction","content":"The RIDDL compiler, riddlc is able to translate RIDDL into a variety of other document types.\nIt is recommended that before you delve into the types of output, become familiar with the riddlc command line and configuration options\n  The various kinds of output from riddlc are described in the following sections:\n BAST - Binary Abstract Syntax Tree Akka - Akka, protobuffers, Alpakka infrastructure code \u0026amp; skeleton Hugo - Hugo source input for producing HTML web site OpenAPI - OpenAPI (nee Swagger) specifications  "},{"id":45,"href":"/examples/backoffice/","title":"Back Office","parent":"Example","content":""},{"id":46,"href":"/grammar/entity/","title":"Entity","parent":"Grammar","content":"   (* RIDDL EBNF Grammar For Entity definition *)  entity = entity kind, \u0026#34;entity\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;{\u0026#34;,  entity options, entity definitions,  \u0026#34;}\u0026#34;, description ;  entity kind = [ \u0026#34;device\u0026#34; | \u0026#34;actor\u0026#34; | \u0026#34;concept\u0026#34;] ;  entity options = single option | multi options ;  single-option = \u0026#34;option\u0026#34;, \u0026#34;is\u0026#34;, entity option kinds;  multi-option = \u0026#34;options\u0026#34;, \u0026#34;(\u0026#34;, { entity option kinds }, \u0026#34;)\u0026#34;;  entity option kinds = \u0026#34;event sourced\u0026#34; | \u0026#34;value\u0026#34; | \u0026#34;aggregate\u0026#34; | \u0026#34;persistent\u0026#34; |  \u0026#34;consistent\u0026#34; | \u0026#34;available\u0026#34;;  entity definition =  handler | feature | function | invariant | typeDef | state;  entity definitions = entity definition { entity definition } ;  entity state = \u0026#34;state\u0026#34;, identifier, \u0026#34;is\u0026#34;, \u0026#34;{\u0026#34;, identifier, \u0026#34;is\u0026#34;, typeExpression, \u0026#34;}\u0026#34;, description  State     A state is defined with the state keyword in the content of an entity using this syntax:\nstate = \u0026#34;state\u0026#34;, identifier, \u0026#34;is\u0026#34;, aggregate, description For details see the following production descriptions\n "},{"id":47,"href":"/language/common/functions/","title":"Functions","parent":"Common","content":"Introduction     Functions are pieces of processing that can be attached to entity, consumer, and api definitions. A function has a set of inputs (its requirements) and a set of output (what it yields). Functions need not be pure and often have side effects through the state changes of an entity.\nExample     Here\u0026rsquo;s an example of a function, named riddle, that requires a Subject(String) type and returns a Riddle (String) type. Presumably, it generates a riddle in any subject.\ntype Subject = String type Riddle = String function riddle is { requires {s: Subject} yields { r: Riddle } } Applicability     Functions have applicability across several RIDDL definitions:\n Context APIs - APIs are collections of functions Entity Handler - As utilities in an entity [handler](Encapsulate repeating logic from a consumer\u0026rsquo;s on clause) Allow internal entity processing to be specified as part of an interaction etc.  Further Content: TBD\n"},{"id":48,"href":"/grammar/","title":"Grammar","parent":"Introduction","content":"This section defines the RIDDL syntax grammar using EBNF This form can be quite technical and is intended for those who are familiar with EBNF format and lexical parsing. For a more descriptive introduction to the language, please refer to the Tutorial section.\nThe RIDDL syntax grammar is broken down into the following portions:\n terminals - Terminal symbols used in the grammar common - Common grammar productions used in other files root - Top level root level (\u0026ldquo;file scope\u0026rdquo;). domain - Defining domains context - Defining contexts entity - Defining entities  "},{"id":49,"href":"/language/hierarchy/domain/context/entity/handler/","title":"Handler","parent":"Entities","content":"A handler in an entity specifies how an entity handles its input messages.\nHandlers are specified with the handler keyword and enclose a set of on clauses that specify what to do with a given event when that handler is active. There are four kinds of on clauses distinguished by the kind of message they handle (command, event, query, and reaction) as detailed in the following sections\nCommand Handler     A command handler specifies which persistent event is generated for a given command. For example:\ntype JustDoIt = command { id: Id(AnEntity), encouragement: String } type JustDidIt = event { id: Id(AnEntity), encouragement: String } on command JustDoIt yields JustDidIt Event Handler     An event handler specifies how an event modifies the state of the entity.\nstate State is { name: String } type event NameWasUpdated { id: Id(AnEntity), newName: String } on event NameWasUpdated { replace State.name with NameWasUpdated.newName } Reaction Handler     A reaction handler is used to specify how an entity converts a foreign event (from another entity in the same bounded context) into a command for altering its own state. This is also how we avoid corruption of the entity\u0026rsquo;s ubiquitous language by converting another bounded context\u0026rsquo;s concept into the handler\u0026rsquo;s entity\u0026rsquo;s concept.\ndomain Path is { domain To is { context Context is { type ThingThatHappened is event { id: Id(Entity), whatHappened: String } } } } domain Foo { context Bar { entity Example { type ExternalThingHappened = event { id: Id(Example), whatHappened: String } on event Path.To.Context.ThingThatHappened yields ExternalThingHappened } } } Notes:\n Path.To.Context.ThingThatHappend is known as a path identifier.  Query Handler     A query handler associates a query message to the result message that the query returns along with the SQL statement that yields the result set.\ntype JustGetIt = query { id: Id(AnEntity) } type JustGotIt = response { id: Id(AnEntity), count: Integer } on query JustGetIt return JustGotIt from \u0026#34;SELECT id, count FROM AnEntity WHERE id = %id\u0026#34; Defining Multiple Handlers     An entity can make use of multiple handlers so that the behavior of and entity can be changed. There can be only one handler active at any moment, but an entity can change which handler is active in response to any message. This ability permits a set of handlers to model a finite state machine where each handler is a state and each on clause is a transition. When a handler is active, any messages received that are not explicitly defined by the handler will simply be ignored.\n"},{"id":50,"href":"/language/common/interactions/","title":"Interactions","parent":"Common","content":"Introduction     An Interaction evolves from the concepts inherent in a UML Sequence Diagram. Instead of specifying those concepts in a visual way, as in UML, RIDDL specifies them in a textual way. The purpose of an interaction is to specify an important way in which the system components communicate and cooperate to accomplish a task that is valuable to the stakeholders of the system.\nAs with the UML concept, an interaction shows the message flow between system entities in time sequence. Interaction definitions are often derived from use cases, usage scenarios, work flows, or other repetitive patterns of usage of the system. Their purpose is to show the intended flow of messages in order to guide the development of the system or specify required communication between system entities.\n"},{"id":51,"href":"/language/hierarchy/domain/context/entity/functions/","title":"Function","parent":"Entities","content":"TBD\n"},{"id":52,"href":"/examples/corporate/","title":"Corporate","parent":"Example","content":""},{"id":53,"href":"/language/common/imports/","title":"Imports","parent":"Common","content":" This feature is not implemented yet.\n An import statement may be used to import a definition from a BAST file that was generated from a prior compilation. Import statements help to save time when a prior compilation has completed and been saved as a BAST file.\n"},{"id":54,"href":"/_footer/","title":"Footer","parent":"Introduction","content":"2022 Reactific Software LLC. All Rights Reserved.\n"},{"id":55,"href":"/_header/","title":"Header","parent":"Introduction","content":"RIDDL Documentation\n"},{"id":56,"href":"/privacy/","title":"Privacy","parent":"Introduction","content":"Privacy Notice     This is a static site. It does not use cookies, collects no information, and invades no privacy. This is merely a documentation site for your use.\n"},{"id":57,"href":"/contact/","title":"Contact Us","parent":"Introduction","content":"TBD\n"},{"id":58,"href":"/introduction/faq/","title":"Frequently Asked Questions","parent":"Introduction","content":" Is RIDDL a programming language? No. RIDDL is a business and system specification language based on many ideas from domain driven design and reactive system architecture. RIDDL is not computationally complete. However, its compiler is capable of producing compilable code to automate the creation of the structure of a system.\n   "},{"id":59,"href":"/search/","title":"Search Result","parent":"Introduction","content":""},{"id":60,"href":"/tags/","title":"Tags","parent":"Introduction","content":""},{"id":61,"href":"/tutorial/","title":"Tutorial","parent":"Introduction","content":"This section provides tutorials, tips \u0026amp; tricks, and how-to articles\n"}]