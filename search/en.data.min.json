[{"id":0,"href":"/","title":"Home","parent":"","content":"\nRIDDL is a language and toolset for specifying a system design using a combination of unique ideas and ideas from prior works. Before we get into the details, this documentation has multiple paths by which you can learn RIDDL, depending on how you learn.\nEveryone should read the Introduction section as it provides a high level introduction to RIDDL, defines what RIDDL is, what it can do, and what it is based upon. Definitely start with the Introduction if you\u0026rsquo;re new to RIDDL.\nThere is an Audiences section which provides learning paths for different kinds of readers, to wit:\nDomain Expert\u0026rsquo;s Guide: for knowledge domain experts who would provide concepts, structure, and event flows to a RIDDL author. Domain experts are generally not required to deal with the RIDDL language itself but do need to be familiar with its concepts and facilities. Author\u0026rsquo;s Guide: for those who will write RIDDL specifications and must know the language intricacies for full and accurate specifications. Implementor\u0026rsquo;s Guide: for those who will implement software systems based on RIDDL specifications and the output of RIDDL based tools Developer\u0026rsquo;s Guide: for those who will work on the RIDDL software itself and tools such as riddlc For those that like to learn incrementally, there is a Tutorial section which walks the reader through the construction of a RIDDL model for a restaurant chain, and the resulting software system to operate it.\nFor those that like to learn by example, the model produced in the Tutorial is presented, step-by-step, with new concepts added as they occur, in the Example section\nIf you want to dive into the technical specification for the RIDDL language, you can go to the Language section and learn the language from first principles.\nIf you want to dive into the software tools that RIDDL provides, you can go to the Tooling section and learn how to install and use them.\nIf you\u0026rsquo;re interested in knowing how we plan to extend RIDDl in the future, please review our Future Work section.\nPrivacy Policy Contact Us Search Result Audience Domain Expert\u0026#39;s Guide Author\u0026#39;s Guide Design Tips Implementor\u0026#39;s Guide Developer\u0026#39;s Guide Principles Grammar Terminals Common Domain Context Entity Releasing RIDDL Language Common Documentation Conventions Language Conventions Descriptions Identifiers Examples Types Expressions Includes Functions Imports Options Root Domain Context Entities State Options Invariants Handler Function Adaptors APIs Saga Projections Features Story Streaming Pipes Processors Plants Tooling riddlc How To Build `riddlc` Installing `riddlc` Compilation Translation riddlc options Binary AST Diagrams Hugo Docs OpenAPI Kalix Akka Other Translators Example RBBQ Scenarios Reactive BBQ Restaurant Back Office Corporate Tutorial Future Work "},{"id":1,"href":"/tooling/riddlc/translation/options/","title":"riddlc options","parent":"Translation","content":" Introduction Like many other complex programs, riddlc implements a variety of commands, each with their own functionality and their own options. As there are overlaps\nOptions come and go as riddlc evolves. If you experience issues with the command line options, you can always run riddlc without any options and it will explain the options your version supports. Common Options Some options are common to all the commands.\n-h (\u0026ndash;help) Causes riddlc to print out help and usage information and exit.\n-t (\u0026ndash;show-times) Translation is done in various stages (parsing, validating, loading, translating, etc.). This option causes riddlc to print out how long each of these stages takes\n-v (\u0026ndash;verbose) Causes riddlc to be more verbose in its output, what it is doing, etc. So far this doesn\u0026rsquo;t add any additional output but the option is reserved for this use case.\n-q (\u0026ndash;quiet) Do not print out any output, just do the requested command.\n-d (\u0026ndash;dry-run) Go through the motions of processing the options and teeing up the command to run, but don\u0026rsquo;t actually run it.\n-w (\u0026ndash;suppress-warnings) Causes all warnings to be squelched from the output. riddlc has many general warnings, lots of warnings about missing things, and even stylistic or idiomatic suggestions. This option suppresses all of them to make the output less verbose.\n-m (\u0026ndash;suppress-missing-warnings) Warnings about missing constructs are normally turned off, this option turns them back on so the messages are put out by riddlc. This can be quiet verbose in early RIDDL specifications that do not have much documentation in them.\n-s (\u0026ndash;suppress-style-warnings) Warnings about RIDDL style are normally turned off, this option turns them back on so the messages are put out by riddlc\nparse [options] Command The parse command causes riddlc to only parse the provided RIDDL file for syntactic compliance with the RIDDL language. No validation or translation is done on the input. Note that riddlc terminates after the first syntax error message has printed.\nIn addition to the common options, you can specify the options described in the following subsections.\n-i (--input-file) This is a required option that provides the file to be parsed.\nvalidate [options] Command This command does everything that the parse command does, but also semantically validates the input if parsing succeeds.\nIn addition to the common options, you can specify the options described in the following subsections.\n-i (--input-file) This is a required option that provides the file to be parsed.\nreformat [options] Command This command regurgitates its input but in a consistent style with options to affect that style in various ways.\nIn addition to the common options, you can specify the options described in the following subsections.\n-i (--input-file) This is a required option that provides the file to be parsed.\n-o (--output-dir) This is a required option that provides the directory into which the output will be placed. Generated files will have the same names as the input files.\n-s (--single-file) This option causes all the include statements in the input to be removed and the entire input generated into a single file.\nCurrently this option is forced on whether you specify the option or not. The only output supported is a single file. This will be remedied in a later release. hugo [options] Command This command causes riddlc to parse, validate and translate its input into the input needed for a hugo based website that described the RIDDL input.\nIn addition to the common options, you can specify the options described in the following subsections.\n-i (--input-file) This is a required option that provides the file to be translated to a hugo website.\n-o (--output-dir) This is a required option that provides the directory into which the hugo website source files will be placed.\n-p, --project-name \u0026lt;value\u0026gt; This options provides the hugo command with the overall name of the project that is being described by the RIDDL input. This is used in the meta tags for the title of the page, and other places where the title is needed.\n-e, --erase-output \u0026lt;value\u0026gt; Erase the entire output directory before putting out any files.\nIt is highly recommended that you use this option, but it defaults to off to prevent the new user from deleting the wrong directory structure. All files under --output-dir will be unceremoniously deleted so specifying --output-dir incorrectly can yield significant data loss. -b, --base-url \u0026lt;value\u0026gt; This option provides the first part of the URL at which the generated site is publicly accessible. It defaults to http://localhost:1313 which is the default for hugo.\n-s, --source-url \u0026lt;value\u0026gt; The generated site offers the ability to link to the source document for any page. The \u0026lt;value\u0026gt; provided must be a valid URL for a website.\nThis corresponds to the geekdoc hugo theme\u0026rsquo;s geekdocRepo parameter. -h, --edit-path \u0026lt;value\u0026gt; This option is used to extend the funtionality of the --source-url option to allow editing as well as linking to the source. This option provides the source repository\u0026rsquo;s intermediate URL path that can be used to edit a page.\n-l, --site-logo-url \u0026lt;value\u0026gt; URL to the site\u0026rsquo;s logo image for use by hugo\nhugo-git-check [options] Command This command is the same as the hugo command, and takes the same options, except you also provide a URL to a directory in a git repository. Any changes to the git repository below that direction, as reported by git, will cause the hugo command to run. Otherwise nothing happens. This allows an auto-update upon changes when combined with the repeat command.\nfrom \u0026lt;path-to-config-file\u0026gt; Command This command repeats\nrepeat \u0026lt;cycle-delay\u0026gt; \u0026lt;max-cycles\u0026gt; \u0026lt;path-to-config-file Command This command repeats whichever command is specified in the configuration file at \u0026lt;path-to-config-file\u0026gt;. It will cycle \u0026lt;max-cycles\u0026gt; times and insert a delay of \u0026lt;cycle-delay\u0026gt; which must be specified with a duration suffix like s(seconds) m(minutes), etc. The full set of possibilities are defined here\nthe input needed for a hugo based website that described the RIDDL input.\nIn addition to the common options, you can specify the options described in the following subsections.\nOptions From Configuration Files The from and repeat commands use HOCON configuration files to determine what to do. The HOCON syntax is [fully explained here](https://github. com/lightbend/config/blob/main/HOCON.md) but it is simpler than that in the case of riddlc, just follow these rules:\nAssign the command you want to run to the \u0026ldquo;command\u0026rdquo; option. All the common options can be specified at the top level. Command specific options must appear in a section named after the command. All the configuration items have the same names as the long form names that\nriddlc prints out with the help command. So, for example, to reformat a file to another file without warnings you could set up a configuration file like this:\ncommand = reformat suppress-warnings = true reformat { input-file = \u0026#34;path/to/input.riddl\u0026#34; output-dir = \u0026#34;path/to/output/dir\u0026#34; single-file = true } Similarly for other commands. You can even specify all the options for all the commands and then just change the command selector when you want to do something different. Or, put them each in separate files and use commandline completion to specify which file.\nExample of riddlc help command RIDDL Compiler (c) 2022 Reactive Software LLC. All rights reserved. Version: 0.2.1-131-f6486929 This program parses, validates and translates RIDDL sources to other kinds of documents. RIDDL is a language for system specification based on Domain Drive Design, Reactive Architecture, and Agile principles. Usage: riddlc [parse|validate|reformat|hugo|hugo-git-check|from|help|repeat] [options] \u0026lt;args\u0026gt;... -V | --version -h | --help Print out help/usage information and exit -t | --show-times Show compilation phase execution times -d \u0026lt;value\u0026gt; | --dry-run \u0026lt;value\u0026gt; go through the motions but don\u0026#39;t write any changes -v | --verbose Provide detailed, step-by-step, output detailing riddlc\u0026#39;s actions -q | --quiet Do not print out any output, just do the requested command -w | --suppress-warnings Suppress all warning messages so only errors are shown -m | --suppress-missing-warnings Show warnings about things that are missing -s | --suppress-style-warnings Show warnings about questionable input style. Command: parse [options] Parse the input for syntactic compliance with riddl language. No validation or translation is done on the input -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt; required riddl input file to read Command: validate [options] Parse the input and if successful validate the resulting model. No translation is done on the input. -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt; required riddl input file to read Command: reformat [options] Parse and validate the input-file and then reformat it to a standard layout written to the output-dir. -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt; required riddl input file to read -o \u0026lt;value\u0026gt; | --output-dir \u0026lt;value\u0026gt; required output directory for the generated output -s \u0026lt;value\u0026gt; | --single-file \u0026lt;value\u0026gt; Resolve all includes and imports and write a single file with the same file name as the input placed in the out-dir Command: hugo [options] Parse and validate the input-file and then translate it into the input needed for hugo to translate it to a functioning web site. -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt; required riddl input file to read -o \u0026lt;value\u0026gt; | --output-dir \u0026lt;value\u0026gt; required output directory for the generated output -p \u0026lt;value\u0026gt; | --project-name \u0026lt;value\u0026gt; Optional project name to associate with the generated output -e \u0026lt;value\u0026gt; | --erase-output \u0026lt;value\u0026gt; Erase entire output directory before putting out files -b \u0026lt;value\u0026gt; | --base-url \u0026lt;value\u0026gt; Optional base URL for root of generated http URLs -t \u0026lt;value\u0026gt; | --themes \u0026lt;value\u0026gt; -s \u0026lt;value\u0026gt; | --source-url \u0026lt;value\u0026gt; URL to the input file\u0026#39;s Git Repository -h \u0026lt;value\u0026gt; | --edit-path \u0026lt;value\u0026gt; Path to add to source-url to allow editing -l \u0026lt;value\u0026gt; | --site-logo-url \u0026lt;value\u0026gt; URL to the site\u0026#39;s logo image for use by site -p \u0026lt;value\u0026gt; | --site-logo-path \u0026lt;value\u0026gt; Path, in \u0026#39;static\u0026#39; directory to placement and use of the site logo. Command: hugo-git-check [options] git-clone-dir This command checks the \u0026lt;git-clone-dir\u0026gt; directory for new commits and does a `git pull\u0026#34; command there if it finds some; otherwise it does nothing. If commits were pulled from the repository, then the hugo command is run to generate the hugo source files and hugo is run to make the web site available at hugo\u0026#39;s default local web address: |http://localhost:1313/ git-clone-dir Provides the top directory of a git repo clone that contains the \u0026lt;input-file\u0026gt; to be processed. -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt; required riddl input file to read -o \u0026lt;value\u0026gt; | --output-dir \u0026lt;value\u0026gt; required output directory for the generated output -p \u0026lt;value\u0026gt; | --project-name \u0026lt;value\u0026gt; Optional project name to associate with the generated output -e \u0026lt;value\u0026gt; | --erase-output \u0026lt;value\u0026gt; Erase entire output directory before putting out files -b \u0026lt;value\u0026gt; | --base-url \u0026lt;value\u0026gt; Optional base URL for root of generated http URLs -t \u0026lt;value\u0026gt; | --themes \u0026lt;value\u0026gt; -s \u0026lt;value\u0026gt; | --source-url \u0026lt;value\u0026gt; URL to the input file\u0026#39;s Git Repository -h \u0026lt;value\u0026gt; | --edit-path \u0026lt;value\u0026gt; Path to add to source-url to allow editing -l \u0026lt;value\u0026gt; | --site-logo-url \u0026lt;value\u0026gt; URL to the site\u0026#39;s logo image for use by site -p \u0026lt;value\u0026gt; | --site-logo-path \u0026lt;value\u0026gt; Path, in \u0026#39;static\u0026#39; directory to placement and use of the site logo. Command: from [options] config-file Load riddlc options from a config file config-file A HOCON configuration file with riddlc options -i \u0026lt;value\u0026gt; | --input-file \u0026lt;value\u0026gt; required riddl input file to read -o \u0026lt;value\u0026gt; | --output-dir \u0026lt;value\u0026gt; required output directory for the generated output Command: help Print out how to use this program Command: repeat config-file [refresh-rate] [max-cycles] This command supports the edit-build-check cycle. It doesn\u0026#39;t end until \u0026lt;max-cycles\u0026gt; has completed or EOF is reached on standard input. During that time, the selected subcommands are repeated. config-file The path to the configuration file that should be repeated refresh-rate Specifies the rate at which the \u0026lt;git-clone-dir\u0026gt; is checked for updates so the process to regenerate the hugo site is started max-cycles Limit the number of check cycles that will be repeated. -n | --interactive This option causes the repeat command to read from the standard input and when it reaches EOF (Ctrl-D is entered) then it cancels the loop to exit. "},{"id":2,"href":"/audience/domain-experts-guide/","title":"Domain Expert's Guide","parent":"Audience","content":"Domain experts (DEs) are subject matter experts (SMEs) in some knowledge or problem domain. They are the authority on the language used to describe both problems and solutions within their domain or field of expertise. These individuals are recognized authorities, and they influence an organization\u0026rsquo;s product, service or strategic direction.\nDomain experts may or may not be in leadership positions, but they are people who are broadly trusted for their knowledge of business rules, processes, technical details, and system requirements.\nThese are the EF_Huttons of the organization.\nWhile not a comprehensive list, these people may be Architects, Analysts, Developers, Managers, QA Engineers, or even Call Center Agents, and line workers from the warehouse.\nDomain Experts do not need to be well versed in DDD or Reactive Architecture initially. It is the job of the Author to act as a guide and mentor through these topics. But Domain Experts must be open to change what is for what could be. Reactive Architectures can be very challenging for people to digest. More specifically, quite often techniques used to implement distributed and reactive systems will change user experiences, expectations of consistency and availability, the means used to monitor and maintain systems and processes, and so on. Domain experts will need to come to understand the reasons for these changes and be able to evangelize them as they interact with their peers.\n"},{"id":3,"href":"/tooling/riddlc/translation/bast/","title":"Binary AST","parent":"Translation","content":"When the riddlc compiler parses a RIDDL document, it translates it to an Abstract Syntax Tree (AST) in memory. The AST is then used by other passes to validate and translate the AST into other forms. The binary AST (BAST) translator converts the AST in memory into a binary format that is stored for later usage. Saving the BAST format and then reading it back into the compiler avoids the time to both parse the RIDDL document and validate it for consistency.\nConsequently, the riddlc offers a translator from validated AST to BAST format and the ability to read BAST files instead of RIDDL files. The content of a BAST file must contain a valid domain definition from which portions can be imported with the import keyword like this:\nimport domain Kitchen from \u0026#34;rbbq.bast\u0026#34; "},{"id":4,"href":"/language/root/domain/context/","title":"Context","parent":"Domain","content":"A context definition in RIDDL represents the notion of a bounded context in DDD. Contexts are introduced with the context keyword and have a name, like this:\ncontext BBQ is { ??? } IN the above the context is named BBQ and its definition is 3 question marks. ??? means \u0026ldquo;unknown\u0026rdquo; or \u0026ldquo;to be determined\u0026rdquo;\nContained Definitions Common Options A context may define options. Options help the translation tools know what to do with\nType Types are used in bounded contexts to define messages, function input and output, the state of entities, etc. For more on type definitions see types\nSpecific Context definitions are containers and they may contain definitions that are specific to being defined in a context:\nEntities State Options Invariants Handler Function Adaptors APIs Saga Projections Features "},{"id":5,"href":"/language/root/domain/context/entity/","title":"Entities","parent":"Context","content":"An entity in RIDDL is the same as it is in DDD which defines it this way:\nEntity Definitions\nAn object primarily defined by its identity is called an Entity.\nand\nMany objects are not fundamentally defined by their attributes, but rather by a thread of continuity and identity.\nThere are three main aspects to this definition of entity:\nEntities are objects (containing both state and function) which means they can represent physical objects, mental constructs, concepts, etc. It also means they can be implemented as objects, actors, or collections of functions that share exclusive access to some data Entities have an identity; they are identified by some unique value that no other entity of the same type may have. Entities are continuous; they have a lifecycle, evolving from creation, through their useful lifespan, to destruction. An entity is the fundamental processor of work in a reactive system and in a RIDDL specification.\nEntities are most often implemented in software as an actor or a OOP class.\nIdentity Entities have a unique immutable persistent identifier, much like people have names except our personal names are not unique. The unique identifier is used to locate the entity in a computing system and for other computing purposes. These immutable and unique identifiers convey equivalence. That is when two values of an identifier are the same, then by definition, they must refer to the same entity. Changing the state of the entity does not break this equivalence. type Id, which provides the means to reference the entity in its context or between contexts. an Entity\u0026rsquo;s immutable identity conveys equivalence. Individual pieces of attribute of entity can change.\nEntities can also contain business Logic. Actors in Akka, Entities in Lagom. Contrary to Value Objects,\nConsumption Entities consume commands and queries and produce events and results, correspondingly. They also hold state, whether persistent or not. Entities use event sourcing to keep track of the entire history of changes to the entity\u0026rsquo;s state. This is important because two instances of the same Entity may have different attribute values, but because both instances have the same identity value, they represent the same Entity. Which, then, is correct? The answer is neither. Both would need to reference the Event Log for the Entity to get the most current and correct state of this Entity. Thus, entities are the single source of truth for a particular id. They are the same entity. For example:\nentity Printer is { options(value, available, kind(\u0026#34;device\u0026#34;)) // ... } Aspects Entities also have several contained definitions which specify various aspects of the entity. These aspects are detailed on the following pages:\nOptions - Various options that provide high level optional aspects of the entity. States - The information retained by the entity through its lifecycle Handlers - A specification of how the entity processes commands, events, queries, and reactions to events from other entities in the same bounded context. Functions - Auxiliary function definitions to implement the frequently used business logic referenced from the Handler definitions Invariants - Logical assertions that must always be true through an entity\u0026rsquo;s lifecycle to enforce business rules Features - High level descriptions of features as an outline for both developing the system and to test the entity functionality. Adaptors - An adaptor converts events from another bounded context into commands to this entity. This is how an entity reacts to its external environment while the handler provides a way to react to events within the internal environment (its bounded context). "},{"id":6,"href":"/tooling/riddlc/","title":"riddlc","parent":"Tooling","content":"This section covers how use the riddlc tool.\nHow To Build `riddlc` Installing `riddlc` Compilation Translation riddlc options Binary AST Diagrams Hugo Docs OpenAPI Kalix Akka Other Translators "},{"id":7,"href":"/language/root/domain/context/entity/state/","title":"State","parent":"Entities","content":"The state definitions of an entity define the structure of the information that the entity retains as its current state.\nSyntax Example The state of an entity is defined with the state keyword within the content of an entity definition, like this:\nentity Car { type Propulsion = any of { ICE, Electric, Steam, Diesel, EMDrive } state Static is { wheels: Integer doors: Integer rightHandDrive: Boolean propulsion: Propulsion } } One of the primary purposes of an entity is to represent the characteristics of the entity with state information. We call it state because it represents the current state of the entity at any given point in time.\nThe above example definition associates a state, named Static with the entity named Car having these fields in its aggregate data type:\nwheels - an Integer value providing the number of wheels on the car. doors - an Integer value providing the number of doors on the car. rightHandDrive - a Boolean value indicating if it is right hand drive. propulsino - a Propulsion enum value presumably representing the kind of propulsion the vehicle uses. Multiple State Definitions It is entirely possible to specify multiple named state definitions for a single entity. This is provided in the language to support finite state machines which are frequently used with entities. The state of an entity can be modelled as simply transitions of states as each handler processes a command. Multiple state values are useful when the state of the entity has different modes of operation where different sets of state values are needed.\n"},{"id":8,"href":"/audience/developers-guide/grammar/terminals/","title":"Terminals","parent":"Grammar","content":"This file shows the definition of the terminal symbols, as productions, and grouped in categories:\n(* Terminal symbol definitions in various categories *) Terminals = Punctuation | Options | Keywords | Predefined | Readability | Operators; Punctuation = asterisk | comma | colon | curlyOpen | curlyClose | dot | equals | ellipsis | ellipsisQuestion | plus | question | quote | roundOpen | roundClose | squareOpen | squareClose | undefined | verticalBar ; asterisk = \u0026#34;*\u0026#34;; comma = \u0026#34;,\u0026#34;; colon = \u0026#34;:\u0026#34;; curlyOpen = \u0026#34;{\u0026#34;; curlyClose = \u0026#34;}\u0026#34;; dot = \u0026#34;.\u0026#34;; equals = \u0026#34;=\u0026#34;; ellipsis = \u0026#34;...\u0026#34;; ellipsisQuestion = \u0026#34;...?\u0026#34;; plus = \u0026#34;+\u0026#34;; question = \u0026#34;?\u0026#34;; quote = \u0026#34;\\\u0026#34;\u0026#34;; roundOpen = \u0026#34;(\u0026#34;; roundClose = \u0026#34;)\u0026#34;; squareOpen = \u0026#34;[\u0026#34;; squareClose = \u0026#34;]\u0026#34;; undefined = \u0026#34;???\u0026#34;; verticalBar = \u0026#34;|\u0026#34;; Options = actor |aggregate | async | available | consistent | device eventSourced | function | gateway | persistent | reply | concept | sync value | wrapper ; actor = \u0026#34;actor\u0026#34;; aggregate = \u0026#34;aggregate\u0026#34;; async = \u0026#34;async\u0026#34;; available = \u0026#34;available\u0026#34;; consistent = \u0026#34;consistent\u0026#34;; device = \u0026#34;device\u0026#34;; eventSourced = \u0026#34;event sourced\u0026#34;; function = \u0026#34;function\u0026#34;; gateway = \u0026#34;gateway\u0026#34;; persistent = \u0026#34;persistent\u0026#34;; reply = \u0026#34;reply\u0026#34;; concept = \u0026#34;concept\u0026#34;; sync = \u0026#34;sync\u0026#34;; value = \u0026#34;value\u0026#34;; wrapper = \u0026#34;wrapper\u0026#34;; Keywords = action | adaptor | all | any | append | background | brief | call | causing | command | commands | consumer | context | described | details | domain | each | else_ | entity | event | events | example | execute | explained | feature | function | handles | include | input | interaction | invariant | items | many | mapping | on | one | option | optional | options | output | publish | query | queries | range | remove | requires | result | results | role | see | send | set | state | then_ | topic | type | value | when | yields action = \u0026#34;action\u0026#34;; adaptor = \u0026#34;adaptor\u0026#34;; all = \u0026#34;all\u0026#34;; any = \u0026#34;any\u0026#34;; append = \u0026#34;append\u0026#34;; background = \u0026#34;background\u0026#34;; brief = \u0026#34;brief\u0026#34;; call = \u0026#34;call\u0026#34;; causing = \u0026#34;causing\u0026#34;; command = \u0026#34;command\u0026#34;; commands = \u0026#34;commands\u0026#34;; consumer = \u0026#34;consumer\u0026#34;; context = \u0026#34;context\u0026#34;; described = \u0026#34;described\u0026#34;; details = \u0026#34;details\u0026#34;; domain = \u0026#34;domain\u0026#34;; each = \u0026#34;each\u0026#34;; else_ = \u0026#34;else\u0026#34;; entity = \u0026#34;entity\u0026#34;; event = \u0026#34;event\u0026#34;; events = \u0026#34;events\u0026#34;; example = \u0026#34;example\u0026#34;; execute = \u0026#34;execute\u0026#34;; explained = \u0026#34;explained\u0026#34;; feature = \u0026#34;feature\u0026#34;; function = \u0026#34;function\u0026#34;; handles = \u0026#34;handles\u0026#34;; include = \u0026#34;include\u0026#34;; input = \u0026#34;input\u0026#34;; interaction = \u0026#34;interaction\u0026#34;; invariant = \u0026#34;invariant\u0026#34;; items = \u0026#34;items\u0026#34;; many = \u0026#34;many\u0026#34;; mapping = \u0026#34;mapping\u0026#34;; on = \u0026#34;on\u0026#34;; one = \u0026#34;one\u0026#34;; option = \u0026#34;option\u0026#34;; optional = \u0026#34;optional\u0026#34;; options = \u0026#34;options\u0026#34;; output = \u0026#34;output\u0026#34;; publish = \u0026#34;publish\u0026#34;; query = \u0026#34;query\u0026#34;; queries = \u0026#34;queries\u0026#34;; range = \u0026#34;range\u0026#34;; remove = \u0026#34;remove\u0026#34;; requires = \u0026#34;requires\u0026#34;; result = \u0026#34;result\u0026#34;; results = \u0026#34;results\u0026#34;; role = \u0026#34;role\u0026#34;; see = \u0026#34;see\u0026#34;; send = \u0026#34;send\u0026#34;; set = \u0026#34;set\u0026#34;; state = \u0026#34;state\u0026#34;; then_ = \u0026#34;then\u0026#34;; topic = \u0026#34;topic\u0026#34;; type = \u0026#34;type\u0026#34;; value = \u0026#34;value\u0026#34;; when = \u0026#34;when\u0026#34;; yields = \u0026#34;yields\u0026#34;; Predefined = Boolean | Date | DateTime | Decimal | Duration | Id | Integer | LatLong | Nothing | Number | Pattern | Real | String | Time | TimeStamp | UniqueId | URL ; Boolean = \u0026#34;Boolean\u0026#34;; Date = \u0026#34;Date\u0026#34;; DateTime = \u0026#34;DateTime\u0026#34;; Decimal = \u0026#34;Decimal\u0026#34;; Duration = \u0026#34;Duration\u0026#34;; Id = \u0026#34;Id\u0026#34;; Integer = \u0026#34;Integer\u0026#34;; LatLong = \u0026#34;LatLong\u0026#34;; Nothing = \u0026#34;Nothing\u0026#34;; Number = \u0026#34;Number\u0026#34;; Pattern = \u0026#34;Pattern\u0026#34;; Real = \u0026#34;Real\u0026#34;; String = \u0026#34;String\u0026#34;; Time = \u0026#34;Time\u0026#34;; TimeStamp = \u0026#34;TimeStamp\u0026#34;; UniqueId = \u0026#34;UniqueId\u0026#34;; URL = \u0026#34;URL\u0026#34;; Readability = and | are | as | by | for | from | is | of | on | to ; and = \u0026#34;and\u0026#34;; are = \u0026#34;are\u0026#34;; as = \u0026#34;as\u0026#34;; by = \u0026#34;by\u0026#34;; for = \u0026#34;for\u0026#34;; from = \u0026#34;from\u0026#34;; is = \u0026#34;is\u0026#34;; of = \u0026#34;of\u0026#34;; on = \u0026#34;on\u0026#34;; to = \u0026#34;to\u0026#34;; Operators = and | or | not | plus | minus | times | div | mod ; not = \u0026#34;not\u0026#34;; plus = \u0026#34;+\u0026#34;; minus = \u0026#34;-\u0026#34;; times = \u0026#34;*\u0026#34;; div = \u0026#34;/\u0026#34;; mod = \u0026#34;%\u0026#34;; "},{"id":9,"href":"/language/common/doc-conventions/","title":"Documentation Conventions","parent":"Common","content":"This page defines the conventions we use throughout this documentation.\nRIDDL Snippets Whenever we include RIDDL source code in the documentation it will be in a fixed sized font like this:\ndomain MyDomain is { ??? } Notes Whenever an incidental note needs to be presented, it will be shown in blue like this paragraph. Recommendations Whenever an important recommendation needs to be made it will be shown in green like this paragraph. Warnings Whenever a point that is often a source of confusion needs to be made, it will be shown in yellow like this paragraph. Dangers Whenever a point that will lead to errors or have dangerous consequences needs be made, it will be shown in red like this paragraph. Language Definitions Whenever an important RIDDL language definition is made, it will appear in a box like this. "},{"id":10,"href":"/language/common/lang-conventions/","title":"Language Conventions","parent":"Common","content":" Introduction Syntax conventions of RIDDL are very simple and lenient. The intended audience is business owners, business analysts, domain engineers, and software architects. It is intentionally simple and readable. The language is free in its formatting. It does not require indentation and its various constructs can be arranged on any line. RIDDL supports the definition of a variety of concepts taken directly from Domain Driven Design and the Unified Modeling Language as well as software architecture.\nThe following language conventions are adhered to throughout the language for ease of use (special cases and rule contraventions cause confusion).\nLanguage Consistency Most things in RIDDL are consistent throughout the language. We believe this makes learning the language easier since there are no exceptions to fundamental constructs. The sections below define the consistent language features.\nDeclarative Definitions The language is declarative. You don\u0026rsquo;t say how to do something, you specify the end result you want to see. The language aims to capture a detailed and concise definition of the abstractions that a complex system will require. It does not specify how those abstractions should be built. RIDDL is not a programming language, but its compiler can generate structurally sound code that can be implemented by a software engineer.\nEvery Definition Can Be Documented Every thing you can define can has a described by or explained by suffix which lets you document the definition using markdown.\nHierarchy Of Definitions Definitions are specified in a strict containment hierarchy. Definitions that can contain other definitions are known as containers. For example, a domain definition is a recursively nested definition, as follows:\ndomain root is { domain branch is { domain leaf { } } } That is, domains are definitions that can contain the definition of (sub) domains. Similarly context can define entity\ncontext foo is { entity bar is { ... } } Definitions And References A definition introduces a named instance of some RIDDL concept at its point. The specification of that definition proceeds directly following the is keyword.\nIf RIDDL supported the concept of a Cat and its owner (it doesn\u0026rsquo;t in both those cases), then you might specify a cat named \u0026ldquo;Smudge\u0026rdquo; with an owner named \u0026ldquo;Reid\u0026rdquo; like this:\ncat Smudge is { owner is entity Reid } Here is an explanation of each of these tokens:\ncat is the kind of concept that the author wants to define Smudge is the name the author wants to assign to this cat concept is is a required keyword for readability { starts the definition of Smudge the cat owner is the name of a property that all \u0026ldquo;cat\u0026rdquo; concepts have is is another keyword required for readability entity Reid is a reference to an instance of a concept, an entity, of type Reid. References to many kinds of RIDDL concepts are made in this way, by name (type) with a prefix for the kind of concept. } completes the definition of Smudge the cat. This is a simple convention used throughout the language for all concept definitions and references to them.\nContainers Containers are definitions that contain other, nested, definitions. Between the { and the } that define the boundaries of a definition, you may place other definitions. Such nested definitions are deemed to be contained. Not every definition is a container as it only applies to concepts like domain, context and entity.\nThe full list of all Container types is as follows:\ntopic feature entity adaptor context interaction domain Leaves Definitions that may not contain other definitions are called \u0026ldquo;leaves\u0026rdquo; because, like tree leaves, they occur at the extremity (most nested) part of the definitional hierarchy.\nWork In Progress Modelling a domain can be hard work. New ideas come up that must be flushed out. Sometimes things get left undefined. That\u0026rsquo;s okay! Riddl uses a special construct, ??? to mean \u0026ldquo;we don\u0026rsquo;t know yet\u0026rdquo;. It can be used as the body of any definition. For example it is entirely legal to write:\ncat Smudge is { ??? } If we aren\u0026rsquo;t sure of the characteristics of the cat named \u0026ldquo;Smudge\u0026rdquo;\nDirectives RIDDL supports the notion of directives that are specified as a complete line whose first character is the hash mark. The directive extends to the end of that line. Hash marks at other locations on a line are not recognized as directives. The sub-sections below define the kinds of directives supported by RIDDL\u0026rsquo;s compiler.\nSubstitutions For example:\n#define x = expialidocious defines a symbol x that has the value expialidocious . Wherever $x is seen in the input it will be replaced with expialidocious before being lexically interpreted by the compiler.\nFile Inclusion RIDDL allows source input to be included, inline, from other files. That is, the parser will substitute the text of an included file, replacing the include directive. This is much like the C preprocessor #include directive. RIDDL always parses the entire specification but the include directive allows you to organize that specification into many (even nested) files. Note that include directives only permitted within container definitions. Doing so prevents fragments of definitions from being separated into individual files.\nFor example, this is allowed:\ndomain ThingAmaJig { #include \u0026#34;thingamajig/thing-context\u0026#34; #include \u0026#34;thingamajig/ama-topic\u0026#34; #include \u0026#34;thingamajig/jig-context\u0026#34; } while this is not:\ndomain #include \u0026#34;ThingAmaJig-domain\u0026#34; because it is not specified within the contained portion of a container. A domain is a container, but it needs a name and that name cannot be buried in an include file. As a rule of thumb, you can always use #include right after an opening curly brace of a container definition.\nDescriptions (Explanations) A definition may also be accompanied by some text or markup at its end to describe or explain the purpose of that definition. We call these descriptions or explanations because this is the text that is used to describe or explain the RIDDL definition, and it is used to generate documentation for the definition. A description occurs directly after the definition\u0026rsquo;s closing curly bracket and is preceded using either the described as or explained as keyword phrase. Essentially it looks like this:\ncat Smudge is { ??? } explained as \u0026#34;TBD but owned by Reid\u0026#34; The grammar for a description is this:\ndescription = (\u0026#34;described\u0026#34; | \u0026#34;explained\u0026#34;), \u0026#34;as\u0026#34;, \u0026#34;{\u0026#34;, description body, \u0026#34;}\u0026#34; ; description body = literal string description | doc block description ; literal string description = (literal string)+ ; literal string = \u0026#34;\\\u0026#34;\u0026#34; ; doc-block-description = ... tbd What occurs within a description/explanation can be one of three things:\nA single literal string in quotations: \u0026quot;this string\u0026quot;, as shown above. A curly brace enclosed list of \u0026ldquo;docblock\u0026rdquo; lines which consists of a group of lines, each preceded by a vertical bar. The bar denotes the left margin. Markdown syntax is accepted. A curly brace enclosed list of four sections: brief, details, items and see Each of these is explained in more detail in the sections that follow.\nSingle Literal String Pretty simple, like this:\ndomain SomeDomain is { ??? } explained as \u0026#34;Not very helpful\u0026#34; Documentation Block Allowing markdown syntax, like this:\ndomain SomeDomain is { ??? } explained as { |## Overview |This domain is rather vague, it has no content. |## Utility |The utility of this domain is dubious because: |* It has no content |* Its name is not useful |* It is only an example of RIDDL syntax } Separate Sections When more formal documentation is required for major definitions (domains, contexts, entities), then you should use the sectioned style to group your documentation into standard sections, like this:\nbrief is a simple text description of the definition details is a longer textual description enclosed in a block { }, avoiding the need to quote the text. This property may include Markdown directives that will be rendered in any generated documentation. items is a means of including references to other entities or definitions is also enclosed withing a block { }. see is a block where additional resources supporting the description may be listed. All of these nested blocks can use markdown in a doc block or simple literal strings depending on your needs. For example:\ndomain SomeDomain is { ??? } explained as { brief { \u0026#34;this domain is rather vague, it has no content\u0026#34; } description { |The utility of this domain is dubious because: } items(\u0026#34;Aspects Of Utility\u0026#34;) { |* It has no content |* Its name is not useful |* It is only an example of RIDDL syntax } } "},{"id":11,"href":"/language/common/descriptions/","title":"Descriptions","parent":"Common","content":"The RIDDL syntax is simply a hierarchical arrangement of definitions. Each definition can have a description. Descriptions are used to generate documentation and follow markdown conventions.\nExamples There are several ways to describe a definition. In each of the examples we attach a description to some domain named Foo. The definition is not important for our purposes here. Descriptions come after the definition using one of four phrases:\ndescribed by described as explained by explained as These four phrases are equivalent but provided to suit the nature of the definitions to which they may be applied. For example:\ndomain Foo is { } explained as \u0026#34;Foo is not a very good domain name\u0026#34; is equivalent to:\ndomain Foo is { } described by \u0026#34;Foo is not a very good domain name\u0026#34; Quoted String Format The examples show above use a single string as the description. This is appropriate when the description is short, as is typical for small definitions.\nQuoted Strings Format Alternatively, a large description may be provided as a set of quoted strings enclosed in curly braces. For example:\ndomain Foo is { } described by { \u0026#34;Foo is not a very good domain name\u0026#34; \u0026#34;And an empty domain doesn\u0026#39;t define anything!\u0026#34; } Note in this case that we have embedded markdown syntax into the description.\nMarkdown Format Alternatively, to make things a little more free-form, and aligned on the left column, a description may be formed using just a vertical bar character to indicate the line start. For example:\ndomain Foo is { } described by { |# Warning |Foo is not a very good domain name |And an empty domain doesn\u0026#39;t define anything! } Note in this case that we have embedded markdown syntax into the description. The # Warning syntax is an indication to a markdown processor that a new heading with the text \u0026ldquo;Warning\u0026rdquo; should be started. All descriptions are encouraged to use this markdown syntax style.\nUsing Markdown Syntax Markdown syntax is encouraged in descriptions because the riddlc compiler can translate RIDDL specifications into the input of the website generator hugo, which expects markdown. In this way, a large RIDDL specification can be translated automatically into a beautiful website.\nThe full range of markdown, html, and shortcode syntax that hugo supports may be used in RIDDL descriptions. See this link for more details on hugo\n"},{"id":12,"href":"/language/root/domain/context/entity/options/","title":"Options","parent":"Entities","content":"The optional entity kind prefix is a directive that suggests how the entity might handle its state and received messages. In the example above, we expect the \u0026ldquo;Printer\u0026rdquo; entity to be a physical device. An \u0026ldquo;actor\u0026rdquo; entity in of the same name could be expected to be a person who prints.\nThe options available suggest how the entity might handle its state and message input:\nkind - indicates the intended kind of entity in an argument to the kind entity. event sourced - indicates that event sourcing is used in the persistence of the entity\u0026rsquo;s states, storing a log of change events value - indicates that only the current value of the entity\u0026rsquo;s state is persisted, recording no history off the change events aggregate - indicates this entity is an \u0026lsquo;aggregate root entity\u0026rsquo; as defined by DDD. persistent - indicates that this entity should persist its state to stable storage. consistent - indicates that this entity tends towards Consistency as defined by the CAP theorem and therefore uses sharding and the single writer principle to ensure a consistent view on state changes available - indicates that this entity tends towards Availability as defined by the CAP theorem and therefore replicates its entity state to multiple locations or even across data centers using CRDTs (conflict-free replicated data types). grpc - indicates that the entity should be accessible via gRPC api invocations mq - indicates that commands and queries may be sent by a message queue such as Kafka, Pulsar, or Google Pub Sub "},{"id":13,"href":"/audience/authors-guide/","title":"Author's Guide","parent":"Audience","content":"The author needs a clear and intuitive language to program in (RIDDL). This activity is greatly faciliated by tools to aid the job, for example, IDE plugins, graphical authoring utilities, and so on. The author needs to have the ability to configure these tools and utilites to match their mode of work. The RIDDL complier must emit clear feedback on errors, warnings, and other details that would improve the overall correctness and outputs from RIDDL.\nFinally, the author should have broad control to influence the look and feel, as well as the content of the outputs. For specification outputs, examples might include fonts, colors, logos, and even layout of the specification web site. For implementation artifacts, these customizations could include license, copyright, and trademark information that serve as a preamble in code artifacts.\nRIDDL sources are intended to kept in version control along with the source code. The RIDDL compiler, riddlc, has utilities that will automate the process of generating RIDDL outputs from source control or in local environments. These will be discussed further when we dive into riddlc in depth.\nAuthors are the individuals who create system specifications. Such work is greatly aided by using a clear, concise, precise, and intuitive language in which to specify a system. That language is RIDDL. Authors form the bridge between Domain Experts and Implementors.\nAuthors should have an expert understanding of DDD, and be familiar with reactive architecture, API design and distributed systems\u0026rsquo; concepts. While not required, it is also helpful to be familiar with Scala, Akka (including Akka Clustering and Streaming), and cloud architectures. This knowledge is useful for the successful construction of va viable domain model encoded in the RIDDL language. Consequently, Authors must acquire a full understanding of the syntax, structure and semantics of RIDDL.\nIt will also be very helpful if authors become familiar with:\nMarkdown Git Hugo Geekdoc Theme for Hugo HOCON configuration format Scala programming language The Actor Model This activity is greatly facilitated by tools to aid the job, for example, IDE plugins, graphical authoring utilities, and so on. The author needs to have the ability to configure and run these tools and utilities to match their mode of work. The RIDDL compiler emits clear feedback on errors, warnings, and an author must be able to interpret those messages and use them to adjust the RIDDL sources to improve the overall correctness in the outputs from RIDDL.\nFinally, the author should have broad control to influence the look and feel, as well as the content of the outputs. For specification outputs, examples might include fonts, colors, logos, and even layout of the specification web site. For implementation artifacts, these customizations could include license, copyright, and trademark information that serve as a preamble in code artifacts.\nRIDDL sources are intended to be kept in version control along with the source code. The RIDDL compiler, riddlc, has utilities that will automate the process of generating RIDDL outputs from source control or in local environments. These will be discussed further when we dive into riddlc in depth.\n"},{"id":14,"href":"/audience/","title":"Audience","parent":"Home","content":"There are four kinds of readers of this documentation based on the intent of the reader. Accordingly, the documentation has a guide for each kind of reader:\nThe Domain Expert\u0026rsquo;s Guide will help domain experts learn how to assist authors with the creation and validation of RIDDL specifications. The Author\u0026rsquo;s Guide will help RIDDL authors to create and prefect system specifications using RIDDL. The Implementor\u0026rsquo;s Guide will help software developers convert RIDDL specifications, and output from the riddl tools into working software systems. The Developer\u0026rsquo;s Guide is for software developers and other interested parties who want to help with development and usage of RIDDL itself. The following sections define these roles more clearly: Domain Experts Authors Implementors Developers Domain Experts Domain experts (DEs) are subject matter experts (SMEs) in some knowledge or problem domain. They are the authority on the language used to describe both problems and solutions within their domain or field of expertise. These individuals are recognized authorities, and they influence an organization\u0026rsquo;s product, service or strategic direction.\nAuthors Authors are the individuals who create system specifications. Such work is greatly aided by using a clear, concise, precise, and intuitive language in which to specify a system. That language is RIDDL. Authors form the bridge between Domain Experts and Implementors.\nImplementors Implementors are the technical experts who implement the system defined in a RIDDL specification. These people are most often Software, QA, and DevOps Engineers. Of course, throughout implementation they will be supported by the Author(s), Domain Experts, and other related staff. Implementors use the output from the RIDDL tools to aid in their comprehension and coding of a solution that corresponds to the RIDDL system specification or model.\nDevelopers Developers are the technical experts that advance RIDDL\u0026rsquo;s state of the art. They develop the tooling and documentation that makes up RIDDL. Since RIDDL is an open source project, developers can be affiliated with many organizations, presumably the organizations that derive utility from RIDDL.\n"},{"id":15,"href":"/language/root/domain/context/adaptor/","title":"Adaptors","parent":"Context","content":"Adaptors are translators between contexts and (sub-)domains. DDD calls these \u0026ldquo;anti-corruption layers\u0026rdquo;; but we find that term to be awkward, hence we renamed them as adaptors. However, the name DDD chose is apt. Adaptors aim to solve a language problem that often exists in large domain modelling exercises: conflation and overloading of terms.\nFor example, consider the word \u0026ldquo;order\u0026rdquo; in various contexts:\nmilitary - a directive or command from a superior to a subordinate restaurant - a list of items to be purchased and delivered to a table mathematics - A sequence or arrangement of successive things. sociology - A group of people united in a formal way architecture - A type of column and entablature forming the unit of a style And there are several more. To disambiguate these definitions we use bounded contexts in DDD, and RIDDL, that precisely define the meaning of a term in that context. But, what happens when two bounded contexts use the same term for different purposes? That\u0026rsquo;s where Adaptors come in.\nUse Cases There are several use cases in which the need for an Adaptor occurs as in the following subsections\nNon-DDD External Systems An adaptor can adapt a non-DDD external system to a DDD system. The DDD system can then interact with the non-DDD system using messages as if it was a DDD system by simply interacting with the corresponding Adaptor.\nSee this stackoverflow article for more on this.\nReactions Some entities need to react to the occurrence of events from other bounded contexts. These adaptations are often handled directly by an entity handler but sometimes the model needs to specify reactions at the bounded context level where they can be converted into commands on the appropriate entities.\nVersioning Bounded contexts and their entities undergo version changes and those changes can affect the structure and composition of the messages used. To support smooth transitions between versions, the software needs to support older versions of messages seamlessly. This is handled in RIDDL by adapting the old messages to the new messages, even if that means ignoring them.\nDefining Adaptors An adaptor can only be defined as part of the definition of a bounded context. It can specify how to handle the messages received from another bounded context, or even from a pipe. For example, we adapt context Bar below to the event from context Foo\ncontext Foo is { type FooEventName is event { ??? } } context Bar is { type BarCommandName is command { ??? } adaptor FromFooContext for Foo is { adapt FooEventName to BarCommandName as { given \u0026#34;entity\u0026#34; } } } "},{"id":16,"href":"/language/root/domain/context/api/","title":"APIs","parent":"Context","content":"An api definition represents a stateless application programming interface. RIDDL supports this definition in domains and bounded contexts. This permits higher level functional gateways to summarize the behavior of entire subdomains and bounded contexts.\nAlways Stateless APIs are always stateless. Any state that needs to be saved when an API function is invoked should be done by sending commands to an entity from an API function.\nFunctions APIs are collections of functions. TBD\n"},{"id":17,"href":"/audience/developers-guide/grammar/common/","title":"Common","parent":"Grammar","content":"A number of frequently used productions are useful to understand in the sections that follow. Commentary follows the grammar.\n(* Common RIDDL EBNF Grammar Productions *) (******************************************************************** COMMON *) any char = ? any UTF-8 character ? ; any but newline = any char - ( \u0026#34;\\n\u0026#34; | \u0026#34;\\r\u0026#34; ) ; nonquote = any char - \u0026#39;\u0026#34;\u0026#39; ; digits = \u0026#34;0\u0026#34; | \u0026#34;1\u0026#34; | \u0026#34;2\u0026#34; | \u0026#34;3\u0026#34; | \u0026#34;4\u0026#34; | \u0026#34;5\u0026#34; | \u0026#34;6\u0026#34; | \u0026#34;7\u0026#34; | \u0026#34;8\u0026#34; | \u0026#34;9\u0026#34; ; literalInteger = digits literalString = quote nonquote quote ; literalStrings = literalString { literalString } ; markdownLine = verticalBar, any but newline, newline ; markdownLines= markdownLine { markdownLine.rep(1)) } ; docBlock = (open, (markdownLines | literalStrings), close) | literalString ; optionalNestedContent(content) = open [ content ] close ; brief = \u0026#34;brief\u0026#34;, [ ( literalString | docBlock ) ] ; details = \u0026#34;details\u0026#34;, [ (literalString | docBlock) ] ; items = \u0026#34;items\u0026#34;, [ \u0026#34;(\u0026#34;, literalString \u0026#34;)\u0026#34; ], open, { identifier, \u0026#34;is\u0026#34;, docBlock), close ; citations = \u0026#34;see\u0026#34;, docBlock ; as = \u0026#34;as\u0026#34; | \u0026#34;by\u0026#34;; detailedDescription = brief, details, items, citations ; literalStringsDescription = literalStrings ; docBlockDescription = markdownLine ; description = ( \u0026#34;described\u0026#34; | \u0026#34;explained\u0026#34; ), as, open, (literalStringDescription | docBlockDescription | detailedDescription), close ; literalDecimal = plusOrMinus, digits{digits}, \u0026#34;.\u0026#34; {digits} ; idHeadChars = ? upper and lower case letters ? ; idTailChars = ? letters digits and underscore ? ; simpleIdentifier = idHeadChars, { idTailChars } ; quotedIdentifier = \u0026#34;\u0026#39;\u0026#34;, any char { any char }, \u0026#34;\u0026#39;\u0026#34; ; identifier = simpleIdentifier | quotedIdentifier ; pathIdentifier = identifier { \u0026#34;.\u0026#34;, identifier } ; is = \u0026#34;is\u0026#34; | \u0026#34;are\u0026#34; | \u0026#34;:\u0026#34; | \u0026#34;=\u0026#34; ) ; open = \u0026#34;{\u0026#34; ; close = \u0026#34;}\u0026#34; ; options(validOptions) = \u0026#34;options\u0026#34;, \u0026#34;(\u0026#34; validOptions{validOptinos} \u0026#34;)\u0026#34; | \u0026#34;option\u0026#34;, \u0026#34;is\u0026#34;, validOptions ; commandRef = \u0026#34;command\u0026#34;, pathIdentifier ; eventRef = \u0026#34;event\u0026#34;, pathIdentifier ; queryRef = \u0026#34;query\u0026#34;, pathIdentifier ; resultRef = \u0026#34;result\u0026#34;, pathIdentifier ; messageRef = commandRef | eventRef | queryRef | resultRef ; entityRef = \u0026#34;entity\u0026#34;, pathIdentifier ; topicRef = \u0026#34;topic\u0026#34;, pathIdentifier ; typeRef = \u0026#34;type\u0026#34;, pathIdentifier; actionRef = \u0026#34;action\u0026#34;, pathIdentifier ; contextRef = \u0026#34;context\u0026#34;, pathIdentifier ; domainRef = \u0026#34;domain\u0026#34;, pathIdentifier; "},{"id":18,"href":"/language/common/","title":"Common","parent":"Language","content":"Some definitions and concepts are fundamental to RIDDL and can appear in many RIDDL definitions. Before exploring the hierarchy of definitions, we will define some things that are common to many definitions:\nDocumentation Conventions Language Conventions Descriptions Identifiers Examples Types Expressions Includes Functions Imports Options "},{"id":19,"href":"/tooling/riddlc/translation/diagrams/","title":"Diagrams","parent":"Translation","content":""},{"id":20,"href":"/tooling/riddlc/build/","title":"How To Build `riddlc`","parent":"riddlc","content":" 1. Obtain source code \u0026gt; git clone https://github.com/reactific/riddl.git \u0026gt; cd riddl 2. Install JDK Please follow the directions provided by Adoptium to install OpenJDK on your machine. For MacOS users, this boils down to:\nbrew install --cask temurin 3. Install sbt Please follow the directions to install sbt which orchestrates the build for RIDDL. For MacOS users, this boils down to:\n\u0026gt; brew install sbt 4. Build Within the cloned repository\u0026rsquo;s directory (step 1 above), run this command:\n\u0026gt; sbt \u0026#34;clean ; compile\u0026#34; "},{"id":21,"href":"/language/common/identifiers/","title":"Identifiers","parent":"Common","content":"Identifiers are the names of definitions. In the following domain definition,\ndomain foo is { ??? } the identifier is foo. Identifiers can be specified in two ways:\nsimple: any alphabetic character followed by alphanumerics or underscore quoted: \u0026quot; followed by a string of characters chosen from this set: a-zA-Z0-9_+\\-|/@$%\u0026amp;, :\u0026quot; followed by a \u0026quot; Path Identifiers In several places in RIDDL, you may need to reference a definition in another definition. Such references are called Path Identifiers. Path identifiers encode a simple algorithm to find the definition of interest.\nThe best way to learn path identifiers is by example, so please consider the following example as you read the sections below\ndomain A { domain B { context C { type Simple = String(,30) } type BSimple = A.B.C.Simple // full path starts from root context D { type DSimple = ^E.ESimple // partial path entity E { type ESimple = ^^^C.Simple // E-\u0026gt;D-\u0026gt;B-\u0026gt;C-\u0026gt;Simple type Complicated = ^^^C^D.DSimple // E-\u0026gt;D-\u0026gt;B-\u0026gt;C-\u0026gt;B-\u0026gt;D-\u0026gt;DSimple } } } } Path Identifier Syntax Path identifiers are composed of only the names of the definitions, the caret symbol, ^, and the period character, .. The path is interpreted this way:\nStart in the context of the container definition in which the path occurs If the next symbol is ^ make the context the parent of the current context If the next symbol is an identifier, make the current context that definition If the next symbol is a . it can be considered as the current context and thus ignored. Note that separating the names by periods simply allows us to distinguish the names of adjacent definitions. The resulting definition is the final context.\nFull Path Identifier A full path starts from the root of the hierarchy and mentions each definition name until the sought leaf definition is reached. The full path identifier to the Simple type definition in the example above is A.B.C.Simple which is also used in the definition of the BSimple type\nPartial Path Identifiers Path identifiers can be partial too. All partial path identifiers start with a caret, ^. A single caret indicates the current container definition in the hierarchy, two periods indicates the container\u0026rsquo;s container, three periods indicates the container\u0026rsquo;s container\u0026rsquo;s container, and etc.\nIn the example, the definitions of both DSimple and ESimple use partial paths to name the type.\nFor DSimple the partial path, ^D.E.ESimple, is broken down like this:\nstart with the current definition, type DSimple ^ - go up to context B D - go down to context D . - stay at context D E - select the definition namedE, entity E . - stay at entity E ESimple - select the type named ESimple For ESimple, the partial path, ^^^C.Simple is broken down like this:\nstart with the current container, entity E ^ - go up to context D ^ - go up to domain B C - select context C . - stay at context C Simple - select definition named \u0026ldquo;Simple\u0026rdquo; Complex Partial Path Identifiers The definition of Complicated uses path ^^^C^D.DSimple in the example above. This helps us to see how DSimple is referenced in a complicated path. The complicated part is the ^ between C and D. This path is interpreted like this:\nstart with the current container, entityE ^ - go up one container to context D ^ - go up one container to domain B C - in the current container, domain B, select context C ^ - go up one container to domain B D - in the current container, domain B, select context D . - select the current container, context D DSimple - in the current container, select definition DSimple "},{"id":22,"href":"/language/root/domain/context/entity/invariants/","title":"Invariants","parent":"Entities","content":"Invariants specify rules about the state of an entity that must never be violated. Invariants typically come from business logic assertions. For example, a business axiom of a warehouse might be that the supply of a product should never be below 1. That is, the warehouse should never completely run out of a product it is storing. Reality, of course, must account for the supply running out; nevertheless specifying an invariant on the business intent may be important. This can be done in an entity with the invariant keyword:\ninvariant InSupply is { ProductState.supply \u0026gt; 0 } Invariants are checked every time the corresponding entity\u0026rsquo;s state is modified. If an invariant fails to be satisfied, the state change is aborted and an error is generated.\nSyntax Specifying an invariant may use a variety of common conditional operators familiar to most programming languages and mathematics. The expression provided must evaluate to a boolean value, either true or false. A true value means the invariant is satisfied and a false value means the invariant is not satisfied.\nComparison Operators = equality - The two operands must be equal: op1 = op2 != inequality - The two operands must not be equal op1 != op2 \u0026lt; less - The first operand must be less than the second operand: op1 \u0026lt; op2 \u0026lt;= less-or-equal - The first operand must be less than or equal to the second operand: op1 \u0026lt;= op2 \u0026gt; greater - The first operand must be greater than the second operaond: op1 \u0026gt; op2 \u0026gt;= greater-or-equal = The first operand must be greater than or equal to the second operand: op1 \u0026gt;= op2 Logic and Grouping Operators and - conjunction - Both operands must evaluate to true: op1 and op2 or - disjunction - Either operand must evaluate to true: op1 or op2 not - inverse - The inverse boolean value of the only operand: not op1 () - grouping - Parentheses are used to group operands into a single value: ( ... ) Operand Types constant - Constant values like numbers and strings may be used as operands function - Function invocations that return the right type of value may be used to compare runtime computed values. state - State values of the entity can be used as operands; when multiple state objects are specified, the name of the object must be used with the name of the field, separated by a period. "},{"id":23,"href":"/language/root/domain/streaming/pipe/","title":"Pipes","parent":"Streaming","content":"Pipes are uni-directional conduits for reliably transmitting data of a particular type between the publishers and consumers attached at the ends of the pipe.\nSyntax Example pipe WeatherForecast is { options rate(1000), paritions(7), transmits type Forecast } In the foregoing, a pipe named WeatherForecast is defined to transmit the data type named Forecast and with two options:\nrate - an expected sustained rate of 1000 data points per second partitions - a minimum number of partitions on the data of 7 Data Transmission Type Pipes can transmit any data type that RIDDL can specify. There is only one data type that flows in a pipe. The transmission type is often used with an alternation of message types such as the commands and queries that an entity might receive.\nOptional Pipe Characteristics Pipes may play a large role in the resiliency of a reactive system so we permit a variety of options to be specified no them. These options are intended only as advice to the translators converting the pipe into useful code. For example, a pipe may or may not need to be persistent. If a pipe has the burden of persistence removed, it is likely much more performant because the latency of storage is not involved.\npersistent The messages flowing through the pipe are persisted to stable, durable storage, so they cannot be lost even in the event of system failure or shutdown. This arranges for a kind of [bulkhead](bulkhead pattern) in the system that retains published data despite failures on either end of the pipe\ncommitable With this option, pipes support the notion of being commitable. This means the consuming processors of a pipe\u0026rsquo;s data may commit to the pipe that they have completed their work on one or more data items. The pipe then guarantees that it will never transmit those data items to that processor again. This is helpful when the processor is starting up to know where it left off from its previous incarnation.\npartitions(n) For scale purposes, a pipe must be able to partition the data by some data value that is in each data item (a key) and assign the consumption of the data to corresponding members of a consumer group. This permits multiple instances of a consuming processor to handle the data in parallel. The n value is the minimum recommended number of partitions which defaults to 5 if not specified\nlossy By default, pipes provide the guarantee that they will deliver each data item at least once. The implementation must then arrange for data items to be idempotent so that the effect of running the event two or more times is the same as running it once. To counteract this assumption a pipe can be use the lossy option which reduces the guarantee to merely best reasonable effort, which could mean loss of data. This may increase throughput and lower overhead and is warranted in situations where data loss is not catastrophic to the system. Some IoT systems can have this characteristic.\nProducers \u0026amp; Consumers Attached to the ends of pipes are producers and consumers. These are processors of data and may originate, terminate or flow data through them, connecting two pipes together. Producers provide the data, consumers consume the data. Sometimes we call producers sources because they originate the data. Sometimes we call consumers sinks because they terminate the data.\ngraph LR; Producers --\u003e P{{Pipe}} --\u003e Consumers Source --\u003e P1{{Pipe 1}} --\u003e Flow --\u003e P2{{Pipe 2}} --\u003e Sink Pipes may have multiple publishers (writers of data to the pipe) and multiple consumers (readers of data from the pipe). In fact, because of the partitioned consumption principle, there can be multiple groups of consumers, each group getting each data item from the pipe.\nSubscriptions When a pipe has multiple consumers, they are organized into subscriptions. Each subscription gets every datum the pipe carries. Consumers attach to a subscription and there is generally one consumer per partition of the subscription. Sometimes subscriptions are known as consumer groups as is the case for Kafka.\n"},{"id":24,"href":"/examples/scenario/","title":"RBBQ Scenarios","parent":"Example","content":" Case Study The Reactive BBQ restaurant chain has determined that their existing restaurant operations system is not suitably meeting their needs and have hired a high technology consulting company to provide some needed guidance on how they can improve their customer service, tracking, and reliability.\nWhat follows are the interviews conducted with key personnel at Reactive BBQ in order to identify the issues.\nCEO of Reactive BBQ How would you describe your restaurants?\nReactive BBQ is a family restaurant with 500 locations across 20 countries. We\u0026rsquo;re open for breakfast, lunch and supper. Our specialty at Reactive BBQ is our award winning Reactive Ribs, but we are also well known for our tender steaks and our slow roasted chicken. We take traditional BBQ flavours and give them a bit of a spicy punch. The customer experience at each Reactive BBQ should have the same high level of quality across the globe.\nWhat challenges do you face?\nThe challenge is that our original system was designed for one restaurant, and as more were opened, we started moving into the cloud. We started by moving inventory management into the cloud. Then we moved the customers facing areas: reservations, ordering etc. into the same application. We created a website on top of this so that customers can place orders for pickup or delivery, but they can also make reservations online.\nAs we add more locations, the system becomes unresponsive during peak hours as it seems to be struggling to keep up with all the reservations, the servers entering orders, orders being filled, payments, all of these drag everything down to a crawl. Staff gets frustrated, customers even more so, it can take 30 seconds to make a reservation, or enter an order.\nThe Operations team attempted to address the peak time performance issue by adding more instances of the application in the cloud, but this turned out to be quite expensive, and we still see a noticeable lag in response times during peak hours.\nAnother issue is that our application seems to be brittle. When one thing goes wrong, it seems like everything else goes wrong at the same time. I keep hearing reports of outages across the board. And these outages have a huge impact on our business. In the early days, when a problem happened, it affected a single restaurant. But now that we are in the cloud, when the application becomes unavailable it can affect many restaurants or even all of them.\nWe have been forced to limit certain activities during certain times of the day. For example, during the lunch hour on the east coast we aren\u0026rsquo;t allowed to generate certain kinds of reports. The same applies for the west coast. As our operation expands into more time zones, it is become harder to find the right time to do these reports. Ideally doing an inventory report during the lunch rush shouldn\u0026rsquo;t make the system crawl.\nAnother issue is upgrades. Every time we want to upgrade the software we have to take the whole system offline. This is also affected by things like the east coast lunch rush. So again we have to look for specific windows during the day to deploy. Those windows are getting smaller, and the deployments are taking longer. Sometimes when we do an upgrade something goes wrong and the system is unavailable during the times we need it the most. This gets very expensive and very annoying.\nWe have been wanting to implement a loyalty program that requires tracking data about our customers, but our development team tells us this would be a \u0026ldquo;major refactor\u0026rdquo;, and that sounds expensive and risky. I don\u0026rsquo;t really understand the details, but it feels like adding a loyalty program to do the tracking shouldn\u0026rsquo;t be that big of a deal.\nI wanted to implement a new electronic menu for the restaurants. You know, with the tablets on the tables? I thought it would be more environmentally friendly than printing new menus every month. It would also help us follow the trends. Anyway, that apparently was problematic as well. The system that deals with the online menu is really tightly tied up with the fact that it is online and deliveries and all that. I don\u0026rsquo;t really understand the details, but apparently adapting it to work in the restaurant is apparently going to be a lot of work. I would also like to put screens in the kitchen so we could get rid of paper completely.\nCEO\u0026rsquo;s Key Details 500+ Locations Existing Cloud Infrastructure Online Delivery/Pickup Orders, Reservations Experiencing too much downtime Due to upgrades or failures System responds slowly Outages can be very expensive Actions being taken to \u0026ldquo;work around\u0026rdquo; the problems with the system Want to implement a loyalty program but it\u0026rsquo;s risky Want to implement electronic menus but it is also risky Corporate Head Chef What is your role in the restaurant?\nCorporate wants each restaurant to have a consistent experience. My job is to create new recipes to be included in the menu. I spend a lot of time trying out different ingredients and flavours to try to get the right balance for our menu. I have to be careful to stick to ingredients that we can buy in sufficient quantities. Most people think that a restaurant like ours prepares everything from scratch. Sometimes we do, but a lot of our stuff is bought premade in bulk and then shipped to the restaurants. Our Reactive BBQ sauce is a perfect example. Very few people know what goes into the sauce. Even the companies we get to prepare it don\u0026rsquo;t have all the details.\nOnce I have a new dish figured out I talk to the marketing team. They work on preparing a nice description of the dish. We also have a food photographer so I work with him to make sure that the dish looks nice and is presentable for his photos.\nWhat challenges do you face?\nWell, as I mentioned there is the issues with sourcing ingredients. It can be a tricky business with all of the regions we have restaurants in. That\u0026rsquo;s part of the reason why so many things have to be shipped from our warehouses. Some of our ingredients are sourced locally, but not all of them.\nWe have these crazy processes around updating the actual menus. We can\u0026rsquo;t just do it whenever we want. Menus are only updated once a month. That makes sense because there are printer costs and distribution issues we have to think about. Basically once a month, after everything is prepared, I send an email out to all the restaurants with new menu items and recipes. But then we have to coordinate with the printers to make sure they get hard copies delivered in time. And then we have to also coordinate with the website to make sure they are up to date. It becomes a bit of a hassle. Basically near the end of every month we have this flurry of activity to get everything prepared.\nHead Chef\u0026rsquo;s Key Details Corporate Chef updates the menu once a month. Corporate Chef works with photographer on menu photographs. Corporate Chef deals with supply chain for the restaurants. Menu updates must be coordinated with printing and website. Host What is your role in the restaurant?\nI answer phones and record reservations. I also greet and seat guests as they arrive at the restaurant. Guests can either call, or use the website to make reservations, so it is necessary for me to consult the system before I seat customers. I also need to update the reservations system when I seat customers so that someone online can\u0026rsquo;t reserve the same table.\nWhat challenges do you face?\nI think the biggest problem I have is the reservations system. It seems like it is never working properly. Sometimes I try to add a reservation and it takes forever. I have customers lined up waiting for their tables and I don\u0026rsquo;t have time to be dealing with the slow software. Or I might go to look up the reservation for a customer and it takes so long to find it. The customers get frustrated and I am always apologizing to them for the slow software. Sometimes, after waiting forever for the information to come back, the system just crashes and I get nothing. Then it takes minutes or in rare cases hours for it to come back up. In the meantime I am struggling to figure out who is supposed to have a reservation and who isn\u0026rsquo;t.\nI have started printing out all the reservations periodically during the day. It helps to speed things up because I don\u0026rsquo;t have to use the software. But it doesn\u0026rsquo;t work for more recent reservations, so I end up looking at the print outs first and then only going to the software if I don\u0026rsquo;t find the person on the sheet.\nHost\u0026rsquo;s Key Details Host takes reservations in person or via phone Reservations can also be made online Host seats reservations as well as walk ins. Reservation system is unresponsive System often fails Printouts being used to deal with the failures of the software Server What is your role in the restaurant?\nI greet guests at their table, help them understand the menu and make recommendations, then take their food and drink orders. After taking their order I input it into our computer system. When the order is ready I pick it up from the kitchen or bar and deliver it to the table.\nWhen the guest is finished, I present the bill and settle at the table. At the end of the shift I pay out my cash bills to the restaurant, bundle and submit my receipts and collect my tips.\nHow do you know which prepared order from the kitchen/bar is for which table?\nOrders are input into the computer system with the table number, the prepared order is presented with a printout including the table number.\nHow do you settle a bill at the table?\nGuests can pay with cash or card.\nHow do you track how much you\u0026rsquo;ve made in tips for a shift?\nOur computer system keeps track of that for me and gives me a total at the end of the shift.\nWhat challenges do you face?\nDuring peak times things can get a little hectic. Entering orders seems to take longer when we get busy. We have a limited number of computer terminals to enter the information into, so as things slow down the other servers start to line up to enter their orders. We have asked for more terminals, but apparently they are really expensive so they won\u0026rsquo;t give us more.\nSome of us have tried going around the system and just asking the kitchen to start making something before we enter the order, but the cooks really don\u0026rsquo;t like when we do that. They say it\u0026rsquo;s too hard for them to keep track so they want us to use the computer.\nServer\u0026rsquo;s Key Details Server enters orders into the system. Server collects orders from the kitchen and delivers it to the table. Server delivers bills to the tables and collects payments. Server helps customers to understand the menu choices. Software tracks tips etc. System slows down when it\u0026rsquo;s busy. Servers bottleneck on using the computers. Kitchen doesn\u0026rsquo;t like servers working around the system. Bartender What is your role in the restaurant?\nI take drink orders at the bar and entertain the guests. I mix the drinks and take them to the customers when they are ready. When the customer is done for the day I help them settle their tab.\nI also mix drink orders for the servers in the restaurant. The servers deliver those drinks. I just get them ready and leave them on a tray with the table number so the servers know where they go.\nAt the end of a shift I cash out with the restaurant and take my tips.\nWhat challenges do you face?\nSometimes drink orders will sit for a really long time. When a drink is ordered a ticket prints out at my station and I usually make it right away. But the servers get busy, or they forget to check for the order. The drink ends up sitting on the counter for a while before they are able to come and get it. This means the ice is melting and it can really ruin a good drink.\nIt would be nice if there was a way to let the server know that their order is ready. Sometimes I end up looking around and trying to signal them if the drink has been sitting for a while, but they aren\u0026rsquo;t always easy to track down because they might be busy talking to customers. It would be nice if there was some way to get someone else to deliver the drinks. I would do it, but I am not allowed to leave the bar unattended.\nBartender\u0026rsquo;s Key Details Bartender takes drink orders at the bar. Bartender prepares drinks for customers at the bar. Bartender delivers drink orders to customers at the bar. Bartender collects payments for the customers at the bar. Bartender prepares drinks for tables to be taken out be the servers. Collect tips, similar to the server. Would like a way to notify servers when something is ready. Chef What is your role in the restaurant?\nI oversee the entire kitchen and all of its staff. I source local ingredients required to prepare our menu items. The menu is decided on monthly and distributed via email. I inspect all prepared orders that leave the kitchen.\nWhat challenges do you face?\nI think the worst thing is when the system that prints our orders goes haywire. Sometimes the system crashes and orders get lost. While it is down we don\u0026rsquo;t know what needs to be made. The servers have to resort to handwritten tickets and it\u0026rsquo;s sometimes difficult to read their writing. Some of it is really just gibberish. It results in a lot of orders getting missed or getting made improperly.\nThe servers complain a lot about the system being slow, but we don\u0026rsquo;t really see that in the kitchen. Once they enter an order it usually prints out right away as long as the system is working.\nChef\u0026rsquo;s Key Details Chef sources local ingredients for the menu. Chef inspects all orders that leave the kitchen. Orders get lost when the system fails. Handwritten tickets are a pain. Cook What is your role in the restaurant?\nDepending on the day, I work at different stations in the kitchen. The chef tells me where I will be working for that day. I prepare orders according to the tickets that get printed out at my station. Once an order is ready, I take it over to a station where we gather all the pieces of that order. The chef then approves it and we notifiy the server that their order is ready.\nWhat challenges do you face?\nHandwritten tickets. Man do I hate those things. We have this one server that writes in this horrible chicken scratch. Every time he brings me these tickets, I have to get her to explain to me what she has written. It\u0026rsquo;s just awful.\nThen there is the server\u0026rsquo;s attitudes. It\u0026rsquo;s pretty good most of the time, but when things get busy they start to get really annoying. When they get frustrated they kind of take it out on us in the kitchen. They start yelling about their orders taking too long. I try to explain to them that there are other orders that came first and I have to do them before I can get to theirs, but it doesn\u0026rsquo;t help. They end up storming off. I hear them talking sometimes like it\u0026rsquo;s our fault somehow.\nCook\u0026rsquo;s Key Details Printed Ticket provide details on orders to be prepared. Handwritten tickets are a pain. Servers are frustrated. Delivery Driver What is your role in the restaurant?\nI deliver for five locations around the city. We don\u0026rsquo;t get a lot of deliveries. We aren\u0026rsquo;t a pizza place after all. but our wings and ribs are popular delivery options. I am on call for each of the delivery locations. If one of them gets a delivery, I get a notification on my phone. I go pick up the food from the location nearest the customer. Then I drive to the customer, and deliver their food. I collect their payment if necessary. Sometimes they pay online. In that case I don\u0026rsquo;t have to do much, just drop off the food.\nWhat challenges do you face?\nYou mean other than traffic and customers annoyed with the delivery times? I think the app they give me is probably my biggest headache. I have this app on my phone. When I get a delivery it notifies me. It gives me all the details about the order and the customer. I also have a dongle that I attach to my phone that allow me to collect credit/debit payments.\nThe problem is that sometimes it doesn\u0026rsquo;t work. I will be on the way to a customer site when suddenly it just stops. I get some error like \u0026ldquo;unable to communicate with server\u0026rdquo; or something. When that happens I lose everything. I don\u0026rsquo;t have access to the customer address or their order. Thankfully they always print that information out on the bill before the delivery so I can still use that. But then when I go to collect the payment I end up having to use one of those old credit card swipe machines. The manual ones that take an imprint of the card. That doesn\u0026rsquo;t work if the customer planned to pay with debit though. In those cases I am out of luck.\nApparently they are going to start offering customer loyalty cards as well. They tell me that those will go through the same app. That just sounds like more headache. So now when the system goes down I am going to have to write down the customer\u0026rsquo;s loyalty number, and then enter it when manually when the system comes back up.\nDelivery Driver\u0026rsquo;s Key Details Driver gets notifications through the app on their phone. Driver picks up orders and delivers them to the customer. Driver collects payments. Workarounds for unreliable software in the form of printed receipts. Online Customer Describe how you place an order online with Reactive BBQ\nWell, I go to the website and they have their menu there. I have a look at the menu and decide what I want. The menu is organized into different sections, like lunch, dinner, appetizers, dessert, that sort of thing. The menu online isn\u0026rsquo;t identical to what I get in the restaurant, but it\u0026rsquo;s pretty close. I have also done it through the phone app they have.\nAs I find things that I want, I add them to my order. Then when I have everything I want, I checkout.\nTo checkout I have to give them some information, like the delivery address, my phone number, that sort of thing. I also have to give them my credit card information so that I can pay for it. I order pretty often though, so they have all of that stuff on file already. I just enter my username and password. Once that is done, I finish the order and then I have to wait.\nAnd what happens when your food is delivered?\nThe driver brings the food to the door. They hand me the food. I usually pay online. I love that when they come to the door, I don\u0026rsquo;t have to give them money. I can enter a tip online too so that I don\u0026rsquo;t have to give them anything, but it always feels a bit weird to tip them when they haven\u0026rsquo;t delivered the food yet. If I have cash I will often pay for the food online but then give them the tip in person. I live pretty far away and it\u0026rsquo;s a bit of a drive for them, so I usually tip them pretty well. I like to see their smile when I give it to them in person.\nDo you ever order pickup?\nSometimes. I order pickup once in a while and just grab it on my way home from work. I can still order online so I usually do that, and then I just choose pickup instead of delivery. Sometimes, if I am away from my computer, I will just phone them and order something instead.\nDo you ever have trouble ordering online?\nSometimes. Their website and app aren\u0026rsquo;t always working. Or if it is working it can be really slow. I don\u0026rsquo;t mind waiting when it\u0026rsquo;s slow, unless I am in a hurry or really hungry. But when it doesn\u0026rsquo;t work at all, I usually just don\u0026rsquo;t bother. When that happens I will usually just order from the other place down the street. The food isn\u0026rsquo;t as good, and their website is kind of hard to use, but it gets the job done in a pinch.\nHave you ever used the online reservation system?\nI have used it once or twice. I usually eat at home so I don\u0026rsquo;t use it that often. But it has been okay when I have used it. I don\u0026rsquo;t get to pick specific tables or anything. I just give them a few details about what I want, like how many people, whether I want a booth, that sort of thing.\nOnline Customer\u0026rsquo;s Key Details Customer adds menu items to their order through the website/app. Customer checks out when they have completed their order. Customer enters delivery or pickup information. Customer authorizes payment and tip through the website/app. Customer makes reservations through the website/app. Website/app doesn\u0026rsquo;t always work, forcing customer to go elsewhere. "},{"id":25,"href":"/language/root/domain/story/","title":"Story","parent":"Domain","content":"A story is a domain definition the defines an agile user story. This is the same concept that Kent Beck popularized in the early 2000s with eXtreme Programming. In RIDDL, a story is composed of the following things:\nAn role specification giving the role played by the narrator of the story A capability specification giving the capability used by the narrator A benefit specification providing the reason why the narrator wants to use the capability A accepted by specification expressed as Gherkin examples that defines done. A implemented by specification that links the story to the various RIDDL definitions involved in the implementation of this story Example story WritingABook is { role is \u0026#34;Author\u0026#34; capability is \u0026#34;edit on the screen\u0026#34; benefit is \u0026#34;revise content more easily\u0026#34; accepted by { example one { given \u0026#34;I need to write a book\u0026#34; when \u0026#34;I am writing the book\u0026#34; then \u0026#34;I can easily type words on the screen instead of using a pen\u0026#34; } described by \u0026#34;nothing\u0026#34; example two { given \u0026#34;I need to edit a previously written book\u0026#34; when \u0026#34;I am revising the book\u0026#34; then \u0026#34;I can erase and re-type words on the screen\u0026#34; } described as \u0026#34;nothing\u0026#34; } implemented by { ??? } } described as \u0026#34;A simple authoring story\u0026#34; "},{"id":26,"href":"/language/root/domain/context/saga/","title":"Saga","parent":"Context","content":" Introduction A Saga defines a way for an external application to invoke a distributed transaction via the Saga Pattern. Sagas are necessary in distributed services that use the Database per Service Pattern, like RIDDL. The Saga Pattern definition describes the context in which Sagas are used:\nYou have applied the Database per Service pattern. Each service has its own database. Some business transactions, however, span multiple service so you need a mechanism to implement transactions that span services. For example, lets imagine that you are building an e-commerce store where customers have a credit limit. The application must ensure that a new order will not exceed the customers credit limit. Since Orders and Customers are in different databases owned by different services the application cannot simply use a local ACID transaction.\nThe goal of a saga is to define a function across multiple entities that must atomically succeed with state changes, or fail with no state changes. So, a saga defines a set of commands to send to incur changes on entities, and a set of commands to undo those changes in case it cannot be atomically completed.\nSagas are very like functions but they only involve the sending of commands to entities. Sagas generally involve one or more different kinds of entities, or multiple entities of the same kind.\nExample saga AllOrNothing is { options(parallel) requires { p1: String, p2: String } yields { result: String } action Step1 for entity Thingy is { command DoIt reverted by UnDoIt as { example One is { then \u0026#34;pass p1 to entity Thingy with DoIt\u0026#34; } } } action Step2 for entity Thingy is { command CheckIt reverted by UnCheckIt as { example One is { then \u0026#34;pass p2 to entity Thingy with CheckIt\u0026#34; and \u0026#34;yield the result from the reply from Thingy\u0026#34; } } } } defines saga, AllOrNothing, with two input parameters, an output string, and two steps to be done in parallel.\n"},{"id":27,"href":"/audience/implementors-guide/","title":"Implementor's Guide","parent":"Audience","content":"Implementors are the technical experts who implement the system defined in a RIDDL specification. These people are most often Software, QA, and DevOps Engineers. Of course, throughout implementation they will be supported by the Author(s), Domain Experts, and other related staff. Implementors use the output from the RIDDL tools to aid in their comprehension and coding of a solution that corresponds to the RIDDL system specification or model.\nIt is incumbent on the author and implementation team members to keep the RIDDL sources up to date and accurate as the system evolves. The implementation team members must notify the author of changes to the model that the technical implementation necessitates.\nImplementors should be experts in Reactive Architectures. In addition, software engineers, and to a certain extent, other implementors need to be well versed in the implementation tech stack. The creators of the RIDDL language have found that Scala and Akka deployed into a cloud environment provide the best tooling and support for implementing a reactive system. It is not surprising then, that some concepts and constructs found in RIDDL have strong parallels to these tools. It must be noted, however, that reactive systems can be implemented using a variety of languages, frameworks, environments, products and tools. Cloud native offerings can be used with great effect. The critical point is, throughout implementation, reactive principles must be forefront in mind as implementation choices are made.\nIt must also be stated at this point that even though it may conflict with reactive principles, the business has final say in major implementation choices. It is incumbent on the implementation team to advise decision makers on the risks and challenges that are posed by making choices that conflict with reactive principles. Factors like time, cost, user experience, business rules, availability of technical talent, strategic partners, and so on are all extremely important and may conflict with the choices of the implementation team and sound reactive architecture.\n"},{"id":28,"href":"/audience/developers-guide/grammar/domain/","title":"Domain","parent":"Grammar","content":"See domains for examples and explanations of the following grammar productions\n(* RIDDL EBNF Grammar for knowledge domains *) domain include = \u0026#34;include\u0026#34;, literalString domain content = typeDef | topic | interaction | context | domain | domainInclude domain = \u0026#34;domain\u0026#34;, identifier, \u0026#34;is\u0026#34;, \u0026#34;{\u0026#34;, (undefined | domainContent), \u0026#34;}\u0026#34;, description "},{"id":29,"href":"/language/common/examples/","title":"Examples","parent":"Common","content":"RIDDL uses Gherkin examples in various places to express a functionality or behavior requirement on the definition that uses it. Gherkin examples are used in these places:\nAdaptors Entity Handlers Functions Processors Saga Actions Story Structure Gherkin is a language developed by SmartBear Software, a vendor of software quality tools, for the cucumber testing system. RIDDL uses a subset of the language as SmartBear has defined it. Four constructs are used in RIDDL:\nGIVEN - A description of the scenario, environment, or setting of the example WHEN - A condition that must be true for this example to be applicable THEN - An action, or set of actions, that are to be performed BUT - An action, or set of actions, that are not to be performed Example example AllDone is { Given \u0026#34;I am out shopping\u0026#34; And \u0026#34;I have eggs\u0026#34; And \u0026#34;I have milk\u0026#34; And \u0026#34;I have butter\u0026#34; When \u0026#34;I check my list\u0026#34; Then \u0026#34;I don\u0026#39;t need anything\u0026#34; } "},{"id":30,"href":"/tooling/riddlc/translation/hugo/","title":"Hugo Docs","parent":"Translation","content":"One of the main features of the RIDDL compiler is generating HTML documentation. The documentation enjoys the advantage of being more complete and accurate due to the compiler\u0026rsquo;s rigorous analyses. The riddlc compiler generates Hugosources for conversion to a web-site by the hugo generator. See Hugo Documentation for details on how to\n"},{"id":31,"href":"/tooling/riddlc/install/","title":"Installing `riddlc`","parent":"riddlc","content":"This guide helps you to install the riddlc tool on your local computer. Before installation, you will need to follow the steps defined on the build page.\nUniversal Installer RIDDL\u0026rsquo;s build system can generate a universal installation package that produces a zip file that can be unpacked and it provides a script to run on MacOS, Windows, and Linux.\n1. Build Universal Installer \u0026gt; project riddlc \u0026gt; universal:packageBin 2. Move Generated ZIP File a. Step 1 will have produce a .zip file in the riddlc/target/universal directory. b. Copy this .zip file to the machine on which you wish to install riddlc c. On that machine, unpack the .zip file with unzip \u0026lt;path-to-zip\u0026gt; You will now have a directory named something like:riddl-0.5.6/bin but the version # might be different. d. Put that bin directory in your path e. Now you can just run riddlc from the command line\nNative Installer TBD. Some day we will have a native installer for each platform.\n"},{"id":32,"href":"/language/","title":"Language","parent":"Home","content":"This section presents the RIDDL source language syntax, one definition at a time according to their typical arrangement.\nOverview Prerequisites Definitional Hierarchy Overview RIDDL is not a Turing complete language. However, it is intended to be used to create systems that are Turing complete. Consequently, RIDDL is not a programming language, it is a system specification language, and not only at software developers.\nWe expected business managers, business analysts, knowledge domain experts, system architects, and software developers to all be able to read and comprehend RIDDL models with only a little training and DDD background. The language tries hard to be readable in English and not overly technical while still retaining the ability to be precise, concise, and specific enough to be used for software source code generation.\nThe language is opinionated in the sense that it is intended for the specification of large scale distributed software systems. It does not attempt to be useful for every kind of computing problem nor even every kind of knowledge domain. Several distributed software architecture patterns have been adopted as natural extensions of domain driven design. Data engineering and user interface ideas are also included.\nPrerequisites We recommend that you first read the Language Conventions (not documentation conventions!) to which RIDDL adheres. These conventions are aimed at making RIDDL models consistent, simple, and free of special cases and exceptions.\nNext, there are several concepts that are used in a variety of places in the language. The Common section describes these concepts in preparation for looking at the major definitions in the language.\nDefinitional Hierarchy RIDDL\u0026rsquo;s basic structure is a containment hierarchy of nested definitions. That is, definitions are defined by their contained definitions. At the root of that definitional hierarchy is a single file known as the root file. The name of this file is given to riddlc to start processing a specification.\nSo, we can explore and learn the RIDDL language by examining each level of the definitional hierarchy like peeling the layers of an onion to discover what is hidden at each level.\nStart with the Root.\n"},{"id":33,"href":"/language/root/domain/streaming/processor/","title":"Processors","parent":"Streaming","content":"As the name indicates, a RIDDL processor definition specifies the inputs and outputs of some processor of data. The inputs to the processor are declared with inlet statements and the outputs from the processor are declared with outlet statements.\nInlets An inlet statement in the definition of a processor provides the name and data type for an input to the processor. There can be multiple inlets to the processor but each one must have a separate inlet statement. A processor with no inlets defined is called a source since it originates data and only has an outlet.\nOutlets An outlet statement in the definition of a processor provides the name and data type for an output of the processor. There can be multiple outlets to the processor but each noe must have a separate outlet statement. A processor with no outlets is called a sink since it terminates data and only has an inlet.\nKinds Of Processors RIDDL supports six kinds of processors that are used as the keyword to introduce the processor. The kind of processor depends solely on the number of inlet sand outlets that are defined. The keyword used ensures RIDDL knows how to validate the intention for the number of inlets and outlets.\n# of Inlets # of Outlets Kind Description 0 1 Source Sources originate their data, and publish it to an outlet 1 0 Sink Sinks terminate their data, and consume it from their inlet 1 1 Flow Flows transform their data from inlet to outlet 1 any Split Splits their data from one source to multiple outlets any 1 Merge Merges their data from multiple intles to a single outlet any any Multi Any other combination is a many-to-many flow Syntax Examples source GetWeatherForecast is { outlet Weather is type Forecast } explained as \u0026#34;This is a source for Forecast data\u0026#34; flow GetCurrentTemperature is { inlet Weather is type Forecast outlet CurrentTemp is type Temperature } explained as \u0026#34;This is a Flow for the current temperature, when it changes\u0026#34; sink AttenuateSensor is { inlet CurrentTemp is type Temperature } explained as \u0026#34;This is a Sink for making sensor adjustments based on temperature\u0026#34; The above example shows the definition of three processors of different types. GetWeatherForecast is a source of data that generates weather forecast data as type Forecast. Presumably, that data could be used as the input to the flow named GetCurrentTemperature which takes the forecast and puts out temperate changes as indicated by the latest Forecast received. Finally, the AttenuateSenso processor is a sink of data that makes adjustments to a sensor\u0026rsquo;s attenuation based on the temperature.\n"},{"id":34,"href":"/language/root/domain/context/projections/","title":"Projections","parent":"Context","content":" Introduction A projection is a read-only view of entity information. Projections are necessary since entities use event sourcing which is not a query-friendly format.\nHere\u0026rsquo;s the projection process. Usually, events are logged as they are kept appended at the end of the log file. Logs are string and text. To retrieving meaningful information out of logs, logs are transformed into a more query-friendly format and stored in queriable repository or DB.\n"},{"id":35,"href":"/examples/reactivebbq/","title":"Reactive BBQ","parent":"Example","content":"domain ReactiveBBQ is { author is { name: \u0026#34;Reid Spencer\u0026#34; email: \u0026#34;reid@reactific.com\u0026#34; organization: \u0026#34;Reactific Software LLC\u0026#34; title: \u0026#34;President\u0026#34; url: http://reactific.com/ } include \u0026#34;restaurant/domain\u0026#34; include \u0026#34;backoffice/domain\u0026#34; include \u0026#34;corporate/domain\u0026#34; } explained as { | |A domain to encapsulate the entire enterprise named Reactive BBQ. |It is divided into three subdomains: |* Restaurant -- handles each of the restaurant locations |* Back Office -- handles all the back office supplies and menus |* Corporate -- handles the corporate web site, marketing, accounting and HR |This domain definition is designed to be instructive in the RIDDL language. |It uses the case study from the Lightbend Reactive Architecture course as |the basis for defining the domain. The course uses a set of interviews with |Reactive BBQ employees and customers to define the requirements. This domain |specification is a possible result of analyzing that domain: the Reactive BBQ |restaurant. } Everything in RIDDL revolves around creating domains and subdomains. These are logical groupings of definitions that belong together, presumably because they mimic and organizations structure or some other logical, real world groupings. Domains can be nested.\nAt this top level of definition we can see that a single domain named ReactiveBBQ represents the entire enterprise. The details of that top level domain is abstracted away via three include statements within its body, one for each of the subdomains:\nRestaurant Back Office Corporate "},{"id":36,"href":"/language/root/","title":"Root","parent":"Language","content":"The Root level of the definitional hierarchy is the top most concept in the language but there is no syntax to define a \u0026ldquo;Root\u0026rdquo;. Instead, you just create definitions in a file. The \u0026ldquo;Root\u0026rdquo; concept is identical to the file content.\nAt the Root (file) level you can only do two things:\ninclude definitions from another file, define a top level domain For example:\ninclude \u0026#34;other-file\u0026#34; domain foo is { ??? } In this example, we have included all the definitions from \u0026ldquo;other-file\u0026rdquo; but they can only be domain definitions. This example also abstractly defines a domain named foo.\nNow, you can use the tree below to navigate the definitional hierarchy. We recommend you start with Domain and work your way down from there.\nDomain Context Entities State Options Invariants Handler Function Adaptors APIs Saga Projections Features Story Streaming Pipes Processors Plants "},{"id":37,"href":"/language/common/types/","title":"Types","parent":"Common","content":" Introduction The RIDDL language allows users to define data types. Definitions of types are more limited in RIDDL than in programming languages on purpose. The type system must be easily understandable by non-programmers as the domain engineer or domain expert is likely the most frequent user.\nPredefined Types RIDDL supports several predefined types that just \u0026ldquo;exist\u0026rdquo; because they are fundamental and well understood in any targeted computing environment. These predefined type names can be used anywhere that a type definition is needed, for example in a field of an entity\u0026rsquo;s state definition see here\nThe predefined types are:\nString - a sequence of characters of any length Boolean - a binary value for true/false logic Number - a numeric value either integer or decimal Integer - a numeric value that excludes fractional parts Decimal - a numeric value that includes fractional parts Real - a real number Id - a globally unique identifier Date - a date value Time - a time of day value DateTime - a date and a time value together TimeStamp - a date and time combined with at least millisecond accuracy Duration - the amount of time between a start and stop time LatLong - a position on earth Nothing - a type that cannot hold a value URL - a uniform resource locator of any scheme Named Type Definitions In addition to the predefined types, RIDDL supports the definition of new types using a name and a type expression with this syntax:\ntype name = \u0026lt;type-expression\u0026gt; When defining values, one must use a named type defined with the type keyword. This enforces legibility by naming every type expression.\nType Expressions RIDDL supports a variety of type expressions for defining named types. The following sections define the kinds of expressions allowed.\nRenames It is possible to rename a predefined or previously defined type as another type name. This is common to increase domain applicability of the name of a predefined type. For example,\ntype FirstName = String // rename a predefined type for clarity might be used to make it clear that the intended use of the String value is to provide a person\u0026rsquo;s first name.\nBounded Strings The predefined types allow use of unbounded strings but when you want to fix the minimum or maximum length of a string, it may only be used in a type expression. The expression String(\u0026lt;min\u0026gt;, \u0026lt;max\u0026gt;) can be used to define such a type. Both \u0026lt;min\u0026gt; and \u0026lt;max\u0026gt; are optional. \u0026lt;min\u0026gt; defaults to 0, and max defaults to infinite. For example;\ntype FirstName = String(2, 30) // string between 2 and 30 chars inclusive type LastName = String(,30) // string between 0 and 30 chars type Unbounded = String(,) // unbounded, same as just \u0026#34;String\u0026#34; Patterns When you need a string to conform to a regular expression, you can use the Pattern type expression. The expression Pattern(\u0026lt;regex\u0026gt;) will define a string that validates its content according to \u0026lt;regex\u0026gt; which must be a quoted Scala regular expression. If assignment to the string does not match the\u0026lt;regex\u0026gt; then an InvalidateEstateException will be generated. For example, here\u0026rsquo;s a pattern for extracting the three components of a North American telephone number:\ntype NATelephoneNumber = pattern(\u0026#34;\\(?([0-9]{3})\\)?-?([0-9]{3})-?([0-9]{4})\u0026#34;) Range The predefined types allow the use of unbounded integers but when you want to constrict the range of values, you need a Range type expression. The expression Range(\u0026lt;min\u0026gt;,\u0026lt;max\u0026gt;) will define an integer value whose range is restricted to the \u0026lt;min\u0026gt; and \u0026lt;max\u0026gt; values provided. As with bounded strings, the \u0026lt;min\u0026gt; and \u0026lt;max\u0026gt; values are optional and default to 0 and infinity respectively. For example:\ntype Percent = range(,100) // only value 0 to 100 inclusive Restricted Scheme URL The predefined types allow the use of any URL, but when you want to restrict the URL to a specific scheme (e.g. \u0026ldquo;http\u0026rdquo;, \u0026ldquo;mailto\u0026rdquo;) then you can use the URL type expression. The expression URL(\u0026lt;scheme\u0026gt;) specifies a URL that is restricted to the \u0026lt;scheme\u0026gt; specified. For example:\ntype HTTPS_URL = url(\u0026#34;https\u0026#34;) Unique Identifier To define a type that uniquely identifies a runtime entity the Id type expression can be used. It requires a pathIdentifier parameter which specifies the full path (from the root domain) to the runtime entity. For example:\ntype ModelXRef = Id(Autos.Tesla.ModelX) Enumeration An enumeration defines a type that may take the value of one identifier from a closed set of constant identifiers using the any keyword and the set of identifiers enclosed in square brackets, like this:\ntype Color = any of [Red, Orange, Yellow, Green, Blue, Indigo, Violet] Alternation A type can be defined as any one type chosen from a set of other type names using the select keyword followed by type names separated by |, like this:\ntype References = select String | URL There must be at least two types in an alternation.\nAggregation A type can be defined as an aggregate of a group of values of types. DDD calls this a \u0026ldquo;value object\u0026rdquo;. Aggregations can be nested, even recursively. Each value in the aggregation has an identifier (name) and a type separated by a colon. For example, here is the type definition for a rectangle located on a Cartesian coordinate system at point (x,y) with a given height and width:\ntype Rectangle = { x: Number, y: Number, height: Number, width: Number } Key/Value Mapping A type can be defined as a mapping from one type (the key) to another type (the value). For example, here is a dictionary definition that maps a word (lower case letters) to a type named DictionaryEntry that presumably contains all the things one would find in a dictionary entry.\ntype dictionary = mapping from Pattern(\u0026#34;[a-z]+\u0026#34;) to DictionaryEntry Messages An aggregate type (value object in DDD) can be declared to be one of four kinds of message types using the command, event, query, and result keywords. These type definitions are useful for sending messages to entities or across pipelines.\nFor example, here is a command definition:\ntype JustDoIt = command { id: Id(AnEntity), encouragement: String, swoosh: URL } Cardinality A type expression can be adorned with a symbol (adopted from regular expressions) that specifies the cardinality of the type, as follows:\n? - optional, 0 or 1 instances * - zero or more instances + - one or more instances Without the adornment, the cardinality is \u0026ldquo;required\u0026rdquo; (exactly one). For example, in this:\ntype MyType = { ids: Id+, name: String? } the MyType type is an aggregate that contains one or more Id values in the ids field and an optional string value in name\n"},{"id":38,"href":"/language/common/expressions/","title":"Expressions","parent":"Common","content":"RIDDL allows expressions to be specified in various places. Most frequently they are the operands to message constructors and when clauses in Gherkin examples. This page shows you what you can do with expressions in RIDDL.\nExpressions Expressions compute values of arbitrary types. Since RIDDL is not a programming language, the syntax used for expressions is minimal and abstract. There is no attempt in RIDDL to be computationally complete. Supporting expression is merely for the convenience to requirements writers.\nConditional Expressions Conditional expressions, or just conditionals, are expressions that can only evaluate to a boolean value. These are used in places where a conditional value is expected, like in a when clause in a Gherkin example. While any expression value can be considered a conditional, there are several operators (or, and, not and the six comparison operators) that will only yield a conditional value. Arithmetic operators are not considered conditional expression. Function call, field selection, and arbitrary expressions are considered conditionals.\nLISP Style Prefix Syntax RIDDL expressions uses prefix syntax. That is the name of each operator comes first (prefix) and its arguments follow within parentheses and comma separated. For example:\nsqrt(+(4,*(3,@MyState.numberField))) This expression says multiply 3 by the value of \u0026ldquo;MyState.numberField\u0026rdquo; (presumably a numeric field in the state named \u0026ldquo;MyState\u0026rdquo;), add 4 to that, then take the square root of that sum. Note that \u0026ldquo;sqrt\u0026rdquo;, \u0026ldquo;+\u0026rdquo; and \u0026ldquo;*\u0026rdquo; and \u0026ldquo;@\u0026rdquo; are all operators. In the case of @, no parentheses are required.\nOperators In the subsections below we will discuss each of the operators that are defined by RIDDL.\nUndefined Expression: ??? If you don\u0026rsquo;t know what expression is needed, just use RIDDL\u0026rsquo;s undefined operator, which is ???. This can be considered a placeholder for future definition.\nArbitrary Expression: \u0026ldquo;expression\u0026rdquo; RIDDL allows an arbitrary expression which is just a quoted string. When you don\u0026rsquo;t have time, inclination or the details of a computation, just describe it in text. For example:\nexample Foo { when \u0026#34;conditions are right\u0026#34; then set State.Field to \u0026#34;the correct value\u0026#34; } In this example, two \u0026ldquo;arbitrary\u0026rdquo; expressions are used:\nconditions are right presumably resolves to a conditional (boolean) value \u0026quot;the correct valuepresumably resolves to a value compatible with the type of the fieldState.Field` Value Selection: @ The @ operator selects the value of a named thing in the RIDDL definition. The @ is followed immediately by a path identifier such as Domain.Context. Entity.State.Field. The path identifier chosen must specify something that holds a value, for example the fields in a state definition or the message of an on clause (in a handler).\nArithmetic: +, -, / *, %, name Arithmetic values perform computations. The usual five arithmetic operators, + - / * % are permitted and they each take two arguments. Additionally, any function name in all lower case, with 0 or more arguments can be used. The function name is not checked except that it must be in all lower case. For example, sqrt(n), log(n), empty(@list) are all valid expressions.\nFunction Call: Path.To.Function(arg1=expression,\u0026hellip;) An expression may invoke a RIDDL defined function to obtain the expression\u0026rsquo;s value. To make such an invocation, a path identifier is used to locate the function to be invoked and each of its arguments must be supplied between parentheses. Arguments in a function call must be named, unlke in an arbitrary arithmetic operator. For example:\nfunction A { requires { i: Integer} yields { j: Integer } A(i=3) This invokes function A with the required value 3 for \u0026ldquo;i\u0026rdquo; parameter\nComparison Condition: \u0026lt;, \u0026lt;=, ==, !=, \u0026gt;=, \u0026gt; The typical six comparison operators are supported. Each takes two operaonds only and compares them in different ways. The result is a conditional, true or false, depending on how the two values compare. The operators are:\n\u0026lsquo;\u0026lt;\u0026rsquo; - return true if operand 1 is less than operand 2 \u0026lsquo;\u0026lt;=\u0026rsquo; - return true if operand 1 is less than or equal to operand 2 \u0026lsquo;==\u0026rsquo; - return true if operand 1 is equal to operand 2 \u0026lsquo;!=\u0026rsquo; - return true if operand 1 is not equal to operand 2 \u0026lsquo;\u0026gt;=\u0026rsquo; - return true if operand 1 is greater than or equal to operand 2 \u0026lsquo;\u0026gt;\u0026rsquo; - return true if operand 1 is greater than operand 2 Logical: not, or, xor, and Conditional expressions can be combined with the three logical operators:\nnot - evaluates to the opposite of its operand, e.g. if the operand is truethen not(true) yields false. Requires exactly 1 operand. or - evaluates to true if any of its operands are true. Requires a minimum of 2 operands xor - evaluates to true if only one of its operands are true and the others are all false. Requires a minimum of 2 operands. and - evaluates to true if all of its operands are true. Requires a minimum of 2 operands. Constants: True, False, Numbers Constant values such as true and false (both conditionals as well), or any real, floating point, or integer number can be interpreted as expressions too.\nTernary Expression: if(condition,then,else) A computation may include the if operator with three operands. The first operand, condition, is a conditional (true/false) expression that determines whether then, an expression, is the result (condition ==true case) or then, also an expression, is the result (condition == false case).\nGroup Expression: (expression) If if aids in clarity, you may place parentheses around an expression to group it together. With prefix operator notation, this isn\u0026rsquo;t strictly needed but is provided for convenience.\n"},{"id":39,"href":"/audience/developers-guide/","title":"Developer's Guide","parent":"Audience","content":"Developers are the technical experts that advance RIDDL\u0026rsquo;s state of the art. They develop the tooling and documentation that makes up RIDDL. Since RIDDL is an open source project, developers can be affiliated with many organizations, presumably the organizations that derive utility from RIDDL.\nDevelopers must be experts in:\nDomain Drive Design Scala Programming Lanauge Li Haoyi\u0026rsquo;s fastparse Compiler Design Functional programming concepts like folding, AST, etc. Test Driven Development Build Automation Agile Engineering Practices Principles Grammar Terminals Common Domain Context Entity Releasing RIDDL "},{"id":40,"href":"/tooling/riddlc/compilation/","title":"Compilation","parent":"riddlc","content":" Introduction The Riddl compiler performs several analyses which are described in this section and known collectively as compilation. Each of these analyses occurs in a compilation phase, as described in the following sections.\nLexical Analysis Riddl uses the excellent fastparse library by Li Haoyi. This phase parses the raw textual input to make sure it is syntactically correct. From that syntax, an abstract syntax tree (AST) is produced. Incorrect syntax leads to errors without further analysis.\nStructural Analysis If lexical analysis succeeds, an Abstract Syntax Tree (AST) is compiled as the internal representation of the RIDDL source input within the tools\u0026rsquo; memory. Structural Analysis succeeds when the AST is constructed without error. The\nAST represents the containment hierarchy of the input definitions.\nStyle Analysis To aid in reader comprehension, a certain way of using the RIDDL language is recommended. Optionally, the compiler can generate style warnings to indicate language specifications that deviate from that recommended style.\nSemantic Analysis The Riddl AST is very flexible. It can accept a wide range of input, even input that doesn\u0026rsquo;t necessarily make logical sense. For example, suppose you wrote this:\nentity MyLittlePachyderm is { state is { tusk is TuskDefinition } } This defines an entity type named MyLittlePachyderm which can be used as the pattern to instantiate many entities with this form. This entity is defined with a single state value, tusk that has the type TuskDefinition. Note that there is no definition of TuskDefinition as there is for the entity, state and tusk. Consequently, we don\u0026rsquo;t know the type of the tusk field so our specification is incomplete and would fail semantic analysis.\nSemantic analysis, also known as validation, is the process of finding omissions, as described above, as well as:\nreferences to undefined things, references to existing things of the wrong type, constructs that may be confusing, definitional and logical inconsistencies and, etc. The semantic analysis phase generates messages that identify the omissions and inconsistencies in the input specification. These validity issues typically stop the compiler from proceeding with translation because using an invalid input model tends to produce output that is flawed or less than useful.\n"},{"id":41,"href":"/audience/developers-guide/grammar/context/","title":"Context","parent":"Grammar","content":"DDD bounded contexts are represented in RIDDL with the context definition whose syntax is:\n(* RIDDL EBNF Grammar for bounded contexts *) context options = options(\u0026#34;wrapper\u0026#34; | \u0026#34;gateway\u0026#34; | \u0026#34;function\u0026#34;) context include = \u0026#34;include\u0026#34;, literalString context definitions = typedef | entity | adaptor | interaction | contextInclude context = \u0026#34;context\u0026#34;, identifier, is, open, (undefined | context options, context definitions), close, description } "},{"id":42,"href":"/language/root/domain/","title":"Domain","parent":"Root","content":"A domain is the top definitional level in RIDDL. We use the word domain in the sense of a knowledge domain; like an entire business, or some portion of it. It has nothing to do with Internet domain names. A domain is an arbitrary boundary around some subset of concepts in the universe. As with Domain Driven Design, RIDDL uses the concept of a domain to group together a set of related concepts.\nUnlike other definitions in RIDDL, domains can contain other domains. Because of this, we can organize any large, complex knowledge domain or field of study, into a hierarchical ontology. For example, consider these nested domain definitions:\ndomain Automotive { domain Cars { ??? } domain Trucks { ??? } domain Repairs { ??? } } In this example, the Cars domain is nested inside the more general Automotive domain. We would say that Cars is a subdomain of Automotive. Additionally, there are two other subdomains of Automotive: Trucks and Repairs.\nContext Entities State Options Invariants Handler Function Adaptors APIs Saga Projections Features Story Streaming Pipes Processors Plants "},{"id":43,"href":"/language/root/domain/context/features/","title":"Features","parent":"Context","content":"A Feature is a requirement on a context. Features are specified very similarly to the Gherkin language. The same keywords are used and the style is more like RIDDL syntax. If you\u0026rsquo;re already familiar with Gherkin then an example should suffice:\nFeature \u0026#34;Guess the word\u0026#34; is { // The first example has two steps Scenario \u0026#34;Maker starts a game\u0026#34; is { When the Maker starts a game Then the Maker waits for a Breaker to join } // The second example has three steps Scenario \u0026#34;Breaker joins a game\u0026#34; is { Given the Maker has started a game with a word When the Breaker joins the Maker\u0026#39;s game Then the Breaker must guess a word knowing the length of the Maker\u0026#39;s word choice. } Scenario \u0026#34;Breaker makes a guess\u0026#34; is { Given the Maker and Breaker have joined the same game When the Breaker makes a guess And the guess is correct Then the Breaker wins the game And the game is over Else the Breaker may guess again } described by { |The word guess game is a turn-based game for two players. |The Maker makes a word for the Breaker to guess. The game |is over when the Breaker guesses the Maker\u0026#39;s word. } "},{"id":44,"href":"/language/common/includes/","title":"Includes","parent":"Common","content":"An include statement is not a RIDDL definition but an instruction to the compiler to lexically replace the include statement with the content of another file. The name of the file to include is the statement\u0026rsquo;s only parameter, like this:\ninclude \u0026#34;other-file.riddl\u0026#34; The include statement is only permitted where major definitions are expected, specifically at root level, and in the bodies of domain, context, entity, and pipe definitions.\n"},{"id":45,"href":"/tooling/riddlc/translation/openapi/","title":"OpenAPI","parent":"Translation","content":"RIDDL can generate OpenAPI (Swagger) input to document Application Programming Interfaces\n"},{"id":46,"href":"/language/root/domain/streaming/plant/","title":"Plants","parent":"Streaming","content":"A RIDDL plant is a definition that combines pipes with processors to specify a model of how data should flow. You may define as many plants as needed but each plant is a closed system without the ability of the RIDDL model to express the sharing of data between the plants. This is done deliberately to prevent unintentional contamination of data in large models.\nJoints The purpose of a plant definition is to provide the blueprint for how a set of pipes, processors, and entities are joined together so that data may flow end-to-end. This is done by using:\nthe names and types of inlets in processors the names and types of outlets in processors the names and content types of pipes the definition of a joint to connect pipes and processors For example, consider this complete plant definition:\ndomain AnyDomain is { plant SensorMaintenance is { source GetWeatherForecast is { outlet Weather is type Forecast } described by \u0026#34;This is a source for Forecast data\u0026#34; flow GetCurrentTemperature is { inlet Weather is type Forecast outlet CurrentTemp is type Temperature } explained as \u0026#34;This is a Flow for the current temperature, when it changes\u0026#34; sink AttenuateSensor is { inlet CurrentTemp is type Temperature } explained as \u0026#34;This is a Sink for making sensor adjustments based on temperature\u0026#34; pipe WeatherForecast is { transmit type Forecast } explained as \u0026#34;Carries changes in the current weather forecast\u0026#34; pipe TemperatureChanges is { transmit temperature } explained as \u0026#34;Carries changes in the current temperature\u0026#34; joint forecast is outlet GetWeatherForecast.Weather to pipe WeatherForecast joint temp_in is inlet GetCurrentTemperature.weather from pipe WeatherForecast joint temp_out is outlet GetCurrentTemperature.CurrentTemp to pipe TemperatureChanges joint temp_changes is inlet AttenuateSensor.CurrentTemp from pipe TemperatureChanges } explained as \u0026#34;A complete plant definition for temperature based sensor attenuation.\u0026#34; } explained as \u0026#34;Plants can only be specified in a domain definition\u0026#34; In other words, the above plant definition produces this kind of data pipeline: graph LR; subgraph GetWeatherForecast subgraph Weather:outlet end end subgraph GetCurrentTemperature subgraph Weather:inlet end subgraph CurrentTemperature:outlet end end subgraph AttenuateSensor subgraph CurrentTemperature:inlet end end Weather:outlet --\u003e|WeatherForecast| Weather:inlet CurrentTemperature:outlet --\u003e|TemperatureChange| CurrentTemperature:inlet In the diagram, the arrows represent pipes, yellow boxes represent processors and the grey boxes represent the inlet and outlet connection points.\nType Safety Plants are entirely type safe. This means the data type that a pipe transmits must match the data type of the publishing processors (outlets) and the data types of the consuming processors (inlets). When riddlc processes a plant specification, it ensures that all the inlet and outlet data types match the data types of the connected pipes.\nIn the above example, note that each inlet/outlet pair has the same type name (Weather and CurrentTemperature).\nEntities as Processors An entity may also be used as a processor under some special circumstances:\nas a source - An entity may be used as a source of events if a command handler is defined for the entity. as a sink - An entity may be used as a sink for events if a reaction handler is defined for the entity. as a flow - An entity may be used as a flow to convert commands into events Bulkheads "},{"id":47,"href":"/audience/developers-guide/principles/","title":"Principles","parent":"Developer's Guide","content":"RIDDL is a high level system specification language and as such must obey some principles of such languages. This page provides those principles.\n1: Declarative RIDDL is not an implementation language and does not pretend to be computationally complete. RIDDL adopts this what not how principle. Details are for software developers. The analyst or architect that writes RIDDL documents wants to only specify what the system is while abstracting away the process of constructing it. It is like city planning, not the processes of laying pipes, providing power and paving roads. The end user ought to be as comfortable reading it as the developer.\nA specification is a statement of what needs to be produced, but not how it is to be realized (implemented). RIDDL specifications are aimed at modelling large, complicated knowledge domains. A RIDDL model must be complete enough that all the parts of it are recognizable and what it will do is discernable, but without understanding how it will be produced.\nConsequently, RIDDL is a declarative specification language.\n2: Both Data And Process RIDDL models appreciate that the dichotomy between \u0026ldquo;doing\u0026rdquo; (process) and \u0026ldquo;being\u0026rdquo; (data) is false. Modern computing systems that model reality must be both in our view. Thus, strictly data-oriented specification languages nor strictly process-oriented specification languages will suffice. RIDDL must be both. While we are human beings we must also be human doings; or as Kurt Vonnegut published in \u0026ldquo;Deadeye Dick\u0026rdquo;:\nSocrates: To be is to do\nSartre: To do is to be\nSinatra: Do be do be doooo.\n3: Completeness The specification must provide the implementors all the information they need to complete the implementation of the system, and no more.\n4: Sufficiently Formal A RIDDL specification should be sufficiently formal so that it can conceivably be tested for consistency, correctness, completeness, and other desirable properties. Theriddlc compiler for RIDDL input aims to achieve exactly this, automatically.\n5: Familiar Terms The specification should discuss the system in terms that are normal and common for the users, implementors and subject-matter experts of the system. While RIDDL does introduce keywords that require some explanation (hence this documentation), one of the primary motivations for using DDD as a primary model for the language is to reinforce this principle.\n6: Rapidly Translatable The RIDDL specification language exists to reduce the burden on system architects, business analysts, and others who must manage complexity and large volumes of concepts. Without the ability to rapidly translate the specification into other useful artifacts, the language would not have high utility. RIDDL can therefore be used to produce:\nComplete documentation websites for the model specified in RIDDL Various kinds of diagrams for better visual comprehension of the model Various kinds of code artifacts to ease the software developers burden Other artifacts through extension plugins "},{"id":48,"href":"/examples/restaurant/","title":"Restaurant","parent":"Example","content":"domain Restaurant is { type CustomerId is Id(Customer.Customer) explained as \u0026#34;Unique identifier for a customer\u0026#34; type OrderId is Id(Order.Order) described as \u0026#34;Unique identifier for a customer\u0026#39;s order\u0026#34; type LocationId is Id(Location.Location) type LoyaltyId is Id(Loyalty.LoyaltyAccount) type OrderViewerId is Id(Kitchen.OrderViewer) type ReservationId is Id(Reservation.Reservation) type PaymentId is Id(Payment.Payment) type ServerId is Id(Server.Server) type TableId is Id(Table) include \u0026#34;Customer\u0026#34; include \u0026#34;Kitchen\u0026#34; include \u0026#34;Location\u0026#34; include \u0026#34;Loyalty\u0026#34; include \u0026#34;Menu\u0026#34; include \u0026#34;Order\u0026#34; include \u0026#34;Payment\u0026#34; include \u0026#34;Reservation\u0026#34; include \u0026#34;Server\u0026#34; include \u0026#34;Table\u0026#34; } explained as { |This subdomain pertains to all processes and data associated with a single restaurant location. |It includes several bounded contexts, as noted by the include statements above. To make the entity |Id\u0026#39;s ubiquitous for the domain, their type definitions are defined at the domain level. } "},{"id":49,"href":"/language/root/domain/streaming/","title":"Streaming","parent":"Domain","content":"RIDDL supports the definition of complex data streaming models. There are two basic definitions involved in setting up a pipeline: a pipe, and a a processor. There are several kinds of pipes and processors, and they can be combined to form entire systems of data processing known as a plant. These metaphors come from chemical processing\nconcepts which you can visualize as something like this:\nPipes - Pipes are conduits for reliably transmitting messages of a particular type of data from publishers to consumers of that data type that are connected to the pipe. Processors - While pipes reliably transport data from its producers to its consumers, processors are the producers, consumers, and transformers of data. Notably, entities are processors of pipes too. Plants - Plants combine pipes and processors together with support for rich semantics so that arbitrarily complex streams can be modeled in RIDDL. "},{"id":50,"href":"/tooling/","title":"Tooling","parent":"Home","content":"This section covers the various tools that RIDDL provides and how to build, install and use them. There is a subsection for each tool provided, as follows\nriddlc How To Build `riddlc` Installing `riddlc` Compilation Translation riddlc options Binary AST Diagrams Hugo Docs OpenAPI Kalix Akka Other Translators "},{"id":51,"href":"/examples/backoffice/","title":"Back Office","parent":"Example","content":""},{"id":52,"href":"/audience/developers-guide/grammar/entity/","title":"Entity","parent":"Grammar","content":" (* RIDDL EBNF Grammar For Entity definition *) entity = entity kind, \u0026#34;entity\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;{\u0026#34;, entity options, entity definitions, \u0026#34;}\u0026#34;, description ; entity kind = [ \u0026#34;device\u0026#34; | \u0026#34;actor\u0026#34; | \u0026#34;concept\u0026#34;] ; entity options = single option | multi options ; single-option = \u0026#34;option\u0026#34;, \u0026#34;is\u0026#34;, entity option kinds; multi-option = \u0026#34;options\u0026#34;, \u0026#34;(\u0026#34;, { entity option kinds }, \u0026#34;)\u0026#34;; entity option kinds = \u0026#34;event sourced\u0026#34; | \u0026#34;value\u0026#34; | \u0026#34;aggregate\u0026#34; | \u0026#34;persistent\u0026#34; | \u0026#34;consistent\u0026#34; | \u0026#34;available\u0026#34;; entity definition = handler | feature | function | invariant | typeDef | state; entity definitions = entity definition { entity definition } ; entity state = \u0026#34;state\u0026#34;, identifier, \u0026#34;is\u0026#34;, \u0026#34;{\u0026#34;, identifier, \u0026#34;is\u0026#34;, typeExpression, \u0026#34;}\u0026#34;, description State A state is defined with the state keyword in the content of an entity using this syntax:\nstate = \u0026#34;state\u0026#34;, identifier, \u0026#34;is\u0026#34;, aggregate, description For details see the following production descriptions\n"},{"id":53,"href":"/language/common/functions/","title":"Functions","parent":"Common","content":" Introduction Functions are pieces of processing that can be attached to entity, consumer, and api definitions. A function has a set of inputs (its requirements) and a set of output (what it yields). Functions need not be pure and often have side effects through the state changes of an entity.\nExample Here\u0026rsquo;s an example of a function, named riddle, that requires a Subject(String) type and returns a Riddle (String) type. Presumably, it generates a riddle in any subject.\ntype Subject = String type Riddle = String function riddle is { requires {s: Subject} yields { r: Riddle } } Applicability Functions have applicability across several RIDDL definitions:\nContext APIs - APIs are collections of functions Entity Handler - As utilities in an entity [handler](Encapsulate repeating logic from a consumer\u0026rsquo;s on clause) Allow internal entity processing to be specified as part of an interaction etc. Further Content: TBD\n"},{"id":54,"href":"/audience/developers-guide/grammar/","title":"Grammar","parent":"Developer's Guide","content":"This section defines the RIDDL language\u0026rsquo;s grammar formally.\nExtended Backus-Naur Form When RIDDL grammar definitions are shown, we use the EBNF grammar meta-language to specify the grammar. You can read about this grammar meta-language on Wikipedia\nFor example, here\u0026rsquo;s how EBNF can define a quoted string:\nall characters = ? any utf-8 character ? ; quoted string = \u0026#39;\u0026#34;\u0026#39;, { all characters - \u0026#39;\u0026#34;\u0026#39; }, \u0026#39;\u0026#34;\u0026#39;; This form can be quite technical and is intended for those who are familiar with EBNF format and lexical parsing. For a more descriptive introduction to the language, please refer to the Audience section.\nThe RIDDL syntax grammar is broken down into the following portions:\nterminals - Terminal symbols used in the grammar common - Common grammar productions used in other files root - Top level root level (\u0026ldquo;file scope\u0026rdquo;). domain - Defining domains context - Defining contexts entity - Defining entities "},{"id":55,"href":"/language/root/domain/context/entity/handler/","title":"Handler","parent":"Entities","content":"A handler in an entity specifies how an entity handles its input messages.\nHandlers are specified with the handler keyword and enclose a set of on clauses that specify what to do with a given event when that handler is active. There are four kinds of on clauses distinguished by the kind of message they handle (command, event, query, and reaction) as detailed in the following sections\nCommand Handler A command handler specifies which persistent event is generated for a given command. For example:\ntype JustDoIt = command { id: Id(AnEntity), encouragement: String } type JustDidIt = event { id: Id(AnEntity), encouragement: String } on command JustDoIt yields JustDidIt Event Handler An event handler specifies how an event modifies the state of the entity.\nstate State is { name: String } type event NameWasUpdated { id: Id(AnEntity), newName: String } on event NameWasUpdated { replace State.name with NameWasUpdated.newName } Reaction Handler A reaction handler is used to specify how an entity converts a foreign event (from another entity in the same bounded context) into a command for altering its own state. This is also how we avoid corruption of the entity\u0026rsquo;s ubiquitous language by converting another bounded context\u0026rsquo;s concept into the handler\u0026rsquo;s entity\u0026rsquo;s concept.\ndomain Path is { domain To is { context Context is { type ThingThatHappened is event { id: Id(Entity), whatHappened: String } } } } domain Foo { context Bar { entity Example { type ExternalThingHappened = event { id: Id(Example), whatHappened: String } on event Path.To.Context.ThingThatHappened yields ExternalThingHappened } } } Notes:\nPath.To.Context.ThingThatHappend is known as a path identifier. Query Handler A query handler associates a query message to the result message that the query returns along with the SQL statement that yields the result set.\ntype JustGetIt = query { id: Id(AnEntity) } type JustGotIt = response { id: Id(AnEntity), count: Integer } on query JustGetIt return JustGotIt from \u0026#34;SELECT id, count FROM AnEntity WHERE id = %id\u0026#34; Defining Multiple Handlers An entity can make use of multiple handlers so that the behavior of and entity can be changed. There can be only one handler active at any moment, but an entity can change which handler is active in response to any message. This ability permits a set of handlers to model a finite state machine where each handler is a state and each on clause is a transition. When a handler is active, any messages received that are not explicitly defined by the handler will simply be ignored.\n"},{"id":56,"href":"/tooling/riddlc/translation/kalix/","title":"Kalix","parent":"Translation","content":"The Kalix platform-as-a-service system represents one of the easiest methods by which RIDDL models can be turned into running systems. The riddlc program generates Kalix style protobuffers files from the RIDDL model. Kalix uses these files to generate Scala, Java, Javascript or Python code with a fill-in-the-blanks style for just the business logic.\n"},{"id":57,"href":"/tooling/riddlc/translation/","title":"Translation","parent":"riddlc","content":"The RIDDL compiler, riddlc is able to translate RIDDL into a variety of other document types, after the input passes the compilation phases.\nThe various kinds of output from riddlc are described in the following sections:\nBAST - Binary Abstract Syntax Tree. Generates files that capture the abstract syntax tree (AST) in a transportable binary format Diagrams - Data flow, sequence, entity, context maps, and other Hugo - Hugo source input for producing an HTML website diagrams are all automatically deduced from the RIDDL model OpenAPI - OpenAPI (formerly called Swagger) specifications for APIs implied in the RIDDL model Kalix - Kalix protobuffers source generation as input to the Kalix code generator. Akka - Akka, protobuffers, Alpakka infrastructure code \u0026amp; skeleton Others - plugins can be written to convert the AST into any other kind of needed data It is recommended that you become familiar with the riddlc "},{"id":58,"href":"/language/root/domain/context/entity/functions/","title":"Function","parent":"Entities","content":"TBD\n"},{"id":59,"href":"/tooling/riddlc/translation/akka/","title":"Akka","parent":"Translation","content":"The goal of the Akka translator is to generate all the infrastructure code needed to support the domain(s) defined in the RIDDL input. While this does produce a working system, it also relieves developers of much of the repetitive, detail oriented infrastructure that is relatively boring compared to the business logic of the system.\nThis translator recognizes that its output will be co-mingled with the business logic output that developers are writing and keeps them separate. When an expected developer file does not exist, it will create it, but otherwise uses Scala inheritance, or other mechanisms, to indicate the portions that ought to be written.\nOutput File Types The Akka translator doesn\u0026rsquo;t just generate Scala code. It aims to generate complete projects that should be familiar to those famliar with Scala and Akka projects. This means generating a mixture of file types, as described in the following sections\nsbt build files build.sbt project/xxx.scala project/build.properties project/plugins.sbt\nprotobuffers definitions Specifically processed by akka-grpc (via scalapb via protoc plugins)\nScala code Build Time Dependencies sbt 1.6 or later sbt-riddl plugin akka-grpc sbt plugin buildinfo sbt plugin Runtime Dependencies Akka 2.6.17 (or later) including streams, http, cluster, persistence, \u0026hellip; Alpakka 3.x Kafka Comparison To Akka Serverless The Akka Translator has an objective to support both the advanced Akka Scala developer and less knowledgeable developers. It does that by using Scala\u0026rsquo;s abstraction features but without completely disconnecting from Akka\u0026rsquo;s powerful features. For example:\nActors are used, but in a fill-in-the-blank way. Advanced programmers can still do more complicated things, neophytes will find it easy. Does not use GRPC as the interface like Akka Serveless does. Scala is the interface and there is no side-car aspect in the runtime. "},{"id":60,"href":"/examples/corporate/","title":"Corporate","parent":"Example","content":""},{"id":61,"href":"/language/common/imports/","title":"Imports","parent":"Common","content":" This feature is not implemented yet.\nAn import statement may be used to import a definition from a BAST file that was generated from a prior compilation. Import statements help to save time when a prior compilation has completed and been saved as a BAST file.\n"},{"id":62,"href":"/examples/","title":"Example","parent":"Home","content":"Some people can learn RIDDL faster by looking at examples than by reading the informal definitions in the language guide or the formal definitions in the grammar section. To support that mode of learning, this section decomposes the domain of a restaurant, Reactive BBQ.\nThis section provides some examples of how RIDDL can be used.\nAbout Reactive BBQ The Reactive BBQ domain is a familiar one for those who have taken the\nLightbend Reactive Architecture Professional (LRA-P) course which uses this example throughout the course to good effect in the workshops. The same premises apply in this domain but we have chosen to fully specify it in RIDDL.\nAs you might guess from the name, Reactive BBQ is a restaurant chain that serves spicy (reactive!) BBQ dishes. It doesn\u0026rsquo;t exist of course, even if employees may or may not have mistaken R\u0026amp;R BBQ in Salt Lake City for the Reactive version in 2018.\nThe Reactive BBQ case study in the LRA-P course included interviews with several fictitious employees. Those interviews and the case study material have been replicated here with thanks to Lightbend; and we recommend that you read that scenario first.\nThe RIDDL files for Reactive BBQ are arranged into a directory structure, each with an explanation page as follows:\nReactive BBQ Domain Restaurant BackOffice Corporate "},{"id":63,"href":"/tooling/riddlc/translation/others/","title":"Other Translators","parent":"Translation","content":""},{"id":64,"href":"/language/common/options/","title":"Options","parent":"Common","content":"Many definitions can have options. These are hints or processing instructions to the various translator tools.\nneed more detail "},{"id":65,"href":"/tutorial/","title":"Tutorial","parent":"Home","content":"Some people can learn RIDDL faster by looking at examples than they can by reading the informal definitions in the language guide or the formal definitions in the grammar section. To support that mode of learning, this tutorial decomposes the domain of a fictitious restaurant, The Reactive BBQ.\nAs you will see, the Reactive BBQ is an expansive domain. As such, this tutorial will not attempt to have you specify the entire domain. Rather, we will work through each feature of the RIDDL language by considering examples from inside the Reactive BBQ domain. We have fully specified it so that you have a concrete reference implementation and the companion language references to guide you. You can find the fully implemented Reactive BBQ RIDDL specification here. The language reference can be found here.\n"},{"id":66,"href":"/future-work/","title":"Future Work","parent":"Home","content":"This section provides some insight into our plans to extend RIDDL or use it in novel ways:\nAkka source generation Kubernetes deployment descriptors Protobuffers message and service definitions Fast data message streaming infrastructure Details TBD\n"},{"id":67,"href":"/audience/developers-guide/releasing/","title":"Releasing RIDDL","parent":"Developer's Guide","content":"This is a \u0026ldquo;how to\u0026rdquo; guide on releasing the software.\nBuild \u0026amp; Test \u0026gt; cd riddl # top level directory of repository \u0026gt; sbt \u0026#34;clean ; test\u0026#34; ... [info] All tests passed. If all tests do not pass, stop and fix the software\nSet Version Pick a version number, x.y.z, based on current version and semantic versioning rules Formulate a short description string for the release, call it desc % sbt \u0026gt; git tag -a ${x.y.z} \u0026#34;${desc}\u0026#34; \u0026gt; reload \u0026gt; show version \u0026gt; git push --tags When you run the git commands from the SBT command prompt, you must reload in order to get the correct build version number into the artifacts. Failing to do this will attempt to release a snapshot version which won\u0026rsquo;t go well for you. Release To Maven First, publish the artifacts to oss.sonatype.org % cd riddl % sbt publishSigned When that is complete, log in to https://oss.sonatype.org/#stagingRepositories Check the staged artifacts for sanity. All modules should be published with the same release number Close the repository and add the release number in the notes Press the Release button to publish to maven central Build Release Artifacts % sbt \u0026gt; project riddlc \u0026gt; Universal/packageBin \u0026gt; Universal/packageOsxDmg Create Release On GitHub open https://github.com/reactific/riddl/releases/new pick the tag that you just made write the release notes Upload Artifacts Click the area on github new release page that says: Attach binaries by dropping them here or selecting them.\nAttach these files: riddl/riddlc/target/universal/riddlc-${x.y.z}.zip riddl/riddlc/target/universal/riddlc-${x.y.z}.dmg Update riddl-actions Open https://github.com/reactific/riddl-actions/edit/main/riddlc/action.yaml Scroll to the bottom of the page Update the version numbers (3 times) in the last lines of teh file to match the ${x.y.z} version you released above. Create a ${x.y.z} tag on your change and push it. Update riddl-examples Open https://github.com/reactific/riddl-examples/edit/main/.github/workflows/gh-pages.yml On line 22 change the riddl-action version number at the end to ${x.y.z} "},{"id":68,"href":"/audience/authors-guide/design-tips/","title":"Design Tips","parent":"Author's Guide","content":" title: \u0026ldquo;Design Tips\u0026rdquo; description: \u0026ldquo;Tips On Designing RIDDL Specificatons\u0026rdquo; date: 2022-02-25T10:50:32-07:00 draft: true weight: 10 Domain Hierarchy When considering how to organize your specification into a set , there are no formal rules. Domains are fuzzy concepts on purpose. However, here are a few things that might help:\nDomain, Subdomain, Bounded Context, Problem/Solution Space in DDD: Clearly Defined Domain Drive Design: Domain Definition Use the communication structure of the organization per Conway\u0026rsquo;s Law Use the Event Storming and then look for the event groupings. Isolated groups are typically subdomains. "},{"id":69,"href":"/privacy-policy/","title":"Privacy Policy","parent":"Home","content":" Static Web Site This is a static site. It does not use cookies, has no ability to collect your information, and does not invade your privacy. This site is merely for documentation that you may use as you see fit.\n"},{"id":70,"href":"/contact/","title":"Contact Us","parent":"Home","content":"TBD\n"},{"id":71,"href":"/search/","title":"Search Result","parent":"Home","content":""},{"id":72,"href":"/tags/","title":"Tags","parent":"Home","content":""}]