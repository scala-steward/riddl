<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concepts on RIDDL Documentation</title><link>https://riddl.tech/concepts/</link><description>Recent content in Concepts on RIDDL Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>reid@reactific.com (Reid Spencer)</managingEditor><webMaster>reid@reactific.com (Reid Spencer)</webMaster><atom:link href="https://riddl.tech/concepts/index.xml" rel="self" type="application/rss+xml"/><item><title>Action</title><link>https://riddl.tech/concepts/action/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/action/</guid><description>An Action is something a program does. Actions are used in the then and but clauses of an example.
There are many kinds of Actions, described in the table below
Name Description Append Add an item to a field that is a collection Arbitrary A textually described arbitrary action Ask Send a message to an entity, asynchronously process result Become Instructs an entity change to a new handler Compound Execute a group of nested actions Error Produce an error with a message FunctionCall Call a function to get a result Morph Morph the state of an entity to a new state Publish Publish a message to a pipe Reply Provide the reply message to the entity that invoked a query Return Return a value from a function Set Set a field of the current state of an entity Tell Send a message to an entity, do not wait for result Yield Place a message on an entity&amp;rsquo;s event pipe Applicability Not all actions can be used in every situation.</description></item><item><title>Adaptation</title><link>https://riddl.tech/concepts/adaptation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/adaptation/</guid><description>An adaptation is a single component of an adaptor that defines a specific kind of translation or adaptation to undertake. There are several kinds of adaptations that can be defined, all pertain to message handling.
Name Description EventCommand Transformation of an incoming Event to a Command CommandCommand Transformation of an incoming Command to another Command EventAction Transformation of an incoming Event to a set of Actions CommandAction Transformation of an incoming Command to a set of Actions Occurs In Adaptors Contains Examples</description></item><item><title>Adaptor</title><link>https://riddl.tech/concepts/adaptor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/adaptor/</guid><description>An adaptor&amp;rsquo;s purpose is to adapt one context to another. In Domain-Driven Design, this concept is known as an anti-corruption layer. We didn&amp;rsquo;t like that term for a variety of reasons so we have renamed the concept as adaptor in RIDDL. Same idea, different name.
Adaptors simply bundle together a set of adaptations. The actions they take are aimed at the context that contains the adaptor or any entity or projection within that context.</description></item><item><title>Application</title><link>https://riddl.tech/concepts/application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/application/</guid><description>An application in RIDDL represents an interface portion of a system where an actor (human or machine) initiates an action on the system. Applications only define the net result of the interaction between the actor and the application. That is, there is nothing in RIDDL that defines how information is provided nor received. This gives free latitude to the user interface designer to manage the entire interaction between human and machine.</description></item><item><title>Application View</title><link>https://riddl.tech/concepts/view/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/view/</guid><description>TBD</description></item><item><title>Author</title><link>https://riddl.tech/concepts/author/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/author/</guid><description>An author definition merely describes one of the authors that wrote the encapsulating definition. An author definition contains the usual profile information for a human including:
full name email address name of an organization (optional) title at that organization (optional) url for more information (optional) Occurs In All vital definitions
Contains No other definitions</description></item><item><title>Context</title><link>https://riddl.tech/concepts/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/context/</guid><description>A context definition in RIDDL represents the notion of a bounded context from Domain Driven Design (DDD). A bounded context is an isolated portion of some knowledge domain. Consequently, in RIDDL we defined a context inside a domain. DDD uses bounded contexts to divide complexity in large knowledge domains into manageable portions. Since large knowledge domains are difficult for a single human to comprehend in its entirety, DDD uses bounded contexts as a primary structuring tool.</description></item><item><title>Description</title><link>https://riddl.tech/concepts/description/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/description/</guid><description>Descriptions describe definitions. You can add a description to any kind of definition. Descriptions are written in Markdown format and can include any of the capabilities provided by the GeekDoc hugo formatter including mermaid based diagrams.
Occurs On All definitions
Contains Markdown text either directory or in a file.</description></item><item><title>Domain</title><link>https://riddl.tech/concepts/domain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/domain/</guid><description>A domain is the top-most definitional level in RIDDL. We use the word domain in the sense of a knowledge domain; like an entire business, or some portion of it. It has nothing to do with Internet domain names. A domain is an arbitrary boundary around some subset of concepts in the universe. As with Domain Driven Design, RIDDL uses the concept of a domain to group together a set of related concepts.</description></item><item><title>Entity</title><link>https://riddl.tech/concepts/entity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/entity/</guid><description>An entity in RIDDL is the same as it is in DDD which defines it this way:
Entity Definitions
An object primarily defined by its identity is called an Entity.
and
Many objects are not fundamentally defined by their attributes, but rather by a thread of continuity and identity.
There are three main aspects to this definition of entity:
Entities are in the software implementation of the model are objects, containing both state and function.</description></item><item><title>Example</title><link>https://riddl.tech/concepts/example/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/example/</guid><description>The concept for a RIDDL Examples is very similar to Dan North&amp;rsquo;s Gherkin Examples. Gherkin has been used for many years to specify test cases that service a functional specifications as well. Gherkin is simple enough for anyone to understand them.
In RIDDL this idea is used to specify the functionality for any of the vital definitions. An Example is structured like this:
GIVEN condition (optional) WHEN condition (optional) THEN action ELSE action (optional) The intent here is to express how in some circumstance (GIVEN), when a particular thing happens (WHEN), take some action (THEN), otherwise in that circumstance if that thing does not happen take some other actions (ELSE).</description></item><item><title>Expression</title><link>https://riddl.tech/concepts/expression/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/expression/</guid><description>TBD
Literal Expressions (#literal) TBD
Numeric Expressions (#numeric) TBD
Conditions (Boolean Expressions) TBD
Occurs In Actions Contains Nothing</description></item><item><title>Field</title><link>https://riddl.tech/concepts/field/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/field/</guid><description>Fields are the unit of composition of an aggregate type, state, or projection. A field is a simple mapping of a name to a type. For example:
name: Number
specifies that the field named name has type Number. Fields are used in actions and expressions to supply values over which computations are performed.
Occurs In Types States Projections Contains Nothing</description></item><item><title>Function</title><link>https://riddl.tech/concepts/function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/function/</guid><description>A function definition provides a way to not repeat yourself in other definitions. We can define functions in several places and then use them in an expression or action. This way, we only need to define the logic for something once.
Occurs In Contexts Entities Handlers Contains Fields Examples Functions</description></item><item><title>Handlers</title><link>https://riddl.tech/concepts/handler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/handler/</guid><description>A handler is a definition of how to handle messages. A handler contains a set of on clauses that specify what to do for the various kinds of messages.
There are several kinds of handlers depending on the definition type of the parent definition. A quick summary is shown in this table:
Occurs In Handler Focus Adaptor Adapt messages for a bounded context Context Implements API of the stateless context Entity Handler to use on new entity before any morph action Projection Handle updates and queries on the projection State Handle messages while entity is in that state More details are provided in the sections below.</description></item><item><title>Includes</title><link>https://riddl.tech/concepts/include/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/include/</guid><description>Includes permit you to include content from a file into the definition in which it occurs.
Occurs In All vital definitions
Contains Content relevant to the definition in which it is used, as follows:
Adaptor Adaptations Context Options Types Handlers Functions Includes AuthorInfos Entity Adaptor Saga Processor Term Projection Domains Pipe Processor InletJoint OutletJoint Term Include AuthorInfo Entities: Options States Types Handlers Functions Invariants Includes AuthorInfos</description></item><item><title>Inlets</title><link>https://riddl.tech/concepts/inlet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/inlet/</guid><description>An Inlet is a component of a Processor that specifies a named input through which data of a particular type streams into the processor.
Occurs In Processors Contains Nothing</description></item><item><title>Invariants</title><link>https://riddl.tech/concepts/invariant/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/invariant/</guid><description>An invariant is a logical expression that must always hold true. They can be used to validate state changes in entities, or parameter values in functions.
Occurs In Entities - specifies a rule on the state of an entity Functions - specifies a rule on the input parameters of a function Contains Nothing</description></item><item><title>Joints</title><link>https://riddl.tech/concepts/joint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/joint/</guid><description>Joints join Processor Inlets or Outlets to pipes. There are two kinds of joints:
InletJoint - connects an Inlet to a Pipe OutletJoint - connects and Outlet to a Pipe Joints are necessary to set up a pipeline in a Plant which must flow data from source to [sink](/concepts/processor/].
Occurs In Plants Contains Nothing</description></item><item><title>Messages</title><link>https://riddl.tech/concepts/message/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/message/</guid><description>Messages are just aggregate type definitions that have special significance in RIDDL. Messages make up the lingua franca of the API of a context or entity. That is, these are the fundamental building blocks of a message-driven system
Differences Between Kinds of Messages Kind Request? Response? Cancellable? Relationship Command Yes No Yes Independent Event Maybe Yes No Consequent Of Command Query Yes No Yes Independent Result No Yes No Consequent Of Result The truth table above helps you understand the relationship between the kind of message and how it is handled by an entity.</description></item><item><title>On Clauses</title><link>https://riddl.tech/concepts/onclause/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/onclause/</guid><description>An On clause specifies how to handle a particular kind of message for a handler
Occurs In Handlers - the handler to which the On clause is applied Contains Examples - specifies what should happen when the event occurs</description></item><item><title>Options</title><link>https://riddl.tech/concepts/option/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/option/</guid><description>Options are instructions to translators on how a particular definition should be regarded. Any translator can make use of any option.
Occurs In All vital definitions
Contains Option values which are simple identifiers with an optional string arguments.</description></item><item><title>Outlets</title><link>https://riddl.tech/concepts/outlet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/outlet/</guid><description>An Outlet is a component of a Processor that specifies a named input through which data of a particular type streams out of the processor.
Occurs In Processors Contains Nothing</description></item><item><title>Pipes</title><link>https://riddl.tech/concepts/pipe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/pipe/</guid><description>Pipes are uni-directional conduits for reliably transmitting data of a particular type. Pipes always make connections between an InletJoint (the source of data) and an OutletJoint. These joints are always attached to a processor, even possibly the same processor (making a feedback loop).
Data Transmission Type Pipes can transmit any data type that RIDDL can specify. There is only one data type that flows in a pipe. The transmission type is often used with an alternation of messages such as the commands and queries that an entity might receive.</description></item><item><title>Plants</title><link>https://riddl.tech/concepts/plant/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/plant/</guid><description>RIDDL supports the definition of complex data streaming models. There are three basic definitions involved in setting up a pipeline: a plant, a pipe, and a processor. There are several kinds of pipes and processors, and they can be combined to form entire systems of data processing known as a plant. These metaphors come from chemical processing concepts which you can visualize as something like this:
All you have to do is remember the 3 P&amp;rsquo;s:</description></item><item><title>Processors</title><link>https://riddl.tech/concepts/processor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/processor/</guid><description>A processor is a component of any vital definition. Processors perform some transformation, typically, of the data flowing in from itsinlet(s) and produces some, potentially different, data to its [outlet(s)]({{&amp;gt; relref outlet &amp;gt;}}).
Inlets An (inlet)[/concepts/inlet/] provides the name and data type for an input to the processor. There can be multiple inlets to the processor or none. A processor with no inlets defined is called a source since it originates data by itself.</description></item><item><title>Projections</title><link>https://riddl.tech/concepts/projection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/projection/</guid><description>Projections get their name from
Euclidean Geometry but are probably more analogous to a relational database view. The concept is very simple in RIDDL: projections gather data from entities and other sources, transform that data into a specific data format, and support querying that data arbitrarily.
Projections transform update events from entities into a data set that can be more easily queried. Projections have handlers that specify both how to apply updates to the projections state and satisfy queries against that state.</description></item><item><title>Root</title><link>https://riddl.tech/concepts/root/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/root/</guid><description>The root concept refers to the container of domains. Domains are the top level definition in RIDDL but because RIDDL is hierarchical, and you can have more than one domain definition at the top level, something has to contain those top level domains. We call that the root. A root is not a definition since it has no name. You can think of a root as the file in which a domain is defined.</description></item><item><title>Saga Steps</title><link>https://riddl.tech/concepts/sagastep/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/sagastep/</guid><description>One step in a saga. Each step has input arguments and yields output. It also has both do and undo examples for its action and compensating action.
Occurs In Contexts Contains Examples</description></item><item><title>Sagas</title><link>https://riddl.tech/concepts/saga/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/saga/</guid><description>A Saga is a distributed persistent transaction that uses the Saga Pattern. Sagas are used to coordinate state changes across multiple components (typically entities) in a system.
Occurs In Contexts Contains SagaStep</description></item><item><title>States</title><link>https://riddl.tech/concepts/state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/state/</guid><description>A State is the storage of an entity. It is defined as a set of fields with a handler that defines how messages cause changes to the value of those fields.
An entity can have multiple state definitions with the implication that this entity would be considered a Finite State Machine. However, it would only be such if the entity used the finite state machine option
Occurs In Entities Contains Fields</description></item><item><title>Stories</title><link>https://riddl.tech/concepts/story/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/story/</guid><description>A story in RIDDL is a definition that defines a user story. This is the same concept as the idea Kent Beck introduced in 1997. In RIDDL, a story gets a little more involved than the usual formulations of a user story:
As an {actor}, I would like {capability}, so that {benefit}
or
In order to receive {benefit}, as an {actor}, I can {capability}
which have these three ideas:
An actor that provides the role played by the narrator of the story A capability that provides the capability used by the narrator A benefit that provides the reason why the narrator wants to use the capability A RIDDL Story also provides a set of cases that relate the story to other RIDDL components through the steps taken for each [case](/concepts/case/.</description></item><item><title>Story Case</title><link>https://riddl.tech/concepts/case/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/case/</guid><description/></item><item><title>Terms</title><link>https://riddl.tech/concepts/term/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/term/</guid><description>A Term is merely a glossary entry. Since DDD requires bounded contexts to have precise terminology, the Term definition allows model authors to include a word definition that is not a definition in the model.
Occurs In All vital definitions
Contains Nothing</description></item><item><title>Types</title><link>https://riddl.tech/concepts/type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/type/</guid><description>Introduction The RIDDL language allows users to define types of data, or information. RIDDL&amp;rsquo;s type system is fairly rich, for a specification language, providing abstractions for many concretely common information structures. This is done to make it easier for domain engineers and experts to understand the models they are creating.
A type defines the shape of some information. There are many kinds of type definitions allowed, so we have grouped them into categories:</description></item><item><title>Vital Definitions</title><link>https://riddl.tech/concepts/vital/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/concepts/vital/</guid><description>Not all definitions are equal. The RIDDL language considers some definitions to be more important than others, and we call these &amp;ldquo;vital definitions&amp;rdquo;. You can recognize a vital definition because they all have
Examples somewhere in their definitional hierarchy.
These are the vital definitions:
Adaptors, Contexts, Domains, Functions, Entities, Handlers, Plants, Processors, Projections, Sagas, and Stories.</description></item></channel></rss>