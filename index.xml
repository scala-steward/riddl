<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on RIDDL Documentation</title><link>https://riddl.tech/</link><description>Recent content in Home on RIDDL Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>reid@reactific.com (Reid Spencer)</managingEditor><webMaster>reid@reactific.com (Reid Spencer)</webMaster><lastBuildDate>Wed, 01 Dec 2021 15:34:22 -0500</lastBuildDate><atom:link href="https://riddl.tech/index.xml" rel="self" type="application/rss+xml"/><item><title>riddlc options</title><link>https://riddl.tech/tooling/riddlc/translation/options/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/tooling/riddlc/translation/options/</guid><description>Introduction Like many other complex programs, riddlc implements a variety of commands, each with their own functionality and their own options. As there are overlaps
Options come and go as riddlc evolves. If you experience issues with the command line options, you can always run riddlc without any options and it will explain the options your version supports. Common Options Some options are common to all the commands.
-h (&amp;ndash;help) Causes riddlc to print out help and usage information and exit.</description></item><item><title>Binary AST</title><link>https://riddl.tech/tooling/riddlc/translation/bast/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/tooling/riddlc/translation/bast/</guid><description>When the riddlc compiler parses a RIDDL document, it translates it to an Abstract Syntax Tree (AST) in memory. The AST is then used by other passes to validate and translate the AST into other forms. The binary AST (BAST) translator converts the AST in memory into a binary format that is stored for later usage. Saving the BAST format and then reading it back into the compiler avoids the time to both parse the RIDDL document and validate it for consistency.</description></item><item><title>State</title><link>https://riddl.tech/language/root/domain/context/entity/state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/root/domain/context/entity/state/</guid><description>The state definitions of an entity define the structure of the information that the entity retains as its current state.
Syntax Example The state of an entity is defined with the state keyword within the content of an entity definition, like this:
entity Car { type Propulsion = any of { ICE, Electric, Steam, Diesel, EMDrive } state Static is { wheels: Integer doors: Integer rightHandDrive: Boolean propulsion: Propulsion } } One of the primary purposes of an entity is to represent the characteristics of the entity with state information.</description></item><item><title>Terminals</title><link>https://riddl.tech/audience/developers-guide/grammar/terminals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/audience/developers-guide/grammar/terminals/</guid><description>This file shows the definition of the terminal symbols, as productions, and grouped in categories:
(* Terminal symbol definitions in various categories *) Terminals = Punctuation | Options | Keywords | Predefined | Readability | Operators; Punctuation = asterisk | comma | colon | curlyOpen | curlyClose | dot | equals | ellipsis | ellipsisQuestion | plus | question | quote | roundOpen | roundClose | squareOpen | squareClose | undefined | verticalBar ; asterisk = &amp;#34;*&amp;#34;; comma = &amp;#34;,&amp;#34;; colon = &amp;#34;:&amp;#34;; curlyOpen = &amp;#34;{&amp;#34;; curlyClose = &amp;#34;}&amp;#34;; dot = &amp;#34;.</description></item><item><title>Documentation Conventions</title><link>https://riddl.tech/language/common/doc-conventions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/doc-conventions/</guid><description>This page defines the conventions we use throughout this documentation.
RIDDL Snippets Whenever we include RIDDL source code in the documentation it will be in a fixed sized font like this:
domain MyDomain is { ??? } Notes Whenever an incidental note needs to be presented, it will be shown in blue like this paragraph. Recommendations Whenever an important recommendation needs to be made it will be shown in green like this paragraph.</description></item><item><title>Language Conventions</title><link>https://riddl.tech/language/common/lang-conventions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/lang-conventions/</guid><description>Introduction Syntax conventions of RIDDL are very simple and lenient. The intended audience is business owners, business analysts, domain engineers, and software architects. It is intentionally simple and readable. The language is free in its formatting. It does not require indentation and its various constructs can be arranged on any line. RIDDL supports the definition of a variety of concepts taken directly from Domain Driven Design and the Unified Modeling Language as well as software architecture.</description></item><item><title>Descriptions</title><link>https://riddl.tech/language/common/descriptions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/descriptions/</guid><description>The RIDDL syntax is simply a hierarchical arrangement of definitions. Each definition can have a description. Descriptions are used to generate documentation and follow markdown conventions.
Examples There are several ways to describe a definition. In each of the examples we attach a description to some domain named Foo. The definition is not important for our purposes here. Descriptions come after the definition using one of four phrases:
described by described as explained by explained as These four phrases are equivalent but provided to suit the nature of the definitions to which they may be applied.</description></item><item><title>Options</title><link>https://riddl.tech/language/root/domain/context/entity/options/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/root/domain/context/entity/options/</guid><description>The optional entity kind prefix is a directive that suggests how the entity might handle its state and received messages. In the example above, we expect the &amp;ldquo;Printer&amp;rdquo; entity to be a physical device. An &amp;ldquo;actor&amp;rdquo; entity in of the same name could be expected to be a person who prints.
The options available suggest how the entity might handle its state and message input:
kind - indicates the intended kind of entity in an argument to the kind entity.</description></item><item><title>Common</title><link>https://riddl.tech/audience/developers-guide/grammar/common/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/audience/developers-guide/grammar/common/</guid><description>A number of frequently used productions are useful to understand in the sections that follow. Commentary follows the grammar.
(* Common RIDDL EBNF Grammar Productions *) (******************************************************************** COMMON *) any char = ? any UTF-8 character ? ; any but newline = any char - ( &amp;#34;\n&amp;#34; | &amp;#34;\r&amp;#34; ) ; nonquote = any char - &amp;#39;&amp;#34;&amp;#39; ; digits = &amp;#34;0&amp;#34; | &amp;#34;1&amp;#34; | &amp;#34;2&amp;#34; | &amp;#34;3&amp;#34; | &amp;#34;4&amp;#34; | &amp;#34;5&amp;#34; | &amp;#34;6&amp;#34; | &amp;#34;7&amp;#34; | &amp;#34;8&amp;#34; | &amp;#34;9&amp;#34; ; literalInteger = digits literalString = quote nonquote quote ; literalStrings = literalString { literalString } ; markdownLine = verticalBar, any but newline, newline ; markdownLines= markdownLine { markdownLine.</description></item><item><title>Diagrams</title><link>https://riddl.tech/tooling/riddlc/translation/diagrams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/tooling/riddlc/translation/diagrams/</guid><description/></item><item><title>How To Build `riddlc`</title><link>https://riddl.tech/tooling/riddlc/build/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/tooling/riddlc/build/</guid><description>1. Obtain source code &amp;gt; git clone https://github.com/reactific/riddl.git &amp;gt; cd riddl 2. Install JDK Please follow the directions provided by Adoptium to install OpenJDK on your machine. For MacOS users, this boils down to:
brew install --cask temurin 3. Install sbt Please follow the directions to install sbt which orchestrates the build for RIDDL. For MacOS users, this boils down to:
&amp;gt; brew install sbt 4. Build Within the cloned repository&amp;rsquo;s directory (step 1 above), run this command:</description></item><item><title>Identifiers</title><link>https://riddl.tech/language/common/identifiers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/identifiers/</guid><description>Identifiers are the names of definitions. In the following domain definition,
domain foo is { ??? } the identifier is foo. Identifiers can be specified in two ways:
simple: any alphabetic character followed by alphanumerics or underscore quoted: &amp;quot; followed by a string of characters chosen from this set: a-zA-Z0-9_+\-|/@$%&amp;amp;, :&amp;quot; followed by a &amp;quot; Path Identifiers In several places in RIDDL, you may need to reference a definition in another definition.</description></item><item><title>Invariants</title><link>https://riddl.tech/language/root/domain/context/entity/invariants/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/root/domain/context/entity/invariants/</guid><description>Invariants specify rules about the state of an entity that must never be violated. Invariants typically come from business logic assertions. For example, a business axiom of a warehouse might be that the supply of a product should never be below 1. That is, the warehouse should never completely run out of a product it is storing. Reality, of course, must account for the supply running out; nevertheless specifying an invariant on the business intent may be important.</description></item><item><title>Pipes</title><link>https://riddl.tech/language/root/domain/streaming/pipe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/root/domain/streaming/pipe/</guid><description>Pipes are uni-directional conduits for reliably transmitting data of a particular type between the publishers and consumers attached at the ends of the pipe.
Syntax Example pipe WeatherForecast is { options rate(1000), paritions(7), transmits type Forecast } In the foregoing, a pipe named WeatherForecast is defined to transmit the data type named Forecast and with two options:
rate - an expected sustained rate of 1000 data points per second partitions - a minimum number of partitions on the data of 7 Data Transmission Type Pipes can transmit any data type that RIDDL can specify.</description></item><item><title>RBBQ Scenarios</title><link>https://riddl.tech/examples/scenario/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/examples/scenario/</guid><description>Case Study The Reactive BBQ restaurant chain has determined that their existing restaurant operations system is not suitably meeting their needs and have hired a high technology consulting company to provide some needed guidance on how they can improve their customer service, tracking, and reliability.
What follows are the interviews conducted with key personnel at Reactive BBQ in order to identify the issues.
CEO of Reactive BBQ How would you describe your restaurants?</description></item><item><title>Domain</title><link>https://riddl.tech/audience/developers-guide/grammar/domain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/audience/developers-guide/grammar/domain/</guid><description>See domains for examples and explanations of the following grammar productions
(* RIDDL EBNF Grammar for knowledge domains *) domain include = &amp;#34;include&amp;#34;, literalString domain content = typeDef | topic | interaction | context | domain | domainInclude domain = &amp;#34;domain&amp;#34;, identifier, &amp;#34;is&amp;#34;, &amp;#34;{&amp;#34;, (undefined | domainContent), &amp;#34;}&amp;#34;, description</description></item><item><title>Examples</title><link>https://riddl.tech/language/common/examples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/examples/</guid><description>RIDDL uses Gherkin examples in various places to express a functionality or behavior requirement on the definition that uses it. Gherkin examples are used in these places:
Adaptors Entity Handlers Functions Processors Saga Actions Story Structure Gherkin is a language developed by SmartBear Software, a vendor of software quality tools, for the cucumber testing system. RIDDL uses a subset of the language as SmartBear has defined it. Four constructs are used in RIDDL:</description></item><item><title>Hugo Docs</title><link>https://riddl.tech/tooling/riddlc/translation/hugo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/tooling/riddlc/translation/hugo/</guid><description>One of the main features of the RIDDL compiler is generating HTML documentation. The documentation enjoys the advantage of being more complete and accurate due to the compiler&amp;rsquo;s rigorous analyses. The riddlc compiler generates Hugosources for conversion to a web-site by the hugo generator. See Hugo Documentation for details on how to</description></item><item><title>Installing `riddlc`</title><link>https://riddl.tech/tooling/riddlc/install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/tooling/riddlc/install/</guid><description>This guide helps you to install the riddlc tool on your local computer. Before installation, you will need to follow the steps defined on the build page.
Universal Installer RIDDL&amp;rsquo;s build system can generate a universal installation package that produces a zip file that can be unpacked and it provides a script to run on MacOS, Windows, and Linux.
1. Build Universal Installer &amp;gt; project riddlc &amp;gt; universal:packageBin 2. Move Generated ZIP File a.</description></item><item><title>Processors</title><link>https://riddl.tech/language/root/domain/streaming/processor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/root/domain/streaming/processor/</guid><description>As the name indicates, a RIDDL processor definition specifies the inputs and outputs of some processor of data. The inputs to the processor are declared with inlet statements and the outputs from the processor are declared with outlet statements.
Inlets An inlet statement in the definition of a processor provides the name and data type for an input to the processor. There can be multiple inlets to the processor but each one must have a separate inlet statement.</description></item><item><title>Projections</title><link>https://riddl.tech/language/root/domain/context/projections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/root/domain/context/projections/</guid><description>Introduction A projection is a read-only view of entity information. Projections are necessary since entities use event sourcing which is not a query-friendly format.
Here&amp;rsquo;s the projection process. Usually, events are logged as they are kept appended at the end of the log file. Logs are string and text. To retrieving meaningful information out of logs, logs are transformed into a more query-friendly format and stored in queriable repository or DB.</description></item><item><title>Reactive BBQ</title><link>https://riddl.tech/examples/reactivebbq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/examples/reactivebbq/</guid><description>domain ReactiveBBQ is { author is { name: &amp;#34;Reid Spencer&amp;#34; email: &amp;#34;reid@reactific.com&amp;#34; organization: &amp;#34;Reactific Software LLC&amp;#34; title: &amp;#34;President&amp;#34; url: http://reactific.com/ } include &amp;#34;restaurant/domain&amp;#34; include &amp;#34;backoffice/domain&amp;#34; include &amp;#34;corporate/domain&amp;#34; } explained as { | |A domain to encapsulate the entire enterprise named Reactive BBQ. |It is divided into three subdomains: |* Restaurant -- handles each of the restaurant locations |* Back Office -- handles all the back office supplies and menus |* Corporate -- handles the corporate web site, marketing, accounting and HR |This domain definition is designed to be instructive in the RIDDL language.</description></item><item><title>Types</title><link>https://riddl.tech/language/common/types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/types/</guid><description>Introduction The RIDDL language allows users to define data types. Definitions of types are more limited in RIDDL than in programming languages on purpose. The type system must be easily understandable by non-programmers as the domain engineer or domain expert is likely the most frequent user.
Predefined Types RIDDL supports several predefined types that just &amp;ldquo;exist&amp;rdquo; because they are fundamental and well understood in any targeted computing environment. These predefined type names can be used anywhere that a type definition is needed, for example in a field of an entity&amp;rsquo;s state definition see here</description></item><item><title>Expressions</title><link>https://riddl.tech/language/common/expressions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/expressions/</guid><description>RIDDL allows expressions to be specified in various places. Most frequently they are the operands to message constructors and when clauses in Gherkin examples. This page shows you what you can do with expressions in RIDDL.
Expressions Expressions compute values of arbitrary types. Since RIDDL is not a programming language, the syntax used for expressions is minimal and abstract. There is no attempt in RIDDL to be computationally complete. Supporting expression is merely for the convenience to requirements writers.</description></item><item><title>Compilation</title><link>https://riddl.tech/tooling/riddlc/compilation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/tooling/riddlc/compilation/</guid><description>Introduction The Riddl compiler performs several analyses which are described in this section and known collectively as compilation. Each of these analyses occurs in a compilation phase, as described in the following sections.
Lexical Analysis Riddl uses the excellent fastparse library by Li Haoyi. This phase parses the raw textual input to make sure it is syntactically correct. From that syntax, an abstract syntax tree (AST) is produced. Incorrect syntax leads to errors without further analysis.</description></item><item><title>Context</title><link>https://riddl.tech/audience/developers-guide/grammar/context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/audience/developers-guide/grammar/context/</guid><description>DDD bounded contexts are represented in RIDDL with the context definition whose syntax is:
(* RIDDL EBNF Grammar for bounded contexts *) context options = options(&amp;#34;wrapper&amp;#34; | &amp;#34;gateway&amp;#34; | &amp;#34;function&amp;#34;) context include = &amp;#34;include&amp;#34;, literalString context definitions = typedef | entity | adaptor | interaction | contextInclude context = &amp;#34;context&amp;#34;, identifier, is, open, (undefined | context options, context definitions), close, description }</description></item><item><title>Features</title><link>https://riddl.tech/language/root/domain/context/features/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/root/domain/context/features/</guid><description>A Feature is a requirement on a context. Features are specified very similarly to the Gherkin language. The same keywords are used and the style is more like RIDDL syntax. If you&amp;rsquo;re already familiar with Gherkin then an example should suffice:
Feature &amp;#34;Guess the word&amp;#34; is { // The first example has two steps Scenario &amp;#34;Maker starts a game&amp;#34; is { When the Maker starts a game Then the Maker waits for a Breaker to join } // The second example has three steps Scenario &amp;#34;Breaker joins a game&amp;#34; is { Given the Maker has started a game with a word When the Breaker joins the Maker&amp;#39;s game Then the Breaker must guess a word knowing the length of the Maker&amp;#39;s word choice.</description></item><item><title>Includes</title><link>https://riddl.tech/language/common/includes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/includes/</guid><description>An include statement is not a RIDDL definition but an instruction to the compiler to lexically replace the include statement with the content of another file. The name of the file to include is the statement&amp;rsquo;s only parameter, like this:
include &amp;#34;other-file.riddl&amp;#34; The include statement is only permitted where major definitions are expected, specifically at root level, and in the bodies of domain, context, entity, and pipe definitions.</description></item><item><title>OpenAPI</title><link>https://riddl.tech/tooling/riddlc/translation/openapi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/tooling/riddlc/translation/openapi/</guid><description>RIDDL can generate OpenAPI (Swagger) input to document Application Programming Interfaces</description></item><item><title>Plants</title><link>https://riddl.tech/language/root/domain/streaming/plant/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/root/domain/streaming/plant/</guid><description>A RIDDL plant is a definition that combines pipes with processors to specify a model of how data should flow. You may define as many plants as needed but each plant is a closed system without the ability of the RIDDL model to express the sharing of data between the plants. This is done deliberately to prevent unintentional contamination of data in large models.
Joints The purpose of a plant definition is to provide the blueprint for how a set of pipes, processors, and entities are joined together so that data may flow end-to-end.</description></item><item><title>Principles</title><link>https://riddl.tech/audience/developers-guide/principles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/audience/developers-guide/principles/</guid><description>RIDDL is a high level system specification language and as such must obey some principles of such languages. This page provides those principles.
1: Declarative RIDDL is not an implementation language and does not pretend to be computationally complete. RIDDL adopts this what not how principle. Details are for software developers. The analyst or architect that writes RIDDL documents wants to only specify what the system is while abstracting away the process of constructing it.</description></item><item><title>Entity</title><link>https://riddl.tech/audience/developers-guide/grammar/entity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/audience/developers-guide/grammar/entity/</guid><description>(* RIDDL EBNF Grammar For Entity definition *) entity = entity kind, &amp;#34;entity&amp;#34;, &amp;#34;is&amp;#34;, &amp;#34;{&amp;#34;, entity options, entity definitions, &amp;#34;}&amp;#34;, description ; entity kind = [ &amp;#34;device&amp;#34; | &amp;#34;actor&amp;#34; | &amp;#34;concept&amp;#34;] ; entity options = single option | multi options ; single-option = &amp;#34;option&amp;#34;, &amp;#34;is&amp;#34;, entity option kinds; multi-option = &amp;#34;options&amp;#34;, &amp;#34;(&amp;#34;, { entity option kinds }, &amp;#34;)&amp;#34;; entity option kinds = &amp;#34;event sourced&amp;#34; | &amp;#34;value&amp;#34; | &amp;#34;aggregate&amp;#34; | &amp;#34;persistent&amp;#34; | &amp;#34;consistent&amp;#34; | &amp;#34;available&amp;#34;; entity definition = handler | feature | function | invariant | typeDef | state; entity definitions = entity definition { entity definition } ; entity state = &amp;#34;state&amp;#34;, identifier, &amp;#34;is&amp;#34;, &amp;#34;{&amp;#34;, identifier, &amp;#34;is&amp;#34;, typeExpression, &amp;#34;}&amp;#34;, description State A state is defined with the state keyword in the content of an entity using this syntax:</description></item><item><title>Functions</title><link>https://riddl.tech/language/common/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/functions/</guid><description>Introduction Functions are pieces of processing that can be attached to entity, consumer, and api definitions. A function has a set of inputs (its requirements) and a set of output (what it yields). Functions need not be pure and often have side effects through the state changes of an entity.
Example Here&amp;rsquo;s an example of a function, named riddle, that requires a Subject(String) type and returns a Riddle (String) type.</description></item><item><title>Handler</title><link>https://riddl.tech/language/root/domain/context/entity/handler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/root/domain/context/entity/handler/</guid><description>A handler in an entity specifies how an entity handles its input messages.
Handlers are specified with the handler keyword and enclose a set of on clauses that specify what to do with a given event when that handler is active. There are four kinds of on clauses distinguished by the kind of message they handle (command, event, query, and reaction) as detailed in the following sections
Command Handler A command handler specifies which persistent event is generated for a given command.</description></item><item><title>Kalix</title><link>https://riddl.tech/tooling/riddlc/translation/kalix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/tooling/riddlc/translation/kalix/</guid><description>The Kalix platform-as-a-service system represents one of the easiest methods by which RIDDL models can be turned into running systems. The riddlc program generates Kalix style protobuffers files from the RIDDL model. Kalix uses these files to generate Scala, Java, Javascript or Python code with a fill-in-the-blanks style for just the business logic.</description></item><item><title>Function</title><link>https://riddl.tech/language/root/domain/context/entity/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/root/domain/context/entity/functions/</guid><description>TBD</description></item><item><title>Akka</title><link>https://riddl.tech/tooling/riddlc/translation/akka/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/tooling/riddlc/translation/akka/</guid><description>The goal of the Akka translator is to generate all the infrastructure code needed to support the domain(s) defined in the RIDDL input. While this does produce a working system, it also relieves developers of much of the repetitive, detail oriented infrastructure that is relatively boring compared to the business logic of the system.
This translator recognizes that its output will be co-mingled with the business logic output that developers are writing and keeps them separate.</description></item><item><title>Imports</title><link>https://riddl.tech/language/common/imports/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/imports/</guid><description>This feature is not implemented yet.
An import statement may be used to import a definition from a BAST file that was generated from a prior compilation. Import statements help to save time when a prior compilation has completed and been saved as a BAST file.</description></item><item><title>Other Translators</title><link>https://riddl.tech/tooling/riddlc/translation/others/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/tooling/riddlc/translation/others/</guid><description/></item><item><title>Options</title><link>https://riddl.tech/language/common/options/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/language/common/options/</guid><description>Many definitions can have options. These are hints or processing instructions to the various translator tools.
need more detail</description></item><item><title>Releasing RIDDL</title><link>https://riddl.tech/audience/developers-guide/releasing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/audience/developers-guide/releasing/</guid><description>This is a &amp;ldquo;how to&amp;rdquo; guide on releasing the software.
Build &amp;amp; Test &amp;gt; cd riddl # top level directory of repository &amp;gt; sbt &amp;#34;clean ; test&amp;#34; ... [info] All tests passed. If all tests do not pass, stop and fix the software
Set Version Pick a version number, x.y.z, based on current version and semantic versioning rules Formulate a short description string for the release, call it desc &amp;gt; git tag -a ${x.</description></item><item><title/><link>https://riddl.tech/audience/authors-guide/design-tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/audience/authors-guide/design-tips/</guid><description>title: &amp;ldquo;Design Tips&amp;rdquo; description: &amp;ldquo;Tips On Designing RIDDL Specificatons&amp;rdquo; date: 2022-02-25T10:50:32-07:00 draft: true weight: 10 Domain Hierarchy When considering how to organize your specification into a set , there are no formal rules. Domains are fuzzy concepts on purpose. However, here are a few things that might help:
Domain, Subdomain, Bounded Context, Problem/Solution Space in DDD: Clearly Defined Domain Drive Design: Domain Definition Use the communication structure of the organization per Conway&amp;rsquo;s Law Use the Event Storming and then look for the event groupings.</description></item><item><title/><link>https://riddl.tech/privacy-policy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/privacy-policy/</guid><description>Static Web Site This is a static site. It does not use cookies, has no ability to collect your information, and does not invade your privacy. This site is merely for documentation that you may use as you see fit.</description></item><item><title>Contact Us</title><link>https://riddl.tech/contact/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/contact/</guid><description>TBD</description></item><item><title>Search Result</title><link>https://riddl.tech/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>reid@reactific.com (Reid Spencer)</author><guid>https://riddl.tech/search/</guid><description/></item></channel></rss>